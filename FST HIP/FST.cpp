
#include <hip/hip_runtime.h>
#include "FST.hpp"
#include "Platform.hpp"
#include "Surface.hpp"
#include "Trig.hpp"
#include "utils.hpp"
#include <iomanip>
#include <chrono>

# define M_PI                  3.14159265358979323846  /* pi */

# define sinsG(x)              gSineTableG[(unsigned short)(int) (x) >> 4]
# define cossG(x)              gCosineTableG[(unsigned short)(int) (x) >> 4]
# define revAtansG(x)          gReverseArctanTableG[(unsigned short)(int) (x)]
# define sign(x)               (((x) > 0) - ((x) < 0))

class SurfaceG {
public:
    short vertices[3][3];
    float normal[3];
    float origin_offset;
    float lower_y;
    float upper_y;

    float min_x;
    float max_x;
    float min_z;
    float max_z;

    bool is_lava;

    __device__ SurfaceG(short x0, short y0, short z0, short x1, short y1, short z1, short x2, short y2, short z2, bool lava) {
        short verts[3][3] = { {x0, y0, z0}, {x1, y1, z1}, {x2, y2, z2} };
        set_vertices(verts);
        is_lava = lava;
    }

    __device__ SurfaceG(short x0, short y0, short z0, short x1, short y1, short z1, short x2, short y2, short z2) {
        short verts[3][3] = { {x0, y0, z0}, {x1, y1, z1}, {x2, y2, z2} };
        set_vertices(verts);
        is_lava = false;
    }

    __device__ SurfaceG(short verts[3][3]) {
        set_vertices(verts);
    }

    __device__ SurfaceG() {}

    __device__ void set_vertices(short verts[3][3]) {
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 3; ++j) {
                vertices[i][j] = verts[i][j];
            }
        }

        lower_y = fminf(fminf(vertices[0][1], vertices[1][1]), vertices[2][1]) - 5;
        upper_y = fmaxf(fmaxf(vertices[0][1], vertices[1][1]), vertices[2][1]) + 5;

        min_x = fminf(fminf(vertices[0][0], vertices[1][0]), vertices[2][0]);
        max_x = fmaxf(fmaxf(vertices[0][0], vertices[1][0]), vertices[2][0]);
        min_z = fminf(fminf(vertices[0][2], vertices[1][2]), vertices[2][2]);
        max_z = fmaxf(fmaxf(vertices[0][2], vertices[1][2]), vertices[2][2]);

        calculate_normal();
    }

    __device__ void calculate_normal() {
        normal[0] = (vertices[1][1] - vertices[0][1]) * (vertices[2][2] - vertices[1][2]) - (vertices[1][2] - vertices[0][2]) * (vertices[2][1] - vertices[1][1]);
        normal[1] = (vertices[1][2] - vertices[0][2]) * (vertices[2][0] - vertices[1][0]) - (vertices[1][0] - vertices[0][0]) * (vertices[2][2] - vertices[1][2]);
        normal[2] = (vertices[1][0] - vertices[0][0]) * (vertices[2][1] - vertices[1][1]) - (vertices[1][1] - vertices[0][1]) * (vertices[2][0] - vertices[1][0]);

        float mag = sqrtf(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);

        mag = (float)(1.0 / mag);
        normal[0] *= mag;
        normal[1] *= mag;
        normal[2] *= mag;

        origin_offset = -(normal[0] * vertices[0][0] + normal[1] * vertices[0][1] + normal[2] * vertices[0][2]);
    }
};

__constant__ const int maxF3Turn = 522;
__constant__ const int nTenKFloors = 4;
__constant__ float tenKFloors[nTenKFloors][9] = {
    { -613.0, -306.0, -4607.0, -4453.0, -3071.0, -2661.0, -0.9361413717, 0.351623833, 0.0 },
    { -613.0, -306.0, -4146.0, -3993.0, -2661.0, -3071.0, 0.936891377, 0.349620432, 0.0 },
    { -7065.0, -6041.0, 307.0, 322.0, -2866.0, -3071.0, 0.0146370763, 0.03655698895, 0.9992243648 },
    { -7065.0, -6553.0, 307.0, 322.0, -2866.0, -3071.0, 0, 0.07297563553, 0.9973337054 }
};

__constant__ int slideAngleSampleRate = 4;

__constant__ const short default_triangles[2][3][3] = { {{307, 307, -306}, {-306, 307, -306}, {-306, 307, 307}}, {{307, 307, -306}, {-306, 307, 307}, {307, 307, 307}} };
__constant__ const float normal_offsets[4][3] = { {0.01f, -0.01f, 0.01f}, {-0.01f, -0.01f, 0.01f}, {-0.01f, -0.01f, -0.01f}, {0.01f, -0.01f, -0.01f} };

__constant__ const int n_y_ranges = 1;
__constant__ double lower_y[n_y_ranges] = { -1357.0 };
__constant__ double upper_y[n_y_ranges] = { 32767.0 };

__constant__ const int n_floor_ranges = 9;
__constant__ const double lower_floor[n_floor_ranges] = { -1357.0, -743.0, 127.0, 675.0, 2687.0, 4325.0, 4940.0, 5170.0, 5400.0 };
__constant__ const double upper_floor[n_floor_ranges] = { -1125.0, -665.0, 410.0, 1331.0, 3789.0, 4506.0, 5018.0, 5248.0, 5478.0 };

__constant__ bool filter_floor_ranges = true;
__constant__ bool fall_through_pus = true;

__constant__ struct GPULimits limits;

__device__ bool deviceTest = false;

__device__ struct SolStruct solutions;
__device__ struct SolCounts counts;

__device__ float* squishSpots;
__device__ int* nSquishSpots;

__device__ struct StrainSetup* strainSetups;
__device__ int nStrainSetups;

__device__ int maxAngleRange;

__device__ int maxFSpeedLevels;
__device__ int maxSSpeedLevels;

__device__ float magSet[4097];
__device__ int magCount;

__device__ signed char uniqueSticks[65536][2];
__device__ int nUniqueSticks;

__device__ float gSineTableG[4096] = { 0.000000000f, 0.0015339801f, 0.0030679568f, 0.004601926f, 0.0061358847f, 0.007669829f, 0.009203754f, 0.010737659f, 0.012271538f, 0.0138053885f, 0.015339206f, 0.016872987f, 0.018406730f, 0.019940428f, 0.021474080f, 0.023007682f, 0.024541229f, 0.026074719f, 0.027608145f, 0.029141508f, 0.030674804f, 0.032208025f, 0.033741172f, 0.035274237f, 0.036807224f, 0.038340122f, 0.039872926f, 0.041405641f, 0.042938258f, 0.044470772f, 0.046003181f, 0.047535483f, 0.049067676f, 0.050599750f, 0.052131705f, 0.053663537f, 0.055195246f, 0.056726821f, 0.058258265f, 0.059789572f, 0.061320737f, 0.062851757f, 0.064382628f, 0.065913349f, 0.067443922f, 0.068974331f, 0.070504576f, 0.072034650f, 0.073564567f, 0.075094298f, 0.076623864f, 0.078153245f, 0.079682440f, 0.081211448f, 0.082740262f, 0.084268890f, 0.085797310f, 0.087325536f, 0.088853553f, 0.090381362f, 0.091908954f, 0.093436338f, 0.094963498f, 0.096490428f, 0.098017141f, 0.099543616f, 0.101069860f, 0.102595866f, 0.104121633f, 0.105647154f, 0.107172422f, 0.108697444f, 0.110222206f, 0.111746714f, 0.113270953f, 0.114794925f, 0.116318628f, 0.117842063f, 0.119365215f, 0.120888084f, 0.122410677f, 0.123932973f, 0.125454977f, 0.126976699f, 0.128498107f, 0.130019218f, 0.131540030f, 0.133060530f, 0.134580702f, 0.136100575f, 0.137620121f, 0.139139339f, 0.140658244f, 0.142176807f, 0.143695027f, 0.145212919f, 0.146730468f, 0.148247674f, 0.149764538f, 0.151281044f, 0.152797192f, 0.154312968f, 0.155828401f, 0.157343462f, 0.158858150f, 0.160372451f, 0.161886394f, 0.163399950f, 0.164913118f, 0.166425899f, 0.167938292f, 0.169450298f, 0.170961887f, 0.172473088f, 0.173983872f, 0.175494254f, 0.177004218f, 0.178513765f, 0.180022895f, 0.181531608f, 0.183039889f, 0.184547737f, 0.186055154f, 0.187562123f, 0.189068660f, 0.190574750f, 0.192080393f, 0.193585590f, 0.195090324f, 0.196594596f, 0.198098406f, 0.199601755f, 0.201104641f, 0.202607036f, 0.204108968f, 0.205610409f, 0.207111374f, 0.208611846f, 0.210111842f, 0.211611331f, 0.213110313f, 0.214608818f, 0.216106802f, 0.217604280f, 0.219101235f, 0.220597684f, 0.222093627f, 0.223589033f, 0.225083917f, 0.226578265f, 0.228072077f, 0.229565367f, 0.231058106f, 0.232550308f, 0.234041959f, 0.235533059f, 0.237023607f, 0.238513589f, 0.240003020f, 0.241491884f, 0.242980182f, 0.244467899f, 0.245955050f, 0.247441620f, 0.248927608f, 0.250413001f, 0.251897812f, 0.253382027f, 0.254865646f, 0.256348670f, 0.257831097f, 0.259312928f, 0.260794103f, 0.262274712f, 0.263754666f, 0.265234023f, 0.266712755f, 0.268190861f, 0.269668311f, 0.271145165f, 0.272621363f, 0.274096906f, 0.275571823f, 0.277046084f, 0.278519690f, 0.279992640f, 0.281464934f, 0.282936573f, 0.284407526f, 0.285877824f, 0.287347466f, 0.288816422f, 0.290284663f, 0.291752249f, 0.293219149f, 0.294685364f, 0.296150893f, 0.297615707f, 0.299079835f, 0.300543249f, 0.302005947f, 0.303467959f, 0.304929227f, 0.306389809f, 0.307849646f, 0.309308767f, 0.310767144f, 0.312224805f, 0.313681751f, 0.315137923f, 0.316593379f, 0.318048090f, 0.319502026f, 0.320955247f, 0.322407693f, 0.323859364f, 0.325310290f, 0.326760441f, 0.328209847f, 0.329658449f, 0.331106305f, 0.332553357f, 0.333999664f, 0.335445136f, 0.336889863f, 0.338333756f, 0.339776874f, 0.341219217f, 0.342660725f, 0.344101429f, 0.345541328f, 0.346980423f, 0.348418683f, 0.349856138f, 0.351292759f, 0.352728546f, 0.354163527f, 0.355597675f, 0.357030958f, 0.358463407f, 0.359895051f, 0.361325800f, 0.362755716f, 0.364184797f, 0.365612984f, 0.367040336f, 0.368466824f, 0.369892448f, 0.371317208f, 0.372741073f, 0.374164075f, 0.375586182f, 0.377007425f, 0.378427744f, 0.379847199f, 0.381265759f, 0.382683426f, 0.384100199f, 0.385516047f, 0.386931002f, 0.388345033f, 0.389758170f, 0.391170382f, 0.392581671f, 0.393992037f, 0.395401478f, 0.396809995f, 0.398217559f, 0.399624199f, 0.401029885f, 0.402434647f, 0.403838456f, 0.405241311f, 0.406643212f, 0.408044159f, 0.409444153f, 0.410843164f, 0.412241220f, 0.413638324f, 0.415034413f, 0.416429549f, 0.417823702f, 0.419216901f, 0.420609087f, 0.422000259f, 0.423390478f, 0.424779683f, 0.426167876f, 0.427555084f, 0.428941280f, 0.430326492f, 0.431710660f, 0.433093816f, 0.434475958f, 0.435857087f, 0.437237173f, 0.438616246f, 0.439994276f, 0.441371262f, 0.442747235f, 0.444122136f, 0.445496023f, 0.446868837f, 0.448240608f, 0.449611336f, 0.450980991f, 0.452349573f, 0.453717113f, 0.455083579f, 0.456448972f, 0.457813293f, 0.459176540f, 0.460538715f, 0.461899787f, 0.463259786f, 0.464618683f, 0.465976506f, 0.467333198f, 0.468688816f, 0.470043331f, 0.471396744f, 0.472749025f, 0.474100202f, 0.475450277f, 0.476799220f, 0.478147060f, 0.479493767f, 0.480839342f, 0.482183784f, 0.483527064f, 0.484869242f, 0.486210287f, 0.487550169f, 0.488888890f, 0.490226477f, 0.491562903f, 0.492898196f, 0.494232297f, 0.495565265f, 0.496897042f, 0.498227656f, 0.499557108f, 0.500885367f, 0.502212465f, 0.503538370f, 0.504863083f, 0.506186664f, 0.507508993f, 0.508830130f, 0.510150075f, 0.511468828f, 0.512786388f, 0.514102757f, 0.515417874f, 0.516731799f, 0.518044531f, 0.519356012f, 0.520666242f, 0.521975279f, 0.523283124f, 0.524589658f, 0.525895000f, 0.527199149f, 0.528501987f, 0.529803634f, 0.531104028f, 0.532403111f, 0.533701003f, 0.534997642f, 0.536292970f, 0.537587047f, 0.538879931f, 0.540171444f, 0.541461766f, 0.542750776f, 0.544038534f, 0.545324981f, 0.546610177f, 0.547894061f, 0.549176633f, 0.550457954f, 0.551737964f, 0.553016722f, 0.554294109f, 0.555570245f, 0.556845009f, 0.558118522f, 0.559390724f, 0.560661554f, 0.561931133f, 0.563199341f, 0.564466238f, 0.565731823f, 0.566996038f, 0.568258941f, 0.569520533f, 0.570780754f, 0.572039604f, 0.573297143f, 0.574553370f, 0.575808167f, 0.577061653f, 0.578313768f, 0.579564571f, 0.580813944f, 0.582062006f, 0.583308637f, 0.584553957f, 0.585797846f, 0.587040365f, 0.588281572f, 0.589521289f, 0.590759695f, 0.591996670f, 0.593232274f, 0.594466507f, 0.595699310f, 0.596930683f, 0.598160684f, 0.599389315f, 0.600616455f, 0.601842225f, 0.603066623f, 0.604289532f, 0.605511069f, 0.606731117f, 0.607949793f, 0.609167039f, 0.610382795f, 0.611597180f, 0.612810075f, 0.614021540f, 0.615231574f, 0.616440177f, 0.617647290f, 0.618852973f, 0.620057225f, 0.621259987f, 0.622461259f, 0.623661101f, 0.624859512f, 0.626056373f, 0.627251804f, 0.628445745f, 0.629638255f, 0.630829215f, 0.632018745f, 0.633206785f, 0.634393275f, 0.635578334f, 0.636761844f, 0.637943923f, 0.639124453f, 0.640303493f, 0.641481042f, 0.642657042f, 0.643831551f, 0.645004511f, 0.646176040f, 0.647345960f, 0.648514390f, 0.649681330f, 0.650846660f, 0.652010560f, 0.653172851f, 0.654333591f, 0.655492842f, 0.656650543f, 0.657806695f, 0.658961296f, 0.660114348f, 0.661265850f, 0.662415802f, 0.663564146f, 0.664710999f, 0.665856242f, 0.666999936f, 0.668142021f, 0.669282615f, 0.670421541f, 0.671558976f, 0.672694743f, 0.673829019f, 0.674961627f, 0.676092684f, 0.677222192f, 0.678350031f, 0.679476321f, 0.680601001f, 0.681724072f, 0.682845533f, 0.683965385f, 0.685083687f, 0.686200321f, 0.687315345f, 0.688428760f, 0.689540565f, 0.690650702f, 0.691759229f, 0.692866147f, 0.693971455f, 0.695075095f, 0.696177125f, 0.697277486f, 0.698376238f, 0.699473321f, 0.700568795f, 0.701662600f, 0.702754736f, 0.703845263f, 0.704934061f, 0.706021249f, 0.707106769f, 0.708190620f, 0.709272802f, 0.710353374f, 0.711432219f, 0.712509394f, 0.713584840f, 0.714658678f, 0.715730846f, 0.716801286f, 0.717870057f, 0.718937099f, 0.720002532f, 0.721066177f, 0.722128212f, 0.723188460f, 0.724247098f, 0.725303948f, 0.726359129f, 0.727412641f, 0.728464365f, 0.729514420f, 0.730562747f, 0.731609404f, 0.732654274f, 0.733697414f, 0.734738886f, 0.735778570f, 0.736816585f, 0.737852812f, 0.738887310f, 0.739920080f, 0.740951121f, 0.741980433f, 0.743007958f, 0.744033754f, 0.745057762f, 0.746080101f, 0.747100592f, 0.748119354f, 0.749136388f, 0.750151634f, 0.751165152f, 0.752176821f, 0.753186822f, 0.754194975f, 0.755201399f, 0.756205976f, 0.757208824f, 0.758209884f, 0.759209216f, 0.760206699f, 0.761202395f, 0.762196302f, 0.763188422f, 0.764178753f, 0.765167236f, 0.766153991f, 0.767138898f, 0.768122017f, 0.769103348f, 0.770082831f, 0.771060526f, 0.772036374f, 0.773010433f, 0.773982704f, 0.774953127f, 0.775921702f, 0.776888490f, 0.777853429f, 0.778816521f, 0.779777765f, 0.780737221f, 0.781694829f, 0.782650590f, 0.783604503f, 0.784556568f, 0.785506845f, 0.786455214f, 0.787401736f, 0.788346410f, 0.789289236f, 0.790230215f, 0.791169345f, 0.792106569f, 0.793041945f, 0.793975472f, 0.794907153f, 0.795836926f, 0.796764791f, 0.797690868f, 0.798614979f, 0.799537241f, 0.800457656f, 0.801376164f, 0.802292824f, 0.803207517f, 0.804120362f, 0.805031359f, 0.805940390f, 0.806847572f, 0.807752848f, 0.808656156f, 0.809557617f, 0.810457170f, 0.811354876f, 0.812250614f, 0.813144386f, 0.814036310f, 0.814926326f, 0.815814435f, 0.816700578f, 0.817584813f, 0.818467140f, 0.819347501f, 0.820225954f, 0.821102500f, 0.821977139f, 0.822849810f, 0.823720515f, 0.824589312f, 0.825456142f, 0.826321065f, 0.827184021f, 0.828045070f, 0.828904092f, 0.829761207f, 0.830616415f, 0.831469595f, 0.832320869f, 0.833170176f, 0.834017515f, 0.834862888f, 0.835706294f, 0.836547732f, 0.837387204f, 0.838224709f, 0.839060247f, 0.839893818f, 0.840725362f, 0.841554999f, 0.842382610f, 0.843208253f, 0.844031870f, 0.844853580f, 0.845673263f, 0.846490920f, 0.847306609f, 0.848120332f, 0.848932028f, 0.849741757f, 0.850549459f, 0.851355195f, 0.852158904f, 0.852960587f, 0.853760302f, 0.854557991f, 0.855353653f, 0.856147349f, 0.856938958f, 0.857728601f, 0.858516216f, 0.859301805f, 0.860085368f, 0.860866964f, 0.861646473f, 0.862423956f, 0.863199413f, 0.863972843f, 0.864744246f, 0.865513623f, 0.866280973f, 0.867046237f, 0.867809474f, 0.868570685f, 0.869329870f, 0.870086968f, 0.870842040f, 0.871595085f, 0.872346044f, 0.873094976f, 0.873841822f, 0.874586642f, 0.875329375f, 0.876070082f, 0.876808703f, 0.877545297f, 0.878279805f, 0.879012227f, 0.879742622f, 0.880470872f, 0.881197095f, 0.881921291f, 0.882643342f, 0.883363366f, 0.884081244f, 0.884797096f, 0.885510862f, 0.886222541f, 0.886932135f, 0.887639642f, 0.888345063f, 0.889048338f, 0.889749587f, 0.890448749f, 0.891145766f, 0.891840696f, 0.892533541f, 0.893224299f, 0.893912971f, 0.894599497f, 0.895283937f, 0.895966232f, 0.896646500f, 0.897324562f, 0.898000598f, 0.898674488f, 0.899346232f, 0.900015891f, 0.900683403f, 0.901348829f, 0.902012169f, 0.902673304f, 0.903332353f, 0.903989315f, 0.904644072f, 0.905296743f, 0.905947268f, 0.906595707f, 0.907242000f, 0.907886088f, 0.908528090f, 0.909168005f, 0.909805715f, 0.910441279f, 0.911074758f, 0.911706030f, 0.912335157f, 0.912962198f, 0.913587034f, 0.914209783f, 0.914830327f, 0.915448725f, 0.916064978f, 0.916679084f, 0.917290986f, 0.917900801f, 0.918508410f, 0.919113874f, 0.919717133f, 0.920318305f, 0.920917213f, 0.921514034f, 0.922108650f, 0.922701120f, 0.923291445f, 0.923879504f, 0.924465477f, 0.925049245f, 0.925630808f, 0.926210225f, 0.926787496f, 0.927362502f, 0.927935421f, 0.928506076f, 0.929074585f, 0.929640889f, 0.930205047f, 0.930766940f, 0.931326687f, 0.931884289f, 0.932439625f, 0.932992816f, 0.933543801f, 0.934092522f, 0.934639156f, 0.935183525f, 0.935725689f, 0.936265647f, 0.936803460f, 0.937339008f, 0.937872350f, 0.938403547f, 0.938932478f, 0.939459205f, 0.939983726f, 0.940506041f, 0.941026151f, 0.941544056f, 0.942059755f, 0.942573190f, 0.943084419f, 0.943593442f, 0.944100261f, 0.944604814f, 0.945107222f, 0.945607305f, 0.946105242f, 0.946600914f, 0.947094381f, 0.947585583f, 0.948074579f, 0.948561370f, 0.949045897f, 0.949528158f, 0.950008273f, 0.950486064f, 0.950961649f, 0.951435030f, 0.951906145f, 0.952374995f, 0.952841640f, 0.953306019f, 0.953768194f, 0.954228103f, 0.954685748f, 0.955141187f, 0.955594361f, 0.956045270f, 0.956493914f, 0.956940353f, 0.957384527f, 0.957826436f, 0.958266079f, 0.958703458f, 0.959138632f, 0.959571540f, 0.960002124f, 0.960430503f, 0.960856616f, 0.961280465f, 0.961702049f, 0.962121427f, 0.962538481f, 0.962953269f, 0.963365793f, 0.963776052f, 0.964184046f, 0.964589775f, 0.964993238f, 0.965394437f, 0.965793371f, 0.966189981f, 0.966584384f, 0.966976464f, 0.967366278f, 0.967753828f, 0.968139112f, 0.968522072f, 0.968902826f, 0.969281256f, 0.969657362f, 0.970031261f, 0.970402837f, 0.970772147f, 0.971139133f, 0.971503913f, 0.971866310f, 0.972226501f, 0.972584367f, 0.972939968f, 0.973293245f, 0.973644257f, 0.973992944f, 0.974339366f, 0.974683523f, 0.975025356f, 0.975364864f, 0.975702107f, 0.976037085f, 0.976369739f, 0.976700068f, 0.977028131f, 0.977353871f, 0.977677345f, 0.977998495f, 0.978317380f, 0.978633940f, 0.978948176f, 0.979260147f, 0.979569793f, 0.979877114f, 0.980182111f, 0.980484843f, 0.980785251f, 0.981083393f, 0.981379211f, 0.981672704f, 0.981963873f, 0.982252717f, 0.982539296f, 0.982823551f, 0.983105481f, 0.983385086f, 0.983662426f, 0.983937442f, 0.984210074f, 0.984480441f, 0.984748483f, 0.985014260f, 0.985277653f, 0.985538721f, 0.985797524f, 0.986053944f, 0.986308098f, 0.986559927f, 0.986809373f, 0.987056553f, 0.987301409f, 0.987543941f, 0.987784147f, 0.988022029f, 0.988257587f, 0.988490820f, 0.988721669f, 0.988950253f, 0.989176512f, 0.989400446f, 0.989621997f, 0.989841282f, 0.990058184f, 0.990272820f, 0.990485072f, 0.990695000f, 0.990902662f, 0.991107941f, 0.991310835f, 0.991511464f, 0.991709769f, 0.991905689f, 0.992099285f, 0.992290616f, 0.992479563f, 0.992666125f, 0.992850423f, 0.993032336f, 0.993211925f, 0.993389189f, 0.993564129f, 0.993736744f, 0.993906975f, 0.994074881f, 0.994240463f, 0.994403660f, 0.994564593f, 0.994723141f, 0.994879305f, 0.995033205f, 0.995184720f, 0.995333910f, 0.995480776f, 0.995625257f, 0.995767415f, 0.995907247f, 0.996044695f, 0.996179819f, 0.996312618f, 0.996443033f, 0.996571124f, 0.996696889f, 0.996820271f, 0.996941328f, 0.997060061f, 0.997176409f, 0.997290432f, 0.997402132f, 0.997511446f, 0.997618437f, 0.997723043f, 0.997825325f, 0.997925282f, 0.998022854f, 0.998118103f, 0.998211026f, 0.998301566f, 0.998389721f, 0.998475552f, 0.998559058f, 0.998640239f, 0.998719037f, 0.998795450f, 0.998869538f, 0.998941302f, 0.999010682f, 0.999077737f, 0.999142408f, 0.999204755f, 0.999264777f, 0.999322355f, 0.999377668f, 0.999430597f, 0.999481201f, 0.999529421f, 0.999575317f, 0.999618828f, 0.999660015f, 0.999698818f, 0.999735296f, 0.999769390f, 0.999801159f, 0.999830604f, 0.999857664f, 0.999882340f, 0.999904692f, 0.999924719f, 0.999942362f, 0.999957621f, 0.999970615f, 0.999981165f, 0.999989390f, 0.999995291f, 0.999998808f, 1.000000000f, 0.999998808f, 0.999995291f, 0.999989390f, 0.999981165f, 0.999970615f, 0.999957621f, 0.999942362f, 0.999924719f, 0.999904692f, 0.999882340f, 0.999857664f, 0.999830604f, 0.999801159f, 0.999769390f, 0.999735296f, 0.999698818f, 0.999660015f, 0.999618828f, 0.999575317f, 0.999529421f, 0.999481201f, 0.999430597f, 0.999377668f, 0.999322355f, 0.999264777f, 0.999204755f, 0.999142408f, 0.999077737f, 0.999010682f, 0.998941302f, 0.998869538f, 0.998795450f, 0.998719037f, 0.998640239f, 0.998559058f, 0.998475552f, 0.998389721f, 0.998301566f, 0.998211026f, 0.998118103f, 0.998022854f, 0.997925282f, 0.997825325f, 0.997723043f, 0.997618437f, 0.997511446f, 0.997402132f, 0.997290432f, 0.997176409f, 0.997060061f, 0.996941328f, 0.996820271f, 0.996696889f, 0.996571124f, 0.996443033f, 0.996312618f, 0.996179819f, 0.996044695f, 0.995907247f, 0.995767415f, 0.995625257f, 0.995480776f, 0.995333910f, 0.995184720f, 0.995033205f, 0.994879305f, 0.994723141f, 0.994564593f, 0.994403660f, 0.994240463f, 0.994074881f, 0.993906975f, 0.993736744f, 0.993564129f, 0.993389189f, 0.993211925f, 0.993032336f, 0.992850423f, 0.992666125f, 0.992479563f, 0.992290616f, 0.992099285f, 0.991905689f, 0.991709769f, 0.991511464f, 0.991310835f, 0.991107941f, 0.990902662f, 0.990695000f, 0.990485072f, 0.990272820f, 0.990058184f, 0.989841282f, 0.989621997f, 0.989400446f, 0.989176512f, 0.988950253f, 0.988721669f, 0.988490820f, 0.988257587f, 0.988022029f, 0.987784147f, 0.987543941f, 0.987301409f, 0.987056553f, 0.986809373f, 0.986559927f, 0.986308098f, 0.986053944f, 0.985797524f, 0.985538721f, 0.985277653f, 0.985014260f, 0.984748483f, 0.984480441f, 0.984210074f, 0.983937442f, 0.983662426f, 0.983385086f, 0.983105481f, 0.982823551f, 0.982539296f, 0.982252717f, 0.981963873f, 0.981672704f, 0.981379211f, 0.981083393f, 0.980785251f, 0.980484843f, 0.980182111f, 0.979877114f, 0.979569793f, 0.979260147f, 0.978948176f, 0.978633940f, 0.978317380f, 0.977998495f, 0.977677345f, 0.977353871f, 0.977028131f, 0.976700068f, 0.976369739f, 0.976037085f, 0.975702107f, 0.975364864f, 0.975025356f, 0.974683523f, 0.974339366f, 0.973992944f, 0.973644257f, 0.973293245f, 0.972939968f, 0.972584367f, 0.972226501f, 0.971866310f, 0.971503913f, 0.971139133f, 0.970772147f, 0.970402837f, 0.970031261f, 0.969657362f, 0.969281256f, 0.968902826f, 0.968522072f, 0.968139112f, 0.967753828f, 0.967366278f, 0.966976464f, 0.966584384f, 0.966189981f, 0.965793371f, 0.965394437f, 0.964993238f, 0.964589775f, 0.964184046f, 0.963776052f, 0.963365793f, 0.962953269f, 0.962538481f, 0.962121427f, 0.961702049f, 0.961280465f, 0.960856616f, 0.960430503f, 0.960002124f, 0.959571540f, 0.959138632f, 0.958703458f, 0.958266079f, 0.957826436f, 0.957384527f, 0.956940353f, 0.956493914f, 0.956045270f, 0.955594361f, 0.955141187f, 0.954685748f, 0.954228103f, 0.953768194f, 0.953306019f, 0.952841640f, 0.952374995f, 0.951906145f, 0.951435030f, 0.950961649f, 0.950486064f, 0.950008273f, 0.949528158f, 0.949045897f, 0.948561370f, 0.948074579f, 0.947585583f, 0.947094381f, 0.946600914f, 0.946105242f, 0.945607305f, 0.945107222f, 0.944604814f, 0.944100261f, 0.943593442f, 0.943084419f, 0.942573190f, 0.942059755f, 0.941544056f, 0.941026151f, 0.940506041f, 0.939983726f, 0.939459205f, 0.938932478f, 0.938403547f, 0.937872350f, 0.937339008f, 0.936803460f, 0.936265647f, 0.935725689f, 0.935183525f, 0.934639156f, 0.934092522f, 0.933543801f, 0.932992816f, 0.932439625f, 0.931884289f, 0.931326687f, 0.930766940f, 0.930205047f, 0.929640889f, 0.929074585f, 0.928506076f, 0.927935421f, 0.927362502f, 0.926787496f, 0.926210225f, 0.925630808f, 0.925049245f, 0.924465477f, 0.923879504f, 0.923291445f, 0.922701120f, 0.922108650f, 0.921514034f, 0.920917213f, 0.920318305f, 0.919717133f, 0.919113874f, 0.918508410f, 0.917900801f, 0.917290986f, 0.916679084f, 0.916064978f, 0.915448725f, 0.914830327f, 0.914209783f, 0.913587034f, 0.912962198f, 0.912335157f, 0.911706030f, 0.911074758f, 0.910441279f, 0.909805715f, 0.909168005f, 0.908528090f, 0.907886088f, 0.907242000f, 0.906595707f, 0.905947268f, 0.905296743f, 0.904644072f, 0.903989315f, 0.903332353f, 0.902673304f, 0.902012169f, 0.901348829f, 0.900683403f, 0.900015891f, 0.899346232f, 0.898674488f, 0.898000598f, 0.897324562f, 0.896646500f, 0.895966232f, 0.895283937f, 0.894599497f, 0.893912971f, 0.893224299f, 0.892533541f, 0.891840696f, 0.891145766f, 0.890448749f, 0.889749587f, 0.889048338f, 0.888345063f, 0.887639642f, 0.886932135f, 0.886222541f, 0.885510862f, 0.884797096f, 0.884081244f, 0.883363366f, 0.882643342f, 0.881921291f, 0.881197095f, 0.880470872f, 0.879742622f, 0.879012227f, 0.878279805f, 0.877545297f, 0.876808703f, 0.876070082f, 0.875329375f, 0.874586642f, 0.873841822f, 0.873094976f, 0.872346044f, 0.871595085f, 0.870842040f, 0.870086968f, 0.869329870f, 0.868570685f, 0.867809474f, 0.867046237f, 0.866280973f, 0.865513623f, 0.864744246f, 0.863972843f, 0.863199413f, 0.862423956f, 0.861646473f, 0.860866964f, 0.860085368f, 0.859301805f, 0.858516216f, 0.857728601f, 0.856938958f, 0.856147349f, 0.855353653f, 0.854557991f, 0.853760302f, 0.852960587f, 0.852158904f, 0.851355195f, 0.850549459f, 0.849741757f, 0.848932028f, 0.848120332f, 0.847306609f, 0.846490920f, 0.845673263f, 0.844853580f, 0.844031870f, 0.843208253f, 0.842382610f, 0.841554999f, 0.840725362f, 0.839893818f, 0.839060247f, 0.838224709f, 0.837387204f, 0.836547732f, 0.835706294f, 0.834862888f, 0.834017515f, 0.833170176f, 0.832320869f, 0.831469595f, 0.830616415f, 0.829761207f, 0.828904092f, 0.828045070f, 0.827184021f, 0.826321065f, 0.825456142f, 0.824589312f, 0.823720515f, 0.822849810f, 0.821977139f, 0.821102500f, 0.820225954f, 0.819347501f, 0.818467140f, 0.817584813f, 0.816700578f, 0.815814435f, 0.814926326f, 0.814036310f, 0.813144386f, 0.812250614f, 0.811354876f, 0.810457170f, 0.809557617f, 0.808656156f, 0.807752848f, 0.806847572f, 0.805940390f, 0.805031359f, 0.804120362f, 0.803207517f, 0.802292824f, 0.801376164f, 0.800457656f, 0.799537241f, 0.798614979f, 0.797690868f, 0.796764791f, 0.795836926f, 0.794907153f, 0.793975472f, 0.793041945f, 0.792106569f, 0.791169345f, 0.790230215f, 0.789289236f, 0.788346410f, 0.787401736f, 0.786455214f, 0.785506845f, 0.784556568f, 0.783604503f, 0.782650590f, 0.781694829f, 0.780737221f, 0.779777765f, 0.778816521f, 0.777853429f, 0.776888490f, 0.775921702f, 0.774953127f, 0.773982704f, 0.773010433f, 0.772036374f, 0.771060526f, 0.770082831f, 0.769103348f, 0.768122017f, 0.767138898f, 0.766153991f, 0.765167236f, 0.764178753f, 0.763188422f, 0.762196302f, 0.761202395f, 0.760206699f, 0.759209216f, 0.758209884f, 0.757208824f, 0.756205976f, 0.755201399f, 0.754194975f, 0.753186822f, 0.752176821f, 0.751165152f, 0.750151634f, 0.749136388f, 0.748119354f, 0.747100592f, 0.746080101f, 0.745057762f, 0.744033754f, 0.743007958f, 0.741980433f, 0.740951121f, 0.739920080f, 0.738887310f, 0.737852812f, 0.736816585f, 0.735778570f, 0.734738886f, 0.733697414f, 0.732654274f, 0.731609404f, 0.730562747f, 0.729514420f, 0.728464365f, 0.727412641f, 0.726359129f, 0.725303948f, 0.724247098f, 0.723188460f, 0.722128212f, 0.721066177f, 0.720002532f, 0.718937099f, 0.717870057f, 0.716801286f, 0.715730846f, 0.714658678f, 0.713584840f, 0.712509394f, 0.711432219f, 0.710353374f, 0.709272802f, 0.708190620f, 0.707106769f, 0.706021249f, 0.704934061f, 0.703845263f, 0.702754736f, 0.701662600f, 0.700568795f, 0.699473321f, 0.698376238f, 0.697277486f, 0.696177125f, 0.695075095f, 0.693971455f, 0.692866147f, 0.691759229f, 0.690650702f, 0.689540565f, 0.688428760f, 0.687315345f, 0.686200321f, 0.685083687f, 0.683965385f, 0.682845533f, 0.681724072f, 0.680601001f, 0.679476321f, 0.678350031f, 0.677222192f, 0.676092684f, 0.674961627f, 0.673829019f, 0.672694743f, 0.671558976f, 0.670421541f, 0.669282615f, 0.668142021f, 0.666999936f, 0.665856242f, 0.664710999f, 0.663564146f, 0.662415802f, 0.661265850f, 0.660114348f, 0.658961296f, 0.657806695f, 0.656650543f, 0.655492842f, 0.654333591f, 0.653172851f, 0.652010560f, 0.650846660f, 0.649681330f, 0.648514390f, 0.647345960f, 0.646176040f, 0.645004511f, 0.643831551f, 0.642657042f, 0.641481042f, 0.640303493f, 0.639124453f, 0.637943923f, 0.636761844f, 0.635578334f, 0.634393275f, 0.633206785f, 0.632018745f, 0.630829215f, 0.629638255f, 0.628445745f, 0.627251804f, 0.626056373f, 0.624859512f, 0.623661101f, 0.622461259f, 0.621259987f, 0.620057225f, 0.618852973f, 0.617647290f, 0.616440177f, 0.615231574f, 0.614021540f, 0.612810075f, 0.611597180f, 0.610382795f, 0.609167039f, 0.607949793f, 0.606731117f, 0.605511069f, 0.604289532f, 0.603066623f, 0.601842225f, 0.600616455f, 0.599389315f, 0.598160684f, 0.596930683f, 0.595699310f, 0.594466507f, 0.593232274f, 0.591996670f, 0.590759695f, 0.589521289f, 0.588281572f, 0.587040365f, 0.585797846f, 0.584553957f, 0.583308637f, 0.582062006f, 0.580813944f, 0.579564571f, 0.578313768f, 0.577061653f, 0.575808167f, 0.574553370f, 0.573297143f, 0.572039604f, 0.570780754f, 0.569520533f, 0.568258941f, 0.566996038f, 0.565731823f, 0.564466238f, 0.563199341f, 0.561931133f, 0.560661554f, 0.559390724f, 0.558118522f, 0.556845009f, 0.555570245f, 0.554294109f, 0.553016722f, 0.551737964f, 0.550457954f, 0.549176633f, 0.547894061f, 0.546610177f, 0.545324981f, 0.544038534f, 0.542750776f, 0.541461766f, 0.540171444f, 0.538879931f, 0.537587047f, 0.536292970f, 0.534997642f, 0.533701003f, 0.532403111f, 0.531104028f, 0.529803634f, 0.528501987f, 0.527199149f, 0.525895000f, 0.524589658f, 0.523283124f, 0.521975279f, 0.520666242f, 0.519356012f, 0.518044531f, 0.516731799f, 0.515417874f, 0.514102757f, 0.512786388f, 0.511468828f, 0.510150075f, 0.508830130f, 0.507508993f, 0.506186664f, 0.504863083f, 0.503538370f, 0.502212465f, 0.500885367f, 0.499557108f, 0.498227656f, 0.496897042f, 0.495565265f, 0.494232297f, 0.492898196f, 0.491562903f, 0.490226477f, 0.488888890f, 0.487550169f, 0.486210287f, 0.484869242f, 0.483527064f, 0.482183784f, 0.480839342f, 0.479493767f, 0.478147060f, 0.476799220f, 0.475450277f, 0.474100202f, 0.472749025f, 0.471396744f, 0.470043331f, 0.468688816f, 0.467333198f, 0.465976506f, 0.464618683f, 0.463259786f, 0.461899787f, 0.460538715f, 0.459176540f, 0.457813293f, 0.456448972f, 0.455083579f, 0.453717113f, 0.452349573f, 0.450980991f, 0.449611336f, 0.448240608f, 0.446868837f, 0.445496023f, 0.444122136f, 0.442747235f, 0.441371262f, 0.439994276f, 0.438616246f, 0.437237173f, 0.435857087f, 0.434475958f, 0.433093816f, 0.431710660f, 0.430326492f, 0.428941280f, 0.427555084f, 0.426167876f, 0.424779683f, 0.423390478f, 0.422000259f, 0.420609087f, 0.419216901f, 0.417823702f, 0.416429549f, 0.415034413f, 0.413638324f, 0.412241220f, 0.410843164f, 0.409444153f, 0.408044159f, 0.406643212f, 0.405241311f, 0.403838456f, 0.402434647f, 0.401029885f, 0.399624199f, 0.398217559f, 0.396809995f, 0.395401478f, 0.393992037f, 0.392581671f, 0.391170382f, 0.389758170f, 0.388345033f, 0.386931002f, 0.385516047f, 0.384100199f, 0.382683426f, 0.381265759f, 0.379847199f, 0.378427744f, 0.377007425f, 0.375586182f, 0.374164075f, 0.372741073f, 0.371317208f, 0.369892448f, 0.368466824f, 0.367040336f, 0.365612984f, 0.364184797f, 0.362755716f, 0.361325800f, 0.359895051f, 0.358463407f, 0.357030958f, 0.355597675f, 0.354163527f, 0.352728546f, 0.351292759f, 0.349856138f, 0.348418683f, 0.346980423f, 0.345541328f, 0.344101429f, 0.342660725f, 0.341219217f, 0.339776874f, 0.338333756f, 0.336889863f, 0.335445136f, 0.333999664f, 0.332553357f, 0.331106305f, 0.329658449f, 0.328209847f, 0.326760441f, 0.325310290f, 0.323859364f, 0.322407693f, 0.320955247f, 0.319502026f, 0.318048090f, 0.316593379f, 0.315137923f, 0.313681751f, 0.312224805f, 0.310767144f, 0.309308767f, 0.307849646f, 0.306389809f, 0.304929227f, 0.303467959f, 0.302005947f, 0.300543249f, 0.299079835f, 0.297615707f, 0.296150893f, 0.294685364f, 0.293219149f, 0.291752249f, 0.290284663f, 0.288816422f, 0.287347466f, 0.285877824f, 0.284407526f, 0.282936573f, 0.281464934f, 0.279992640f, 0.278519690f, 0.277046084f, 0.275571823f, 0.274096906f, 0.272621363f, 0.271145165f, 0.269668311f, 0.268190861f, 0.266712755f, 0.265234023f, 0.263754666f, 0.262274712f, 0.260794103f, 0.259312928f, 0.257831097f, 0.256348670f, 0.254865646f, 0.253382027f, 0.251897812f, 0.250413001f, 0.248927608f, 0.247441620f, 0.245955050f, 0.244467899f, 0.242980182f, 0.241491884f, 0.240003020f, 0.238513589f, 0.237023607f, 0.235533059f, 0.234041959f, 0.232550308f, 0.231058106f, 0.229565367f, 0.228072077f, 0.226578265f, 0.225083917f, 0.223589033f, 0.222093627f, 0.220597684f, 0.219101235f, 0.217604280f, 0.216106802f, 0.214608818f, 0.213110313f, 0.211611331f, 0.210111842f, 0.208611846f, 0.207111374f, 0.205610409f, 0.204108968f, 0.202607036f, 0.201104641f, 0.199601755f, 0.198098406f, 0.196594596f, 0.195090324f, 0.193585590f, 0.192080393f, 0.190574750f, 0.189068660f, 0.187562123f, 0.186055154f, 0.184547737f, 0.183039889f, 0.181531608f, 0.180022895f, 0.178513765f, 0.177004218f, 0.175494254f, 0.173983872f, 0.172473088f, 0.170961887f, 0.169450298f, 0.167938292f, 0.166425899f, 0.164913118f, 0.163399950f, 0.161886394f, 0.160372451f, 0.158858150f, 0.157343462f, 0.155828401f, 0.154312968f, 0.152797192f, 0.151281044f, 0.149764538f, 0.148247674f, 0.146730468f, 0.145212919f, 0.143695027f, 0.142176807f, 0.140658244f, 0.139139339f, 0.137620121f, 0.136100575f, 0.134580702f, 0.133060530f, 0.131540030f, 0.130019218f, 0.128498107f, 0.126976699f, 0.125454977f, 0.123932973f, 0.122410677f, 0.120888084f, 0.119365215f, 0.117842063f, 0.116318628f, 0.114794925f, 0.113270953f, 0.111746714f, 0.110222206f, 0.108697444f, 0.107172422f, 0.105647154f, 0.104121633f, 0.102595866f, 0.101069860f, 0.099543616f, 0.098017141f, 0.096490428f, 0.094963498f, 0.093436338f, 0.091908954f, 0.090381362f, 0.088853553f, 0.087325536f, 0.085797310f, 0.084268890f, 0.082740262f, 0.081211448f, 0.079682440f, 0.078153245f, 0.076623864f, 0.075094298f, 0.073564567f, 0.072034650f, 0.070504576f, 0.068974331f, 0.067443922f, 0.065913349f, 0.064382628f, 0.062851757f, 0.061320737f, 0.059789572f, 0.058258265f, 0.056726821f, 0.055195246f, 0.053663537f, 0.052131705f, 0.050599750f, 0.049067676f, 0.047535483f, 0.046003181f, 0.044470772f, 0.042938258f, 0.041405641f, 0.039872926f, 0.038340122f, 0.036807224f, 0.035274237f, 0.033741172f, 0.032208025f, 0.030674804f, 0.029141508f, 0.027608145f, 0.026074719f, 0.024541229f, 0.023007682f, 0.021474080f, 0.019940428f, 0.018406730f, 0.016872987f, 0.015339206f, 0.0138053885f, 0.012271538f, 0.010737659f, 0.009203754f, 0.007669829f, 0.0061358847f, 0.004601926f, 0.0030679568f, 0.0015339801f, 0.000000000f, -0.0015339801f, -0.0030679568f, -0.004601926f, -0.0061358847f, -0.007669829f, -0.009203754f, -0.010737659f, -0.012271538f, -0.0138053885f, -0.015339206f, -0.016872987f, -0.018406730f, -0.019940428f, -0.021474080f, -0.023007682f, -0.024541229f, -0.026074719f, -0.027608145f, -0.029141508f, -0.030674804f, -0.032208025f, -0.033741172f, -0.035274237f, -0.036807224f, -0.038340122f, -0.039872926f, -0.041405641f, -0.042938258f, -0.044470772f, -0.046003181f, -0.047535483f, -0.049067676f, -0.050599750f, -0.052131705f, -0.053663537f, -0.055195246f, -0.056726821f, -0.058258265f, -0.059789572f, -0.061320737f, -0.062851757f, -0.064382628f, -0.065913349f, -0.067443922f, -0.068974331f, -0.070504576f, -0.072034650f, -0.073564567f, -0.075094298f, -0.076623864f, -0.078153245f, -0.079682440f, -0.081211448f, -0.082740262f, -0.084268890f, -0.085797310f, -0.087325536f, -0.088853553f, -0.090381362f, -0.091908954f, -0.093436338f, -0.094963498f, -0.096490428f, -0.098017141f, -0.099543616f, -0.101069860f, -0.102595866f, -0.104121633f, -0.105647154f, -0.107172422f, -0.108697444f, -0.110222206f, -0.111746714f, -0.113270953f, -0.114794925f, -0.116318628f, -0.117842063f, -0.119365215f, -0.120888084f, -0.122410677f, -0.123932973f, -0.125454977f, -0.126976699f, -0.128498107f, -0.130019218f, -0.131540030f, -0.133060530f, -0.134580702f, -0.136100575f, -0.137620121f, -0.139139339f, -0.140658244f, -0.142176807f, -0.143695027f, -0.145212919f, -0.146730468f, -0.148247674f, -0.149764538f, -0.151281044f, -0.152797192f, -0.154312968f, -0.155828401f, -0.157343462f, -0.158858150f, -0.160372451f, -0.161886394f, -0.163399950f, -0.164913118f, -0.166425899f, -0.167938292f, -0.169450298f, -0.170961887f, -0.172473088f, -0.173983872f, -0.175494254f, -0.177004218f, -0.178513765f, -0.180022895f, -0.181531608f, -0.183039889f, -0.184547737f, -0.186055154f, -0.187562123f, -0.189068660f, -0.190574750f, -0.192080393f, -0.193585590f, -0.195090324f, -0.196594596f, -0.198098406f, -0.199601755f, -0.201104641f, -0.202607036f, -0.204108968f, -0.205610409f, -0.207111374f, -0.208611846f, -0.210111842f, -0.211611331f, -0.213110313f, -0.214608818f, -0.216106802f, -0.217604280f, -0.219101235f, -0.220597684f, -0.222093627f, -0.223589033f, -0.225083917f, -0.226578265f, -0.228072077f, -0.229565367f, -0.231058106f, -0.232550308f, -0.234041959f, -0.235533059f, -0.237023607f, -0.238513589f, -0.240003020f, -0.241491884f, -0.242980182f, -0.244467899f, -0.245955050f, -0.247441620f, -0.248927608f, -0.250413001f, -0.251897812f, -0.253382027f, -0.254865646f, -0.256348670f, -0.257831097f, -0.259312928f, -0.260794103f, -0.262274712f, -0.263754666f, -0.265234023f, -0.266712755f, -0.268190861f, -0.269668311f, -0.271145165f, -0.272621363f, -0.274096906f, -0.275571823f, -0.277046084f, -0.278519690f, -0.279992640f, -0.281464934f, -0.282936573f, -0.284407526f, -0.285877824f, -0.287347466f, -0.288816422f, -0.290284663f, -0.291752249f, -0.293219149f, -0.294685364f, -0.296150893f, -0.297615707f, -0.299079835f, -0.300543249f, -0.302005947f, -0.303467959f, -0.304929227f, -0.306389809f, -0.307849646f, -0.309308767f, -0.310767144f, -0.312224805f, -0.313681751f, -0.315137923f, -0.316593379f, -0.318048090f, -0.319502026f, -0.320955247f, -0.322407693f, -0.323859364f, -0.325310290f, -0.326760441f, -0.328209847f, -0.329658449f, -0.331106305f, -0.332553357f, -0.333999664f, -0.335445136f, -0.336889863f, -0.338333756f, -0.339776874f, -0.341219217f, -0.342660725f, -0.344101429f, -0.345541328f, -0.346980423f, -0.348418683f, -0.349856138f, -0.351292759f, -0.352728546f, -0.354163527f, -0.355597675f, -0.357030958f, -0.358463407f, -0.359895051f, -0.361325800f, -0.362755716f, -0.364184797f, -0.365612984f, -0.367040336f, -0.368466824f, -0.369892448f, -0.371317208f, -0.372741073f, -0.374164075f, -0.375586182f, -0.377007425f, -0.378427744f, -0.379847199f, -0.381265759f, -0.382683426f, -0.384100199f, -0.385516047f, -0.386931002f, -0.388345033f, -0.389758170f, -0.391170382f, -0.392581671f, -0.393992037f, -0.395401478f, -0.396809995f, -0.398217559f, -0.399624199f, -0.401029885f, -0.402434647f, -0.403838456f, -0.405241311f, -0.406643212f, -0.408044159f, -0.409444153f, -0.410843164f, -0.412241220f, -0.413638324f, -0.415034413f, -0.416429549f, -0.417823702f, -0.419216901f, -0.420609087f, -0.422000259f, -0.423390478f, -0.424779683f, -0.426167876f, -0.427555084f, -0.428941280f, -0.430326492f, -0.431710660f, -0.433093816f, -0.434475958f, -0.435857087f, -0.437237173f, -0.438616246f, -0.439994276f, -0.441371262f, -0.442747235f, -0.444122136f, -0.445496023f, -0.446868837f, -0.448240608f, -0.449611336f, -0.450980991f, -0.452349573f, -0.453717113f, -0.455083579f, -0.456448972f, -0.457813293f, -0.459176540f, -0.460538715f, -0.461899787f, -0.463259786f, -0.464618683f, -0.465976506f, -0.467333198f, -0.468688816f, -0.470043331f, -0.471396744f, -0.472749025f, -0.474100202f, -0.475450277f, -0.476799220f, -0.478147060f, -0.479493767f, -0.480839342f, -0.482183784f, -0.483527064f, -0.484869242f, -0.486210287f, -0.487550169f, -0.488888890f, -0.490226477f, -0.491562903f, -0.492898196f, -0.494232297f, -0.495565265f, -0.496897042f, -0.498227656f, -0.499557108f, -0.500885367f, -0.502212465f, -0.503538370f, -0.504863083f, -0.506186664f, -0.507508993f, -0.508830130f, -0.510150075f, -0.511468828f, -0.512786388f, -0.514102757f, -0.515417874f, -0.516731799f, -0.518044531f, -0.519356012f, -0.520666242f, -0.521975279f, -0.523283124f, -0.524589658f, -0.525895000f, -0.527199149f, -0.528501987f, -0.529803634f, -0.531104028f, -0.532403111f, -0.533701003f, -0.534997642f, -0.536292970f, -0.537587047f, -0.538879931f, -0.540171444f, -0.541461766f, -0.542750776f, -0.544038534f, -0.545324981f, -0.546610177f, -0.547894061f, -0.549176633f, -0.550457954f, -0.551737964f, -0.553016722f, -0.554294109f, -0.555570245f, -0.556845009f, -0.558118522f, -0.559390724f, -0.560661554f, -0.561931133f, -0.563199341f, -0.564466238f, -0.565731823f, -0.566996038f, -0.568258941f, -0.569520533f, -0.570780754f, -0.572039604f, -0.573297143f, -0.574553370f, -0.575808167f, -0.577061653f, -0.578313768f, -0.579564571f, -0.580813944f, -0.582062006f, -0.583308637f, -0.584553957f, -0.585797846f, -0.587040365f, -0.588281572f, -0.589521289f, -0.590759695f, -0.591996670f, -0.593232274f, -0.594466507f, -0.595699310f, -0.596930683f, -0.598160684f, -0.599389315f, -0.600616455f, -0.601842225f, -0.603066623f, -0.604289532f, -0.605511069f, -0.606731117f, -0.607949793f, -0.609167039f, -0.610382795f, -0.611597180f, -0.612810075f, -0.614021540f, -0.615231574f, -0.616440177f, -0.617647290f, -0.618852973f, -0.620057225f, -0.621259987f, -0.622461259f, -0.623661101f, -0.624859512f, -0.626056373f, -0.627251804f, -0.628445745f, -0.629638255f, -0.630829215f, -0.632018745f, -0.633206785f, -0.634393275f, -0.635578334f, -0.636761844f, -0.637943923f, -0.639124453f, -0.640303493f, -0.641481042f, -0.642657042f, -0.643831551f, -0.645004511f, -0.646176040f, -0.647345960f, -0.648514390f, -0.649681330f, -0.650846660f, -0.652010560f, -0.653172851f, -0.654333591f, -0.655492842f, -0.656650543f, -0.657806695f, -0.658961296f, -0.660114348f, -0.661265850f, -0.662415802f, -0.663564146f, -0.664710999f, -0.665856242f, -0.666999936f, -0.668142021f, -0.669282615f, -0.670421541f, -0.671558976f, -0.672694743f, -0.673829019f, -0.674961627f, -0.676092684f, -0.677222192f, -0.678350031f, -0.679476321f, -0.680601001f, -0.681724072f, -0.682845533f, -0.683965385f, -0.685083687f, -0.686200321f, -0.687315345f, -0.688428760f, -0.689540565f, -0.690650702f, -0.691759229f, -0.692866147f, -0.693971455f, -0.695075095f, -0.696177125f, -0.697277486f, -0.698376238f, -0.699473321f, -0.700568795f, -0.701662600f, -0.702754736f, -0.703845263f, -0.704934061f, -0.706021249f, -0.707106769f, -0.708190620f, -0.709272802f, -0.710353374f, -0.711432219f, -0.712509394f, -0.713584840f, -0.714658678f, -0.715730846f, -0.716801286f, -0.717870057f, -0.718937099f, -0.720002532f, -0.721066177f, -0.722128212f, -0.723188460f, -0.724247098f, -0.725303948f, -0.726359129f, -0.727412641f, -0.728464365f, -0.729514420f, -0.730562747f, -0.731609404f, -0.732654274f, -0.733697414f, -0.734738886f, -0.735778570f, -0.736816585f, -0.737852812f, -0.738887310f, -0.739920080f, -0.740951121f, -0.741980433f, -0.743007958f, -0.744033754f, -0.745057762f, -0.746080101f, -0.747100592f, -0.748119354f, -0.749136388f, -0.750151634f, -0.751165152f, -0.752176821f, -0.753186822f, -0.754194975f, -0.755201399f, -0.756205976f, -0.757208824f, -0.758209884f, -0.759209216f, -0.760206699f, -0.761202395f, -0.762196302f, -0.763188422f, -0.764178753f, -0.765167236f, -0.766153991f, -0.767138898f, -0.768122017f, -0.769103348f, -0.770082831f, -0.771060526f, -0.772036374f, -0.773010433f, -0.773982704f, -0.774953127f, -0.775921702f, -0.776888490f, -0.777853429f, -0.778816521f, -0.779777765f, -0.780737221f, -0.781694829f, -0.782650590f, -0.783604503f, -0.784556568f, -0.785506845f, -0.786455214f, -0.787401736f, -0.788346410f, -0.789289236f, -0.790230215f, -0.791169345f, -0.792106569f, -0.793041945f, -0.793975472f, -0.794907153f, -0.795836926f, -0.796764791f, -0.797690868f, -0.798614979f, -0.799537241f, -0.800457656f, -0.801376164f, -0.802292824f, -0.803207517f, -0.804120362f, -0.805031359f, -0.805940390f, -0.806847572f, -0.807752848f, -0.808656156f, -0.809557617f, -0.810457170f, -0.811354876f, -0.812250614f, -0.813144386f, -0.814036310f, -0.814926326f, -0.815814435f, -0.816700578f, -0.817584813f, -0.818467140f, -0.819347501f, -0.820225954f, -0.821102500f, -0.821977139f, -0.822849810f, -0.823720515f, -0.824589312f, -0.825456142f, -0.826321065f, -0.827184021f, -0.828045070f, -0.828904092f, -0.829761207f, -0.830616415f, -0.831469595f, -0.832320869f, -0.833170176f, -0.834017515f, -0.834862888f, -0.835706294f, -0.836547732f, -0.837387204f, -0.838224709f, -0.839060247f, -0.839893818f, -0.840725362f, -0.841554999f, -0.842382610f, -0.843208253f, -0.844031870f, -0.844853580f, -0.845673263f, -0.846490920f, -0.847306609f, -0.848120332f, -0.848932028f, -0.849741757f, -0.850549459f, -0.851355195f, -0.852158904f, -0.852960587f, -0.853760302f, -0.854557991f, -0.855353653f, -0.856147349f, -0.856938958f, -0.857728601f, -0.858516216f, -0.859301805f, -0.860085368f, -0.860866964f, -0.861646473f, -0.862423956f, -0.863199413f, -0.863972843f, -0.864744246f, -0.865513623f, -0.866280973f, -0.867046237f, -0.867809474f, -0.868570685f, -0.869329870f, -0.870086968f, -0.870842040f, -0.871595085f, -0.872346044f, -0.873094976f, -0.873841822f, -0.874586642f, -0.875329375f, -0.876070082f, -0.876808703f, -0.877545297f, -0.878279805f, -0.879012227f, -0.879742622f, -0.880470872f, -0.881197095f, -0.881921291f, -0.882643342f, -0.883363366f, -0.884081244f, -0.884797096f, -0.885510862f, -0.886222541f, -0.886932135f, -0.887639642f, -0.888345063f, -0.889048338f, -0.889749587f, -0.890448749f, -0.891145766f, -0.891840696f, -0.892533541f, -0.893224299f, -0.893912971f, -0.894599497f, -0.895283937f, -0.895966232f, -0.896646500f, -0.897324562f, -0.898000598f, -0.898674488f, -0.899346232f, -0.900015891f, -0.900683403f, -0.901348829f, -0.902012169f, -0.902673304f, -0.903332353f, -0.903989315f, -0.904644072f, -0.905296743f, -0.905947268f, -0.906595707f, -0.907242000f, -0.907886088f, -0.908528090f, -0.909168005f, -0.909805715f, -0.910441279f, -0.911074758f, -0.911706030f, -0.912335157f, -0.912962198f, -0.913587034f, -0.914209783f, -0.914830327f, -0.915448725f, -0.916064978f, -0.916679084f, -0.917290986f, -0.917900801f, -0.918508410f, -0.919113874f, -0.919717133f, -0.920318305f, -0.920917213f, -0.921514034f, -0.922108650f, -0.922701120f, -0.923291445f, -0.923879504f, -0.924465477f, -0.925049245f, -0.925630808f, -0.926210225f, -0.926787496f, -0.927362502f, -0.927935421f, -0.928506076f, -0.929074585f, -0.929640889f, -0.930205047f, -0.930766940f, -0.931326687f, -0.931884289f, -0.932439625f, -0.932992816f, -0.933543801f, -0.934092522f, -0.934639156f, -0.935183525f, -0.935725689f, -0.936265647f, -0.936803460f, -0.937339008f, -0.937872350f, -0.938403547f, -0.938932478f, -0.939459205f, -0.939983726f, -0.940506041f, -0.941026151f, -0.941544056f, -0.942059755f, -0.942573190f, -0.943084419f, -0.943593442f, -0.944100261f, -0.944604814f, -0.945107222f, -0.945607305f, -0.946105242f, -0.946600914f, -0.947094381f, -0.947585583f, -0.948074579f, -0.948561370f, -0.949045897f, -0.949528158f, -0.950008273f, -0.950486064f, -0.950961649f, -0.951435030f, -0.951906145f, -0.952374995f, -0.952841640f, -0.953306019f, -0.953768194f, -0.954228103f, -0.954685748f, -0.955141187f, -0.955594361f, -0.956045270f, -0.956493914f, -0.956940353f, -0.957384527f, -0.957826436f, -0.958266079f, -0.958703458f, -0.959138632f, -0.959571540f, -0.960002124f, -0.960430503f, -0.960856616f, -0.961280465f, -0.961702049f, -0.962121427f, -0.962538481f, -0.962953269f, -0.963365793f, -0.963776052f, -0.964184046f, -0.964589775f, -0.964993238f, -0.965394437f, -0.965793371f, -0.966189981f, -0.966584384f, -0.966976464f, -0.967366278f, -0.967753828f, -0.968139112f, -0.968522072f, -0.968902826f, -0.969281256f, -0.969657362f, -0.970031261f, -0.970402837f, -0.970772147f, -0.971139133f, -0.971503913f, -0.971866310f, -0.972226501f, -0.972584367f, -0.972939968f, -0.973293245f, -0.973644257f, -0.973992944f, -0.974339366f, -0.974683523f, -0.975025356f, -0.975364864f, -0.975702107f, -0.976037085f, -0.976369739f, -0.976700068f, -0.977028131f, -0.977353871f, -0.977677345f, -0.977998495f, -0.978317380f, -0.978633940f, -0.978948176f, -0.979260147f, -0.979569793f, -0.979877114f, -0.980182111f, -0.980484843f, -0.980785251f, -0.981083393f, -0.981379211f, -0.981672704f, -0.981963873f, -0.982252717f, -0.982539296f, -0.982823551f, -0.983105481f, -0.983385086f, -0.983662426f, -0.983937442f, -0.984210074f, -0.984480441f, -0.984748483f, -0.985014260f, -0.985277653f, -0.985538721f, -0.985797524f, -0.986053944f, -0.986308098f, -0.986559927f, -0.986809373f, -0.987056553f, -0.987301409f, -0.987543941f, -0.987784147f, -0.988022029f, -0.988257587f, -0.988490820f, -0.988721669f, -0.988950253f, -0.989176512f, -0.989400446f, -0.989621997f, -0.989841282f, -0.990058184f, -0.990272820f, -0.990485072f, -0.990695000f, -0.990902662f, -0.991107941f, -0.991310835f, -0.991511464f, -0.991709769f, -0.991905689f, -0.992099285f, -0.992290616f, -0.992479563f, -0.992666125f, -0.992850423f, -0.993032336f, -0.993211925f, -0.993389189f, -0.993564129f, -0.993736744f, -0.993906975f, -0.994074881f, -0.994240463f, -0.994403660f, -0.994564593f, -0.994723141f, -0.994879305f, -0.995033205f, -0.995184720f, -0.995333910f, -0.995480776f, -0.995625257f, -0.995767415f, -0.995907247f, -0.996044695f, -0.996179819f, -0.996312618f, -0.996443033f, -0.996571124f, -0.996696889f, -0.996820271f, -0.996941328f, -0.997060061f, -0.997176409f, -0.997290432f, -0.997402132f, -0.997511446f, -0.997618437f, -0.997723043f, -0.997825325f, -0.997925282f, -0.998022854f, -0.998118103f, -0.998211026f, -0.998301566f, -0.998389721f, -0.998475552f, -0.998559058f, -0.998640239f, -0.998719037f, -0.998795450f, -0.998869538f, -0.998941302f, -0.999010682f, -0.999077737f, -0.999142408f, -0.999204755f, -0.999264777f, -0.999322355f, -0.999377668f, -0.999430597f, -0.999481201f, -0.999529421f, -0.999575317f, -0.999618828f, -0.999660015f, -0.999698818f, -0.999735296f, -0.999769390f, -0.999801159f, -0.999830604f, -0.999857664f, -0.999882340f, -0.999904692f, -0.999924719f, -0.999942362f, -0.999957621f, -0.999970615f, -0.999981165f, -0.999989390f, -0.999995291f, -0.999998808f, -1.000000000f, -0.999998808f, -0.999995291f, -0.999989390f, -0.999981165f, -0.999970615f, -0.999957621f, -0.999942362f, -0.999924719f, -0.999904692f, -0.999882340f, -0.999857664f, -0.999830604f, -0.999801159f, -0.999769390f, -0.999735296f, -0.999698818f, -0.999660015f, -0.999618828f, -0.999575317f, -0.999529421f, -0.999481201f, -0.999430597f, -0.999377668f, -0.999322355f, -0.999264777f, -0.999204755f, -0.999142408f, -0.999077737f, -0.999010682f, -0.998941302f, -0.998869538f, -0.998795450f, -0.998719037f, -0.998640239f, -0.998559058f, -0.998475552f, -0.998389721f, -0.998301566f, -0.998211026f, -0.998118103f, -0.998022854f, -0.997925282f, -0.997825325f, -0.997723043f, -0.997618437f, -0.997511446f, -0.997402132f, -0.997290432f, -0.997176409f, -0.997060061f, -0.996941328f, -0.996820271f, -0.996696889f, -0.996571124f, -0.996443033f, -0.996312618f, -0.996179819f, -0.996044695f, -0.995907247f, -0.995767415f, -0.995625257f, -0.995480776f, -0.995333910f, -0.995184720f, -0.995033205f, -0.994879305f, -0.994723141f, -0.994564593f, -0.994403660f, -0.994240463f, -0.994074881f, -0.993906975f, -0.993736744f, -0.993564129f, -0.993389189f, -0.993211925f, -0.993032336f, -0.992850423f, -0.992666125f, -0.992479563f, -0.992290616f, -0.992099285f, -0.991905689f, -0.991709769f, -0.991511464f, -0.991310835f, -0.991107941f, -0.990902662f, -0.990695000f, -0.990485072f, -0.990272820f, -0.990058184f, -0.989841282f, -0.989621997f, -0.989400446f, -0.989176512f, -0.988950253f, -0.988721669f, -0.988490820f, -0.988257587f, -0.988022029f, -0.987784147f, -0.987543941f, -0.987301409f, -0.987056553f, -0.986809373f, -0.986559927f, -0.986308098f, -0.986053944f, -0.985797524f, -0.985538721f, -0.985277653f, -0.985014260f, -0.984748483f, -0.984480441f, -0.984210074f, -0.983937442f, -0.983662426f, -0.983385086f, -0.983105481f, -0.982823551f, -0.982539296f, -0.982252717f, -0.981963873f, -0.981672704f, -0.981379211f, -0.981083393f, -0.980785251f, -0.980484843f, -0.980182111f, -0.979877114f, -0.979569793f, -0.979260147f, -0.978948176f, -0.978633940f, -0.978317380f, -0.977998495f, -0.977677345f, -0.977353871f, -0.977028131f, -0.976700068f, -0.976369739f, -0.976037085f, -0.975702107f, -0.975364864f, -0.975025356f, -0.974683523f, -0.974339366f, -0.973992944f, -0.973644257f, -0.973293245f, -0.972939968f, -0.972584367f, -0.972226501f, -0.971866310f, -0.971503913f, -0.971139133f, -0.970772147f, -0.970402837f, -0.970031261f, -0.969657362f, -0.969281256f, -0.968902826f, -0.968522072f, -0.968139112f, -0.967753828f, -0.967366278f, -0.966976464f, -0.966584384f, -0.966189981f, -0.965793371f, -0.965394437f, -0.964993238f, -0.964589775f, -0.964184046f, -0.963776052f, -0.963365793f, -0.962953269f, -0.962538481f, -0.962121427f, -0.961702049f, -0.961280465f, -0.960856616f, -0.960430503f, -0.960002124f, -0.959571540f, -0.959138632f, -0.958703458f, -0.958266079f, -0.957826436f, -0.957384527f, -0.956940353f, -0.956493914f, -0.956045270f, -0.955594361f, -0.955141187f, -0.954685748f, -0.954228103f, -0.953768194f, -0.953306019f, -0.952841640f, -0.952374995f, -0.951906145f, -0.951435030f, -0.950961649f, -0.950486064f, -0.950008273f, -0.949528158f, -0.949045897f, -0.948561370f, -0.948074579f, -0.947585583f, -0.947094381f, -0.946600914f, -0.946105242f, -0.945607305f, -0.945107222f, -0.944604814f, -0.944100261f, -0.943593442f, -0.943084419f, -0.942573190f, -0.942059755f, -0.941544056f, -0.941026151f, -0.940506041f, -0.939983726f, -0.939459205f, -0.938932478f, -0.938403547f, -0.937872350f, -0.937339008f, -0.936803460f, -0.936265647f, -0.935725689f, -0.935183525f, -0.934639156f, -0.934092522f, -0.933543801f, -0.932992816f, -0.932439625f, -0.931884289f, -0.931326687f, -0.930766940f, -0.930205047f, -0.929640889f, -0.929074585f, -0.928506076f, -0.927935421f, -0.927362502f, -0.926787496f, -0.926210225f, -0.925630808f, -0.925049245f, -0.924465477f, -0.923879504f, -0.923291445f, -0.922701120f, -0.922108650f, -0.921514034f, -0.920917213f, -0.920318305f, -0.919717133f, -0.919113874f, -0.918508410f, -0.917900801f, -0.917290986f, -0.916679084f, -0.916064978f, -0.915448725f, -0.914830327f, -0.914209783f, -0.913587034f, -0.912962198f, -0.912335157f, -0.911706030f, -0.911074758f, -0.910441279f, -0.909805715f, -0.909168005f, -0.908528090f, -0.907886088f, -0.907242000f, -0.906595707f, -0.905947268f, -0.905296743f, -0.904644072f, -0.903989315f, -0.903332353f, -0.902673304f, -0.902012169f, -0.901348829f, -0.900683403f, -0.900015891f, -0.899346232f, -0.898674488f, -0.898000598f, -0.897324562f, -0.896646500f, -0.895966232f, -0.895283937f, -0.894599497f, -0.893912971f, -0.893224299f, -0.892533541f, -0.891840696f, -0.891145766f, -0.890448749f, -0.889749587f, -0.889048338f, -0.888345063f, -0.887639642f, -0.886932135f, -0.886222541f, -0.885510862f, -0.884797096f, -0.884081244f, -0.883363366f, -0.882643342f, -0.881921291f, -0.881197095f, -0.880470872f, -0.879742622f, -0.879012227f, -0.878279805f, -0.877545297f, -0.876808703f, -0.876070082f, -0.875329375f, -0.874586642f, -0.873841822f, -0.873094976f, -0.872346044f, -0.871595085f, -0.870842040f, -0.870086968f, -0.869329870f, -0.868570685f, -0.867809474f, -0.867046237f, -0.866280973f, -0.865513623f, -0.864744246f, -0.863972843f, -0.863199413f, -0.862423956f, -0.861646473f, -0.860866964f, -0.860085368f, -0.859301805f, -0.858516216f, -0.857728601f, -0.856938958f, -0.856147349f, -0.855353653f, -0.854557991f, -0.853760302f, -0.852960587f, -0.852158904f, -0.851355195f, -0.850549459f, -0.849741757f, -0.848932028f, -0.848120332f, -0.847306609f, -0.846490920f, -0.845673263f, -0.844853580f, -0.844031870f, -0.843208253f, -0.842382610f, -0.841554999f, -0.840725362f, -0.839893818f, -0.839060247f, -0.838224709f, -0.837387204f, -0.836547732f, -0.835706294f, -0.834862888f, -0.834017515f, -0.833170176f, -0.832320869f, -0.831469595f, -0.830616415f, -0.829761207f, -0.828904092f, -0.828045070f, -0.827184021f, -0.826321065f, -0.825456142f, -0.824589312f, -0.823720515f, -0.822849810f, -0.821977139f, -0.821102500f, -0.820225954f, -0.819347501f, -0.818467140f, -0.817584813f, -0.816700578f, -0.815814435f, -0.814926326f, -0.814036310f, -0.813144386f, -0.812250614f, -0.811354876f, -0.810457170f, -0.809557617f, -0.808656156f, -0.807752848f, -0.806847572f, -0.805940390f, -0.805031359f, -0.804120362f, -0.803207517f, -0.802292824f, -0.801376164f, -0.800457656f, -0.799537241f, -0.798614979f, -0.797690868f, -0.796764791f, -0.795836926f, -0.794907153f, -0.793975472f, -0.793041945f, -0.792106569f, -0.791169345f, -0.790230215f, -0.789289236f, -0.788346410f, -0.787401736f, -0.786455214f, -0.785506845f, -0.784556568f, -0.783604503f, -0.782650590f, -0.781694829f, -0.780737221f, -0.779777765f, -0.778816521f, -0.777853429f, -0.776888490f, -0.775921702f, -0.774953127f, -0.773982704f, -0.773010433f, -0.772036374f, -0.771060526f, -0.770082831f, -0.769103348f, -0.768122017f, -0.767138898f, -0.766153991f, -0.765167236f, -0.764178753f, -0.763188422f, -0.762196302f, -0.761202395f, -0.760206699f, -0.759209216f, -0.758209884f, -0.757208824f, -0.756205976f, -0.755201399f, -0.754194975f, -0.753186822f, -0.752176821f, -0.751165152f, -0.750151634f, -0.749136388f, -0.748119354f, -0.747100592f, -0.746080101f, -0.745057762f, -0.744033754f, -0.743007958f, -0.741980433f, -0.740951121f, -0.739920080f, -0.738887310f, -0.737852812f, -0.736816585f, -0.735778570f, -0.734738886f, -0.733697414f, -0.732654274f, -0.731609404f, -0.730562747f, -0.729514420f, -0.728464365f, -0.727412641f, -0.726359129f, -0.725303948f, -0.724247098f, -0.723188460f, -0.722128212f, -0.721066177f, -0.720002532f, -0.718937099f, -0.717870057f, -0.716801286f, -0.715730846f, -0.714658678f, -0.713584840f, -0.712509394f, -0.711432219f, -0.710353374f, -0.709272802f, -0.708190620f, -0.707106769f, -0.706021249f, -0.704934061f, -0.703845263f, -0.702754736f, -0.701662600f, -0.700568795f, -0.699473321f, -0.698376238f, -0.697277486f, -0.696177125f, -0.695075095f, -0.693971455f, -0.692866147f, -0.691759229f, -0.690650702f, -0.689540565f, -0.688428760f, -0.687315345f, -0.686200321f, -0.685083687f, -0.683965385f, -0.682845533f, -0.681724072f, -0.680601001f, -0.679476321f, -0.678350031f, -0.677222192f, -0.676092684f, -0.674961627f, -0.673829019f, -0.672694743f, -0.671558976f, -0.670421541f, -0.669282615f, -0.668142021f, -0.666999936f, -0.665856242f, -0.664710999f, -0.663564146f, -0.662415802f, -0.661265850f, -0.660114348f, -0.658961296f, -0.657806695f, -0.656650543f, -0.655492842f, -0.654333591f, -0.653172851f, -0.652010560f, -0.650846660f, -0.649681330f, -0.648514390f, -0.647345960f, -0.646176040f, -0.645004511f, -0.643831551f, -0.642657042f, -0.641481042f, -0.640303493f, -0.639124453f, -0.637943923f, -0.636761844f, -0.635578334f, -0.634393275f, -0.633206785f, -0.632018745f, -0.630829215f, -0.629638255f, -0.628445745f, -0.627251804f, -0.626056373f, -0.624859512f, -0.623661101f, -0.622461259f, -0.621259987f, -0.620057225f, -0.618852973f, -0.617647290f, -0.616440177f, -0.615231574f, -0.614021540f, -0.612810075f, -0.611597180f, -0.610382795f, -0.609167039f, -0.607949793f, -0.606731117f, -0.605511069f, -0.604289532f, -0.603066623f, -0.601842225f, -0.600616455f, -0.599389315f, -0.598160684f, -0.596930683f, -0.595699310f, -0.594466507f, -0.593232274f, -0.591996670f, -0.590759695f, -0.589521289f, -0.588281572f, -0.587040365f, -0.585797846f, -0.584553957f, -0.583308637f, -0.582062006f, -0.580813944f, -0.579564571f, -0.578313768f, -0.577061653f, -0.575808167f, -0.574553370f, -0.573297143f, -0.572039604f, -0.570780754f, -0.569520533f, -0.568258941f, -0.566996038f, -0.565731823f, -0.564466238f, -0.563199341f, -0.561931133f, -0.560661554f, -0.559390724f, -0.558118522f, -0.556845009f, -0.555570245f, -0.554294109f, -0.553016722f, -0.551737964f, -0.550457954f, -0.549176633f, -0.547894061f, -0.546610177f, -0.545324981f, -0.544038534f, -0.542750776f, -0.541461766f, -0.540171444f, -0.538879931f, -0.537587047f, -0.536292970f, -0.534997642f, -0.533701003f, -0.532403111f, -0.531104028f, -0.529803634f, -0.528501987f, -0.527199149f, -0.525895000f, -0.524589658f, -0.523283124f, -0.521975279f, -0.520666242f, -0.519356012f, -0.518044531f, -0.516731799f, -0.515417874f, -0.514102757f, -0.512786388f, -0.511468828f, -0.510150075f, -0.508830130f, -0.507508993f, -0.506186664f, -0.504863083f, -0.503538370f, -0.502212465f, -0.500885367f, -0.499557108f, -0.498227656f, -0.496897042f, -0.495565265f, -0.494232297f, -0.492898196f, -0.491562903f, -0.490226477f, -0.488888890f, -0.487550169f, -0.486210287f, -0.484869242f, -0.483527064f, -0.482183784f, -0.480839342f, -0.479493767f, -0.478147060f, -0.476799220f, -0.475450277f, -0.474100202f, -0.472749025f, -0.471396744f, -0.470043331f, -0.468688816f, -0.467333198f, -0.465976506f, -0.464618683f, -0.463259786f, -0.461899787f, -0.460538715f, -0.459176540f, -0.457813293f, -0.456448972f, -0.455083579f, -0.453717113f, -0.452349573f, -0.450980991f, -0.449611336f, -0.448240608f, -0.446868837f, -0.445496023f, -0.444122136f, -0.442747235f, -0.441371262f, -0.439994276f, -0.438616246f, -0.437237173f, -0.435857087f, -0.434475958f, -0.433093816f, -0.431710660f, -0.430326492f, -0.428941280f, -0.427555084f, -0.426167876f, -0.424779683f, -0.423390478f, -0.422000259f, -0.420609087f, -0.419216901f, -0.417823702f, -0.416429549f, -0.415034413f, -0.413638324f, -0.412241220f, -0.410843164f, -0.409444153f, -0.408044159f, -0.406643212f, -0.405241311f, -0.403838456f, -0.402434647f, -0.401029885f, -0.399624199f, -0.398217559f, -0.396809995f, -0.395401478f, -0.393992037f, -0.392581671f, -0.391170382f, -0.389758170f, -0.388345033f, -0.386931002f, -0.385516047f, -0.384100199f, -0.382683426f, -0.381265759f, -0.379847199f, -0.378427744f, -0.377007425f, -0.375586182f, -0.374164075f, -0.372741073f, -0.371317208f, -0.369892448f, -0.368466824f, -0.367040336f, -0.365612984f, -0.364184797f, -0.362755716f, -0.361325800f, -0.359895051f, -0.358463407f, -0.357030958f, -0.355597675f, -0.354163527f, -0.352728546f, -0.351292759f, -0.349856138f, -0.348418683f, -0.346980423f, -0.345541328f, -0.344101429f, -0.342660725f, -0.341219217f, -0.339776874f, -0.338333756f, -0.336889863f, -0.335445136f, -0.333999664f, -0.332553357f, -0.331106305f, -0.329658449f, -0.328209847f, -0.326760441f, -0.325310290f, -0.323859364f, -0.322407693f, -0.320955247f, -0.319502026f, -0.318048090f, -0.316593379f, -0.315137923f, -0.313681751f, -0.312224805f, -0.310767144f, -0.309308767f, -0.307849646f, -0.306389809f, -0.304929227f, -0.303467959f, -0.302005947f, -0.300543249f, -0.299079835f, -0.297615707f, -0.296150893f, -0.294685364f, -0.293219149f, -0.291752249f, -0.290284663f, -0.288816422f, -0.287347466f, -0.285877824f, -0.284407526f, -0.282936573f, -0.281464934f, -0.279992640f, -0.278519690f, -0.277046084f, -0.275571823f, -0.274096906f, -0.272621363f, -0.271145165f, -0.269668311f, -0.268190861f, -0.266712755f, -0.265234023f, -0.263754666f, -0.262274712f, -0.260794103f, -0.259312928f, -0.257831097f, -0.256348670f, -0.254865646f, -0.253382027f, -0.251897812f, -0.250413001f, -0.248927608f, -0.247441620f, -0.245955050f, -0.244467899f, -0.242980182f, -0.241491884f, -0.240003020f, -0.238513589f, -0.237023607f, -0.235533059f, -0.234041959f, -0.232550308f, -0.231058106f, -0.229565367f, -0.228072077f, -0.226578265f, -0.225083917f, -0.223589033f, -0.222093627f, -0.220597684f, -0.219101235f, -0.217604280f, -0.216106802f, -0.214608818f, -0.213110313f, -0.211611331f, -0.210111842f, -0.208611846f, -0.207111374f, -0.205610409f, -0.204108968f, -0.202607036f, -0.201104641f, -0.199601755f, -0.198098406f, -0.196594596f, -0.195090324f, -0.193585590f, -0.192080393f, -0.190574750f, -0.189068660f, -0.187562123f, -0.186055154f, -0.184547737f, -0.183039889f, -0.181531608f, -0.180022895f, -0.178513765f, -0.177004218f, -0.175494254f, -0.173983872f, -0.172473088f, -0.170961887f, -0.169450298f, -0.167938292f, -0.166425899f, -0.164913118f, -0.163399950f, -0.161886394f, -0.160372451f, -0.158858150f, -0.157343462f, -0.155828401f, -0.154312968f, -0.152797192f, -0.151281044f, -0.149764538f, -0.148247674f, -0.146730468f, -0.145212919f, -0.143695027f, -0.142176807f, -0.140658244f, -0.139139339f, -0.137620121f, -0.136100575f, -0.134580702f, -0.133060530f, -0.131540030f, -0.130019218f, -0.128498107f, -0.126976699f, -0.125454977f, -0.123932973f, -0.122410677f, -0.120888084f, -0.119365215f, -0.117842063f, -0.116318628f, -0.114794925f, -0.113270953f, -0.111746714f, -0.110222206f, -0.108697444f, -0.107172422f, -0.105647154f, -0.104121633f, -0.102595866f, -0.101069860f, -0.099543616f, -0.098017141f, -0.096490428f, -0.094963498f, -0.093436338f, -0.091908954f, -0.090381362f, -0.088853553f, -0.087325536f, -0.085797310f, -0.084268890f, -0.082740262f, -0.081211448f, -0.079682440f, -0.078153245f, -0.076623864f, -0.075094298f, -0.073564567f, -0.072034650f, -0.070504576f, -0.068974331f, -0.067443922f, -0.065913349f, -0.064382628f, -0.062851757f, -0.061320737f, -0.059789572f, -0.058258265f, -0.056726821f, -0.055195246f, -0.053663537f, -0.052131705f, -0.050599750f, -0.049067676f, -0.047535483f, -0.046003181f, -0.044470772f, -0.042938258f, -0.041405641f, -0.039872926f, -0.038340122f, -0.036807224f, -0.035274237f, -0.033741172f, -0.032208025f, -0.030674804f, -0.029141508f, -0.027608145f, -0.026074719f, -0.024541229f, -0.023007682f, -0.021474080f, -0.019940428f, -0.018406730f, -0.016872987f, -0.015339206f, -0.0138053885f, -0.012271538f, -0.010737659f, -0.009203754f, -0.007669829f, -0.0061358847f, -0.004601926f, -0.0030679568f, -0.0015339801f };
__device__ float gCosineTableG[4096] = { 1.000000000f, 0.999998808f, 0.999995291f, 0.999989390f, 0.999981165f, 0.999970615f, 0.999957621f, 0.999942362f, 0.999924719f, 0.999904692f, 0.999882340f, 0.999857664f, 0.999830604f, 0.999801159f, 0.999769390f, 0.999735296f, 0.999698818f, 0.999660015f, 0.999618828f, 0.999575317f, 0.999529421f, 0.999481201f, 0.999430597f, 0.999377668f, 0.999322355f, 0.999264777f, 0.999204755f, 0.999142408f, 0.999077737f, 0.999010682f, 0.998941302f, 0.998869538f, 0.998795450f, 0.998719037f, 0.998640239f, 0.998559058f, 0.998475552f, 0.998389721f, 0.998301566f, 0.998211026f, 0.998118103f, 0.998022854f, 0.997925282f, 0.997825325f, 0.997723043f, 0.997618437f, 0.997511446f, 0.997402132f, 0.997290432f, 0.997176409f, 0.997060061f, 0.996941328f, 0.996820271f, 0.996696889f, 0.996571124f, 0.996443033f, 0.996312618f, 0.996179819f, 0.996044695f, 0.995907247f, 0.995767415f, 0.995625257f, 0.995480776f, 0.995333910f, 0.995184720f, 0.995033205f, 0.994879305f, 0.994723141f, 0.994564593f, 0.994403660f, 0.994240463f, 0.994074881f, 0.993906975f, 0.993736744f, 0.993564129f, 0.993389189f, 0.993211925f, 0.993032336f, 0.992850423f, 0.992666125f, 0.992479563f, 0.992290616f, 0.992099285f, 0.991905689f, 0.991709769f, 0.991511464f, 0.991310835f, 0.991107941f, 0.990902662f, 0.990695000f, 0.990485072f, 0.990272820f, 0.990058184f, 0.989841282f, 0.989621997f, 0.989400446f, 0.989176512f, 0.988950253f, 0.988721669f, 0.988490820f, 0.988257587f, 0.988022029f, 0.987784147f, 0.987543941f, 0.987301409f, 0.987056553f, 0.986809373f, 0.986559927f, 0.986308098f, 0.986053944f, 0.985797524f, 0.985538721f, 0.985277653f, 0.985014260f, 0.984748483f, 0.984480441f, 0.984210074f, 0.983937442f, 0.983662426f, 0.983385086f, 0.983105481f, 0.982823551f, 0.982539296f, 0.982252717f, 0.981963873f, 0.981672704f, 0.981379211f, 0.981083393f, 0.980785251f, 0.980484843f, 0.980182111f, 0.979877114f, 0.979569793f, 0.979260147f, 0.978948176f, 0.978633940f, 0.978317380f, 0.977998495f, 0.977677345f, 0.977353871f, 0.977028131f, 0.976700068f, 0.976369739f, 0.976037085f, 0.975702107f, 0.975364864f, 0.975025356f, 0.974683523f, 0.974339366f, 0.973992944f, 0.973644257f, 0.973293245f, 0.972939968f, 0.972584367f, 0.972226501f, 0.971866310f, 0.971503913f, 0.971139133f, 0.970772147f, 0.970402837f, 0.970031261f, 0.969657362f, 0.969281256f, 0.968902826f, 0.968522072f, 0.968139112f, 0.967753828f, 0.967366278f, 0.966976464f, 0.966584384f, 0.966189981f, 0.965793371f, 0.965394437f, 0.964993238f, 0.964589775f, 0.964184046f, 0.963776052f, 0.963365793f, 0.962953269f, 0.962538481f, 0.962121427f, 0.961702049f, 0.961280465f, 0.960856616f, 0.960430503f, 0.960002124f, 0.959571540f, 0.959138632f, 0.958703458f, 0.958266079f, 0.957826436f, 0.957384527f, 0.956940353f, 0.956493914f, 0.956045270f, 0.955594361f, 0.955141187f, 0.954685748f, 0.954228103f, 0.953768194f, 0.953306019f, 0.952841640f, 0.952374995f, 0.951906145f, 0.951435030f, 0.950961649f, 0.950486064f, 0.950008273f, 0.949528158f, 0.949045897f, 0.948561370f, 0.948074579f, 0.947585583f, 0.947094381f, 0.946600914f, 0.946105242f, 0.945607305f, 0.945107222f, 0.944604814f, 0.944100261f, 0.943593442f, 0.943084419f, 0.942573190f, 0.942059755f, 0.941544056f, 0.941026151f, 0.940506041f, 0.939983726f, 0.939459205f, 0.938932478f, 0.938403547f, 0.937872350f, 0.937339008f, 0.936803460f, 0.936265647f, 0.935725689f, 0.935183525f, 0.934639156f, 0.934092522f, 0.933543801f, 0.932992816f, 0.932439625f, 0.931884289f, 0.931326687f, 0.930766940f, 0.930205047f, 0.929640889f, 0.929074585f, 0.928506076f, 0.927935421f, 0.927362502f, 0.926787496f, 0.926210225f, 0.925630808f, 0.925049245f, 0.924465477f, 0.923879504f, 0.923291445f, 0.922701120f, 0.922108650f, 0.921514034f, 0.920917213f, 0.920318305f, 0.919717133f, 0.919113874f, 0.918508410f, 0.917900801f, 0.917290986f, 0.916679084f, 0.916064978f, 0.915448725f, 0.914830327f, 0.914209783f, 0.913587034f, 0.912962198f, 0.912335157f, 0.911706030f, 0.911074758f, 0.910441279f, 0.909805715f, 0.909168005f, 0.908528090f, 0.907886088f, 0.907242000f, 0.906595707f, 0.905947268f, 0.905296743f, 0.904644072f, 0.903989315f, 0.903332353f, 0.902673304f, 0.902012169f, 0.901348829f, 0.900683403f, 0.900015891f, 0.899346232f, 0.898674488f, 0.898000598f, 0.897324562f, 0.896646500f, 0.895966232f, 0.895283937f, 0.894599497f, 0.893912971f, 0.893224299f, 0.892533541f, 0.891840696f, 0.891145766f, 0.890448749f, 0.889749587f, 0.889048338f, 0.888345063f, 0.887639642f, 0.886932135f, 0.886222541f, 0.885510862f, 0.884797096f, 0.884081244f, 0.883363366f, 0.882643342f, 0.881921291f, 0.881197095f, 0.880470872f, 0.879742622f, 0.879012227f, 0.878279805f, 0.877545297f, 0.876808703f, 0.876070082f, 0.875329375f, 0.874586642f, 0.873841822f, 0.873094976f, 0.872346044f, 0.871595085f, 0.870842040f, 0.870086968f, 0.869329870f, 0.868570685f, 0.867809474f, 0.867046237f, 0.866280973f, 0.865513623f, 0.864744246f, 0.863972843f, 0.863199413f, 0.862423956f, 0.861646473f, 0.860866964f, 0.860085368f, 0.859301805f, 0.858516216f, 0.857728601f, 0.856938958f, 0.856147349f, 0.855353653f, 0.854557991f, 0.853760302f, 0.852960587f, 0.852158904f, 0.851355195f, 0.850549459f, 0.849741757f, 0.848932028f, 0.848120332f, 0.847306609f, 0.846490920f, 0.845673263f, 0.844853580f, 0.844031870f, 0.843208253f, 0.842382610f, 0.841554999f, 0.840725362f, 0.839893818f, 0.839060247f, 0.838224709f, 0.837387204f, 0.836547732f, 0.835706294f, 0.834862888f, 0.834017515f, 0.833170176f, 0.832320869f, 0.831469595f, 0.830616415f, 0.829761207f, 0.828904092f, 0.828045070f, 0.827184021f, 0.826321065f, 0.825456142f, 0.824589312f, 0.823720515f, 0.822849810f, 0.821977139f, 0.821102500f, 0.820225954f, 0.819347501f, 0.818467140f, 0.817584813f, 0.816700578f, 0.815814435f, 0.814926326f, 0.814036310f, 0.813144386f, 0.812250614f, 0.811354876f, 0.810457170f, 0.809557617f, 0.808656156f, 0.807752848f, 0.806847572f, 0.805940390f, 0.805031359f, 0.804120362f, 0.803207517f, 0.802292824f, 0.801376164f, 0.800457656f, 0.799537241f, 0.798614979f, 0.797690868f, 0.796764791f, 0.795836926f, 0.794907153f, 0.793975472f, 0.793041945f, 0.792106569f, 0.791169345f, 0.790230215f, 0.789289236f, 0.788346410f, 0.787401736f, 0.786455214f, 0.785506845f, 0.784556568f, 0.783604503f, 0.782650590f, 0.781694829f, 0.780737221f, 0.779777765f, 0.778816521f, 0.777853429f, 0.776888490f, 0.775921702f, 0.774953127f, 0.773982704f, 0.773010433f, 0.772036374f, 0.771060526f, 0.770082831f, 0.769103348f, 0.768122017f, 0.767138898f, 0.766153991f, 0.765167236f, 0.764178753f, 0.763188422f, 0.762196302f, 0.761202395f, 0.760206699f, 0.759209216f, 0.758209884f, 0.757208824f, 0.756205976f, 0.755201399f, 0.754194975f, 0.753186822f, 0.752176821f, 0.751165152f, 0.750151634f, 0.749136388f, 0.748119354f, 0.747100592f, 0.746080101f, 0.745057762f, 0.744033754f, 0.743007958f, 0.741980433f, 0.740951121f, 0.739920080f, 0.738887310f, 0.737852812f, 0.736816585f, 0.735778570f, 0.734738886f, 0.733697414f, 0.732654274f, 0.731609404f, 0.730562747f, 0.729514420f, 0.728464365f, 0.727412641f, 0.726359129f, 0.725303948f, 0.724247098f, 0.723188460f, 0.722128212f, 0.721066177f, 0.720002532f, 0.718937099f, 0.717870057f, 0.716801286f, 0.715730846f, 0.714658678f, 0.713584840f, 0.712509394f, 0.711432219f, 0.710353374f, 0.709272802f, 0.708190620f, 0.707106769f, 0.706021249f, 0.704934061f, 0.703845263f, 0.702754736f, 0.701662600f, 0.700568795f, 0.699473321f, 0.698376238f, 0.697277486f, 0.696177125f, 0.695075095f, 0.693971455f, 0.692866147f, 0.691759229f, 0.690650702f, 0.689540565f, 0.688428760f, 0.687315345f, 0.686200321f, 0.685083687f, 0.683965385f, 0.682845533f, 0.681724072f, 0.680601001f, 0.679476321f, 0.678350031f, 0.677222192f, 0.676092684f, 0.674961627f, 0.673829019f, 0.672694743f, 0.671558976f, 0.670421541f, 0.669282615f, 0.668142021f, 0.666999936f, 0.665856242f, 0.664710999f, 0.663564146f, 0.662415802f, 0.661265850f, 0.660114348f, 0.658961296f, 0.657806695f, 0.656650543f, 0.655492842f, 0.654333591f, 0.653172851f, 0.652010560f, 0.650846660f, 0.649681330f, 0.648514390f, 0.647345960f, 0.646176040f, 0.645004511f, 0.643831551f, 0.642657042f, 0.641481042f, 0.640303493f, 0.639124453f, 0.637943923f, 0.636761844f, 0.635578334f, 0.634393275f, 0.633206785f, 0.632018745f, 0.630829215f, 0.629638255f, 0.628445745f, 0.627251804f, 0.626056373f, 0.624859512f, 0.623661101f, 0.622461259f, 0.621259987f, 0.620057225f, 0.618852973f, 0.617647290f, 0.616440177f, 0.615231574f, 0.614021540f, 0.612810075f, 0.611597180f, 0.610382795f, 0.609167039f, 0.607949793f, 0.606731117f, 0.605511069f, 0.604289532f, 0.603066623f, 0.601842225f, 0.600616455f, 0.599389315f, 0.598160684f, 0.596930683f, 0.595699310f, 0.594466507f, 0.593232274f, 0.591996670f, 0.590759695f, 0.589521289f, 0.588281572f, 0.587040365f, 0.585797846f, 0.584553957f, 0.583308637f, 0.582062006f, 0.580813944f, 0.579564571f, 0.578313768f, 0.577061653f, 0.575808167f, 0.574553370f, 0.573297143f, 0.572039604f, 0.570780754f, 0.569520533f, 0.568258941f, 0.566996038f, 0.565731823f, 0.564466238f, 0.563199341f, 0.561931133f, 0.560661554f, 0.559390724f, 0.558118522f, 0.556845009f, 0.555570245f, 0.554294109f, 0.553016722f, 0.551737964f, 0.550457954f, 0.549176633f, 0.547894061f, 0.546610177f, 0.545324981f, 0.544038534f, 0.542750776f, 0.541461766f, 0.540171444f, 0.538879931f, 0.537587047f, 0.536292970f, 0.534997642f, 0.533701003f, 0.532403111f, 0.531104028f, 0.529803634f, 0.528501987f, 0.527199149f, 0.525895000f, 0.524589658f, 0.523283124f, 0.521975279f, 0.520666242f, 0.519356012f, 0.518044531f, 0.516731799f, 0.515417874f, 0.514102757f, 0.512786388f, 0.511468828f, 0.510150075f, 0.508830130f, 0.507508993f, 0.506186664f, 0.504863083f, 0.503538370f, 0.502212465f, 0.500885367f, 0.499557108f, 0.498227656f, 0.496897042f, 0.495565265f, 0.494232297f, 0.492898196f, 0.491562903f, 0.490226477f, 0.488888890f, 0.487550169f, 0.486210287f, 0.484869242f, 0.483527064f, 0.482183784f, 0.480839342f, 0.479493767f, 0.478147060f, 0.476799220f, 0.475450277f, 0.474100202f, 0.472749025f, 0.471396744f, 0.470043331f, 0.468688816f, 0.467333198f, 0.465976506f, 0.464618683f, 0.463259786f, 0.461899787f, 0.460538715f, 0.459176540f, 0.457813293f, 0.456448972f, 0.455083579f, 0.453717113f, 0.452349573f, 0.450980991f, 0.449611336f, 0.448240608f, 0.446868837f, 0.445496023f, 0.444122136f, 0.442747235f, 0.441371262f, 0.439994276f, 0.438616246f, 0.437237173f, 0.435857087f, 0.434475958f, 0.433093816f, 0.431710660f, 0.430326492f, 0.428941280f, 0.427555084f, 0.426167876f, 0.424779683f, 0.423390478f, 0.422000259f, 0.420609087f, 0.419216901f, 0.417823702f, 0.416429549f, 0.415034413f, 0.413638324f, 0.412241220f, 0.410843164f, 0.409444153f, 0.408044159f, 0.406643212f, 0.405241311f, 0.403838456f, 0.402434647f, 0.401029885f, 0.399624199f, 0.398217559f, 0.396809995f, 0.395401478f, 0.393992037f, 0.392581671f, 0.391170382f, 0.389758170f, 0.388345033f, 0.386931002f, 0.385516047f, 0.384100199f, 0.382683426f, 0.381265759f, 0.379847199f, 0.378427744f, 0.377007425f, 0.375586182f, 0.374164075f, 0.372741073f, 0.371317208f, 0.369892448f, 0.368466824f, 0.367040336f, 0.365612984f, 0.364184797f, 0.362755716f, 0.361325800f, 0.359895051f, 0.358463407f, 0.357030958f, 0.355597675f, 0.354163527f, 0.352728546f, 0.351292759f, 0.349856138f, 0.348418683f, 0.346980423f, 0.345541328f, 0.344101429f, 0.342660725f, 0.341219217f, 0.339776874f, 0.338333756f, 0.336889863f, 0.335445136f, 0.333999664f, 0.332553357f, 0.331106305f, 0.329658449f, 0.328209847f, 0.326760441f, 0.325310290f, 0.323859364f, 0.322407693f, 0.320955247f, 0.319502026f, 0.318048090f, 0.316593379f, 0.315137923f, 0.313681751f, 0.312224805f, 0.310767144f, 0.309308767f, 0.307849646f, 0.306389809f, 0.304929227f, 0.303467959f, 0.302005947f, 0.300543249f, 0.299079835f, 0.297615707f, 0.296150893f, 0.294685364f, 0.293219149f, 0.291752249f, 0.290284663f, 0.288816422f, 0.287347466f, 0.285877824f, 0.284407526f, 0.282936573f, 0.281464934f, 0.279992640f, 0.278519690f, 0.277046084f, 0.275571823f, 0.274096906f, 0.272621363f, 0.271145165f, 0.269668311f, 0.268190861f, 0.266712755f, 0.265234023f, 0.263754666f, 0.262274712f, 0.260794103f, 0.259312928f, 0.257831097f, 0.256348670f, 0.254865646f, 0.253382027f, 0.251897812f, 0.250413001f, 0.248927608f, 0.247441620f, 0.245955050f, 0.244467899f, 0.242980182f, 0.241491884f, 0.240003020f, 0.238513589f, 0.237023607f, 0.235533059f, 0.234041959f, 0.232550308f, 0.231058106f, 0.229565367f, 0.228072077f, 0.226578265f, 0.225083917f, 0.223589033f, 0.222093627f, 0.220597684f, 0.219101235f, 0.217604280f, 0.216106802f, 0.214608818f, 0.213110313f, 0.211611331f, 0.210111842f, 0.208611846f, 0.207111374f, 0.205610409f, 0.204108968f, 0.202607036f, 0.201104641f, 0.199601755f, 0.198098406f, 0.196594596f, 0.195090324f, 0.193585590f, 0.192080393f, 0.190574750f, 0.189068660f, 0.187562123f, 0.186055154f, 0.184547737f, 0.183039889f, 0.181531608f, 0.180022895f, 0.178513765f, 0.177004218f, 0.175494254f, 0.173983872f, 0.172473088f, 0.170961887f, 0.169450298f, 0.167938292f, 0.166425899f, 0.164913118f, 0.163399950f, 0.161886394f, 0.160372451f, 0.158858150f, 0.157343462f, 0.155828401f, 0.154312968f, 0.152797192f, 0.151281044f, 0.149764538f, 0.148247674f, 0.146730468f, 0.145212919f, 0.143695027f, 0.142176807f, 0.140658244f, 0.139139339f, 0.137620121f, 0.136100575f, 0.134580702f, 0.133060530f, 0.131540030f, 0.130019218f, 0.128498107f, 0.126976699f, 0.125454977f, 0.123932973f, 0.122410677f, 0.120888084f, 0.119365215f, 0.117842063f, 0.116318628f, 0.114794925f, 0.113270953f, 0.111746714f, 0.110222206f, 0.108697444f, 0.107172422f, 0.105647154f, 0.104121633f, 0.102595866f, 0.101069860f, 0.099543616f, 0.098017141f, 0.096490428f, 0.094963498f, 0.093436338f, 0.091908954f, 0.090381362f, 0.088853553f, 0.087325536f, 0.085797310f, 0.084268890f, 0.082740262f, 0.081211448f, 0.079682440f, 0.078153245f, 0.076623864f, 0.075094298f, 0.073564567f, 0.072034650f, 0.070504576f, 0.068974331f, 0.067443922f, 0.065913349f, 0.064382628f, 0.062851757f, 0.061320737f, 0.059789572f, 0.058258265f, 0.056726821f, 0.055195246f, 0.053663537f, 0.052131705f, 0.050599750f, 0.049067676f, 0.047535483f, 0.046003181f, 0.044470772f, 0.042938258f, 0.041405641f, 0.039872926f, 0.038340122f, 0.036807224f, 0.035274237f, 0.033741172f, 0.032208025f, 0.030674804f, 0.029141508f, 0.027608145f, 0.026074719f, 0.024541229f, 0.023007682f, 0.021474080f, 0.019940428f, 0.018406730f, 0.016872987f, 0.015339206f, 0.0138053885f, 0.012271538f, 0.010737659f, 0.009203754f, 0.007669829f, 0.0061358847f, 0.004601926f, 0.0030679568f, 0.0015339801f, 0.000000000f, -0.0015339801f, -0.0030679568f, -0.004601926f, -0.0061358847f, -0.007669829f, -0.009203754f, -0.010737659f, -0.012271538f, -0.0138053885f, -0.015339206f, -0.016872987f, -0.018406730f, -0.019940428f, -0.021474080f, -0.023007682f, -0.024541229f, -0.026074719f, -0.027608145f, -0.029141508f, -0.030674804f, -0.032208025f, -0.033741172f, -0.035274237f, -0.036807224f, -0.038340122f, -0.039872926f, -0.041405641f, -0.042938258f, -0.044470772f, -0.046003181f, -0.047535483f, -0.049067676f, -0.050599750f, -0.052131705f, -0.053663537f, -0.055195246f, -0.056726821f, -0.058258265f, -0.059789572f, -0.061320737f, -0.062851757f, -0.064382628f, -0.065913349f, -0.067443922f, -0.068974331f, -0.070504576f, -0.072034650f, -0.073564567f, -0.075094298f, -0.076623864f, -0.078153245f, -0.079682440f, -0.081211448f, -0.082740262f, -0.084268890f, -0.085797310f, -0.087325536f, -0.088853553f, -0.090381362f, -0.091908954f, -0.093436338f, -0.094963498f, -0.096490428f, -0.098017141f, -0.099543616f, -0.101069860f, -0.102595866f, -0.104121633f, -0.105647154f, -0.107172422f, -0.108697444f, -0.110222206f, -0.111746714f, -0.113270953f, -0.114794925f, -0.116318628f, -0.117842063f, -0.119365215f, -0.120888084f, -0.122410677f, -0.123932973f, -0.125454977f, -0.126976699f, -0.128498107f, -0.130019218f, -0.131540030f, -0.133060530f, -0.134580702f, -0.136100575f, -0.137620121f, -0.139139339f, -0.140658244f, -0.142176807f, -0.143695027f, -0.145212919f, -0.146730468f, -0.148247674f, -0.149764538f, -0.151281044f, -0.152797192f, -0.154312968f, -0.155828401f, -0.157343462f, -0.158858150f, -0.160372451f, -0.161886394f, -0.163399950f, -0.164913118f, -0.166425899f, -0.167938292f, -0.169450298f, -0.170961887f, -0.172473088f, -0.173983872f, -0.175494254f, -0.177004218f, -0.178513765f, -0.180022895f, -0.181531608f, -0.183039889f, -0.184547737f, -0.186055154f, -0.187562123f, -0.189068660f, -0.190574750f, -0.192080393f, -0.193585590f, -0.195090324f, -0.196594596f, -0.198098406f, -0.199601755f, -0.201104641f, -0.202607036f, -0.204108968f, -0.205610409f, -0.207111374f, -0.208611846f, -0.210111842f, -0.211611331f, -0.213110313f, -0.214608818f, -0.216106802f, -0.217604280f, -0.219101235f, -0.220597684f, -0.222093627f, -0.223589033f, -0.225083917f, -0.226578265f, -0.228072077f, -0.229565367f, -0.231058106f, -0.232550308f, -0.234041959f, -0.235533059f, -0.237023607f, -0.238513589f, -0.240003020f, -0.241491884f, -0.242980182f, -0.244467899f, -0.245955050f, -0.247441620f, -0.248927608f, -0.250413001f, -0.251897812f, -0.253382027f, -0.254865646f, -0.256348670f, -0.257831097f, -0.259312928f, -0.260794103f, -0.262274712f, -0.263754666f, -0.265234023f, -0.266712755f, -0.268190861f, -0.269668311f, -0.271145165f, -0.272621363f, -0.274096906f, -0.275571823f, -0.277046084f, -0.278519690f, -0.279992640f, -0.281464934f, -0.282936573f, -0.284407526f, -0.285877824f, -0.287347466f, -0.288816422f, -0.290284663f, -0.291752249f, -0.293219149f, -0.294685364f, -0.296150893f, -0.297615707f, -0.299079835f, -0.300543249f, -0.302005947f, -0.303467959f, -0.304929227f, -0.306389809f, -0.307849646f, -0.309308767f, -0.310767144f, -0.312224805f, -0.313681751f, -0.315137923f, -0.316593379f, -0.318048090f, -0.319502026f, -0.320955247f, -0.322407693f, -0.323859364f, -0.325310290f, -0.326760441f, -0.328209847f, -0.329658449f, -0.331106305f, -0.332553357f, -0.333999664f, -0.335445136f, -0.336889863f, -0.338333756f, -0.339776874f, -0.341219217f, -0.342660725f, -0.344101429f, -0.345541328f, -0.346980423f, -0.348418683f, -0.349856138f, -0.351292759f, -0.352728546f, -0.354163527f, -0.355597675f, -0.357030958f, -0.358463407f, -0.359895051f, -0.361325800f, -0.362755716f, -0.364184797f, -0.365612984f, -0.367040336f, -0.368466824f, -0.369892448f, -0.371317208f, -0.372741073f, -0.374164075f, -0.375586182f, -0.377007425f, -0.378427744f, -0.379847199f, -0.381265759f, -0.382683426f, -0.384100199f, -0.385516047f, -0.386931002f, -0.388345033f, -0.389758170f, -0.391170382f, -0.392581671f, -0.393992037f, -0.395401478f, -0.396809995f, -0.398217559f, -0.399624199f, -0.401029885f, -0.402434647f, -0.403838456f, -0.405241311f, -0.406643212f, -0.408044159f, -0.409444153f, -0.410843164f, -0.412241220f, -0.413638324f, -0.415034413f, -0.416429549f, -0.417823702f, -0.419216901f, -0.420609087f, -0.422000259f, -0.423390478f, -0.424779683f, -0.426167876f, -0.427555084f, -0.428941280f, -0.430326492f, -0.431710660f, -0.433093816f, -0.434475958f, -0.435857087f, -0.437237173f, -0.438616246f, -0.439994276f, -0.441371262f, -0.442747235f, -0.444122136f, -0.445496023f, -0.446868837f, -0.448240608f, -0.449611336f, -0.450980991f, -0.452349573f, -0.453717113f, -0.455083579f, -0.456448972f, -0.457813293f, -0.459176540f, -0.460538715f, -0.461899787f, -0.463259786f, -0.464618683f, -0.465976506f, -0.467333198f, -0.468688816f, -0.470043331f, -0.471396744f, -0.472749025f, -0.474100202f, -0.475450277f, -0.476799220f, -0.478147060f, -0.479493767f, -0.480839342f, -0.482183784f, -0.483527064f, -0.484869242f, -0.486210287f, -0.487550169f, -0.488888890f, -0.490226477f, -0.491562903f, -0.492898196f, -0.494232297f, -0.495565265f, -0.496897042f, -0.498227656f, -0.499557108f, -0.500885367f, -0.502212465f, -0.503538370f, -0.504863083f, -0.506186664f, -0.507508993f, -0.508830130f, -0.510150075f, -0.511468828f, -0.512786388f, -0.514102757f, -0.515417874f, -0.516731799f, -0.518044531f, -0.519356012f, -0.520666242f, -0.521975279f, -0.523283124f, -0.524589658f, -0.525895000f, -0.527199149f, -0.528501987f, -0.529803634f, -0.531104028f, -0.532403111f, -0.533701003f, -0.534997642f, -0.536292970f, -0.537587047f, -0.538879931f, -0.540171444f, -0.541461766f, -0.542750776f, -0.544038534f, -0.545324981f, -0.546610177f, -0.547894061f, -0.549176633f, -0.550457954f, -0.551737964f, -0.553016722f, -0.554294109f, -0.555570245f, -0.556845009f, -0.558118522f, -0.559390724f, -0.560661554f, -0.561931133f, -0.563199341f, -0.564466238f, -0.565731823f, -0.566996038f, -0.568258941f, -0.569520533f, -0.570780754f, -0.572039604f, -0.573297143f, -0.574553370f, -0.575808167f, -0.577061653f, -0.578313768f, -0.579564571f, -0.580813944f, -0.582062006f, -0.583308637f, -0.584553957f, -0.585797846f, -0.587040365f, -0.588281572f, -0.589521289f, -0.590759695f, -0.591996670f, -0.593232274f, -0.594466507f, -0.595699310f, -0.596930683f, -0.598160684f, -0.599389315f, -0.600616455f, -0.601842225f, -0.603066623f, -0.604289532f, -0.605511069f, -0.606731117f, -0.607949793f, -0.609167039f, -0.610382795f, -0.611597180f, -0.612810075f, -0.614021540f, -0.615231574f, -0.616440177f, -0.617647290f, -0.618852973f, -0.620057225f, -0.621259987f, -0.622461259f, -0.623661101f, -0.624859512f, -0.626056373f, -0.627251804f, -0.628445745f, -0.629638255f, -0.630829215f, -0.632018745f, -0.633206785f, -0.634393275f, -0.635578334f, -0.636761844f, -0.637943923f, -0.639124453f, -0.640303493f, -0.641481042f, -0.642657042f, -0.643831551f, -0.645004511f, -0.646176040f, -0.647345960f, -0.648514390f, -0.649681330f, -0.650846660f, -0.652010560f, -0.653172851f, -0.654333591f, -0.655492842f, -0.656650543f, -0.657806695f, -0.658961296f, -0.660114348f, -0.661265850f, -0.662415802f, -0.663564146f, -0.664710999f, -0.665856242f, -0.666999936f, -0.668142021f, -0.669282615f, -0.670421541f, -0.671558976f, -0.672694743f, -0.673829019f, -0.674961627f, -0.676092684f, -0.677222192f, -0.678350031f, -0.679476321f, -0.680601001f, -0.681724072f, -0.682845533f, -0.683965385f, -0.685083687f, -0.686200321f, -0.687315345f, -0.688428760f, -0.689540565f, -0.690650702f, -0.691759229f, -0.692866147f, -0.693971455f, -0.695075095f, -0.696177125f, -0.697277486f, -0.698376238f, -0.699473321f, -0.700568795f, -0.701662600f, -0.702754736f, -0.703845263f, -0.704934061f, -0.706021249f, -0.707106769f, -0.708190620f, -0.709272802f, -0.710353374f, -0.711432219f, -0.712509394f, -0.713584840f, -0.714658678f, -0.715730846f, -0.716801286f, -0.717870057f, -0.718937099f, -0.720002532f, -0.721066177f, -0.722128212f, -0.723188460f, -0.724247098f, -0.725303948f, -0.726359129f, -0.727412641f, -0.728464365f, -0.729514420f, -0.730562747f, -0.731609404f, -0.732654274f, -0.733697414f, -0.734738886f, -0.735778570f, -0.736816585f, -0.737852812f, -0.738887310f, -0.739920080f, -0.740951121f, -0.741980433f, -0.743007958f, -0.744033754f, -0.745057762f, -0.746080101f, -0.747100592f, -0.748119354f, -0.749136388f, -0.750151634f, -0.751165152f, -0.752176821f, -0.753186822f, -0.754194975f, -0.755201399f, -0.756205976f, -0.757208824f, -0.758209884f, -0.759209216f, -0.760206699f, -0.761202395f, -0.762196302f, -0.763188422f, -0.764178753f, -0.765167236f, -0.766153991f, -0.767138898f, -0.768122017f, -0.769103348f, -0.770082831f, -0.771060526f, -0.772036374f, -0.773010433f, -0.773982704f, -0.774953127f, -0.775921702f, -0.776888490f, -0.777853429f, -0.778816521f, -0.779777765f, -0.780737221f, -0.781694829f, -0.782650590f, -0.783604503f, -0.784556568f, -0.785506845f, -0.786455214f, -0.787401736f, -0.788346410f, -0.789289236f, -0.790230215f, -0.791169345f, -0.792106569f, -0.793041945f, -0.793975472f, -0.794907153f, -0.795836926f, -0.796764791f, -0.797690868f, -0.798614979f, -0.799537241f, -0.800457656f, -0.801376164f, -0.802292824f, -0.803207517f, -0.804120362f, -0.805031359f, -0.805940390f, -0.806847572f, -0.807752848f, -0.808656156f, -0.809557617f, -0.810457170f, -0.811354876f, -0.812250614f, -0.813144386f, -0.814036310f, -0.814926326f, -0.815814435f, -0.816700578f, -0.817584813f, -0.818467140f, -0.819347501f, -0.820225954f, -0.821102500f, -0.821977139f, -0.822849810f, -0.823720515f, -0.824589312f, -0.825456142f, -0.826321065f, -0.827184021f, -0.828045070f, -0.828904092f, -0.829761207f, -0.830616415f, -0.831469595f, -0.832320869f, -0.833170176f, -0.834017515f, -0.834862888f, -0.835706294f, -0.836547732f, -0.837387204f, -0.838224709f, -0.839060247f, -0.839893818f, -0.840725362f, -0.841554999f, -0.842382610f, -0.843208253f, -0.844031870f, -0.844853580f, -0.845673263f, -0.846490920f, -0.847306609f, -0.848120332f, -0.848932028f, -0.849741757f, -0.850549459f, -0.851355195f, -0.852158904f, -0.852960587f, -0.853760302f, -0.854557991f, -0.855353653f, -0.856147349f, -0.856938958f, -0.857728601f, -0.858516216f, -0.859301805f, -0.860085368f, -0.860866964f, -0.861646473f, -0.862423956f, -0.863199413f, -0.863972843f, -0.864744246f, -0.865513623f, -0.866280973f, -0.867046237f, -0.867809474f, -0.868570685f, -0.869329870f, -0.870086968f, -0.870842040f, -0.871595085f, -0.872346044f, -0.873094976f, -0.873841822f, -0.874586642f, -0.875329375f, -0.876070082f, -0.876808703f, -0.877545297f, -0.878279805f, -0.879012227f, -0.879742622f, -0.880470872f, -0.881197095f, -0.881921291f, -0.882643342f, -0.883363366f, -0.884081244f, -0.884797096f, -0.885510862f, -0.886222541f, -0.886932135f, -0.887639642f, -0.888345063f, -0.889048338f, -0.889749587f, -0.890448749f, -0.891145766f, -0.891840696f, -0.892533541f, -0.893224299f, -0.893912971f, -0.894599497f, -0.895283937f, -0.895966232f, -0.896646500f, -0.897324562f, -0.898000598f, -0.898674488f, -0.899346232f, -0.900015891f, -0.900683403f, -0.901348829f, -0.902012169f, -0.902673304f, -0.903332353f, -0.903989315f, -0.904644072f, -0.905296743f, -0.905947268f, -0.906595707f, -0.907242000f, -0.907886088f, -0.908528090f, -0.909168005f, -0.909805715f, -0.910441279f, -0.911074758f, -0.911706030f, -0.912335157f, -0.912962198f, -0.913587034f, -0.914209783f, -0.914830327f, -0.915448725f, -0.916064978f, -0.916679084f, -0.917290986f, -0.917900801f, -0.918508410f, -0.919113874f, -0.919717133f, -0.920318305f, -0.920917213f, -0.921514034f, -0.922108650f, -0.922701120f, -0.923291445f, -0.923879504f, -0.924465477f, -0.925049245f, -0.925630808f, -0.926210225f, -0.926787496f, -0.927362502f, -0.927935421f, -0.928506076f, -0.929074585f, -0.929640889f, -0.930205047f, -0.930766940f, -0.931326687f, -0.931884289f, -0.932439625f, -0.932992816f, -0.933543801f, -0.934092522f, -0.934639156f, -0.935183525f, -0.935725689f, -0.936265647f, -0.936803460f, -0.937339008f, -0.937872350f, -0.938403547f, -0.938932478f, -0.939459205f, -0.939983726f, -0.940506041f, -0.941026151f, -0.941544056f, -0.942059755f, -0.942573190f, -0.943084419f, -0.943593442f, -0.944100261f, -0.944604814f, -0.945107222f, -0.945607305f, -0.946105242f, -0.946600914f, -0.947094381f, -0.947585583f, -0.948074579f, -0.948561370f, -0.949045897f, -0.949528158f, -0.950008273f, -0.950486064f, -0.950961649f, -0.951435030f, -0.951906145f, -0.952374995f, -0.952841640f, -0.953306019f, -0.953768194f, -0.954228103f, -0.954685748f, -0.955141187f, -0.955594361f, -0.956045270f, -0.956493914f, -0.956940353f, -0.957384527f, -0.957826436f, -0.958266079f, -0.958703458f, -0.959138632f, -0.959571540f, -0.960002124f, -0.960430503f, -0.960856616f, -0.961280465f, -0.961702049f, -0.962121427f, -0.962538481f, -0.962953269f, -0.963365793f, -0.963776052f, -0.964184046f, -0.964589775f, -0.964993238f, -0.965394437f, -0.965793371f, -0.966189981f, -0.966584384f, -0.966976464f, -0.967366278f, -0.967753828f, -0.968139112f, -0.968522072f, -0.968902826f, -0.969281256f, -0.969657362f, -0.970031261f, -0.970402837f, -0.970772147f, -0.971139133f, -0.971503913f, -0.971866310f, -0.972226501f, -0.972584367f, -0.972939968f, -0.973293245f, -0.973644257f, -0.973992944f, -0.974339366f, -0.974683523f, -0.975025356f, -0.975364864f, -0.975702107f, -0.976037085f, -0.976369739f, -0.976700068f, -0.977028131f, -0.977353871f, -0.977677345f, -0.977998495f, -0.978317380f, -0.978633940f, -0.978948176f, -0.979260147f, -0.979569793f, -0.979877114f, -0.980182111f, -0.980484843f, -0.980785251f, -0.981083393f, -0.981379211f, -0.981672704f, -0.981963873f, -0.982252717f, -0.982539296f, -0.982823551f, -0.983105481f, -0.983385086f, -0.983662426f, -0.983937442f, -0.984210074f, -0.984480441f, -0.984748483f, -0.985014260f, -0.985277653f, -0.985538721f, -0.985797524f, -0.986053944f, -0.986308098f, -0.986559927f, -0.986809373f, -0.987056553f, -0.987301409f, -0.987543941f, -0.987784147f, -0.988022029f, -0.988257587f, -0.988490820f, -0.988721669f, -0.988950253f, -0.989176512f, -0.989400446f, -0.989621997f, -0.989841282f, -0.990058184f, -0.990272820f, -0.990485072f, -0.990695000f, -0.990902662f, -0.991107941f, -0.991310835f, -0.991511464f, -0.991709769f, -0.991905689f, -0.992099285f, -0.992290616f, -0.992479563f, -0.992666125f, -0.992850423f, -0.993032336f, -0.993211925f, -0.993389189f, -0.993564129f, -0.993736744f, -0.993906975f, -0.994074881f, -0.994240463f, -0.994403660f, -0.994564593f, -0.994723141f, -0.994879305f, -0.995033205f, -0.995184720f, -0.995333910f, -0.995480776f, -0.995625257f, -0.995767415f, -0.995907247f, -0.996044695f, -0.996179819f, -0.996312618f, -0.996443033f, -0.996571124f, -0.996696889f, -0.996820271f, -0.996941328f, -0.997060061f, -0.997176409f, -0.997290432f, -0.997402132f, -0.997511446f, -0.997618437f, -0.997723043f, -0.997825325f, -0.997925282f, -0.998022854f, -0.998118103f, -0.998211026f, -0.998301566f, -0.998389721f, -0.998475552f, -0.998559058f, -0.998640239f, -0.998719037f, -0.998795450f, -0.998869538f, -0.998941302f, -0.999010682f, -0.999077737f, -0.999142408f, -0.999204755f, -0.999264777f, -0.999322355f, -0.999377668f, -0.999430597f, -0.999481201f, -0.999529421f, -0.999575317f, -0.999618828f, -0.999660015f, -0.999698818f, -0.999735296f, -0.999769390f, -0.999801159f, -0.999830604f, -0.999857664f, -0.999882340f, -0.999904692f, -0.999924719f, -0.999942362f, -0.999957621f, -0.999970615f, -0.999981165f, -0.999989390f, -0.999995291f, -0.999998808f, -1.000000000f, -0.999998808f, -0.999995291f, -0.999989390f, -0.999981165f, -0.999970615f, -0.999957621f, -0.999942362f, -0.999924719f, -0.999904692f, -0.999882340f, -0.999857664f, -0.999830604f, -0.999801159f, -0.999769390f, -0.999735296f, -0.999698818f, -0.999660015f, -0.999618828f, -0.999575317f, -0.999529421f, -0.999481201f, -0.999430597f, -0.999377668f, -0.999322355f, -0.999264777f, -0.999204755f, -0.999142408f, -0.999077737f, -0.999010682f, -0.998941302f, -0.998869538f, -0.998795450f, -0.998719037f, -0.998640239f, -0.998559058f, -0.998475552f, -0.998389721f, -0.998301566f, -0.998211026f, -0.998118103f, -0.998022854f, -0.997925282f, -0.997825325f, -0.997723043f, -0.997618437f, -0.997511446f, -0.997402132f, -0.997290432f, -0.997176409f, -0.997060061f, -0.996941328f, -0.996820271f, -0.996696889f, -0.996571124f, -0.996443033f, -0.996312618f, -0.996179819f, -0.996044695f, -0.995907247f, -0.995767415f, -0.995625257f, -0.995480776f, -0.995333910f, -0.995184720f, -0.995033205f, -0.994879305f, -0.994723141f, -0.994564593f, -0.994403660f, -0.994240463f, -0.994074881f, -0.993906975f, -0.993736744f, -0.993564129f, -0.993389189f, -0.993211925f, -0.993032336f, -0.992850423f, -0.992666125f, -0.992479563f, -0.992290616f, -0.992099285f, -0.991905689f, -0.991709769f, -0.991511464f, -0.991310835f, -0.991107941f, -0.990902662f, -0.990695000f, -0.990485072f, -0.990272820f, -0.990058184f, -0.989841282f, -0.989621997f, -0.989400446f, -0.989176512f, -0.988950253f, -0.988721669f, -0.988490820f, -0.988257587f, -0.988022029f, -0.987784147f, -0.987543941f, -0.987301409f, -0.987056553f, -0.986809373f, -0.986559927f, -0.986308098f, -0.986053944f, -0.985797524f, -0.985538721f, -0.985277653f, -0.985014260f, -0.984748483f, -0.984480441f, -0.984210074f, -0.983937442f, -0.983662426f, -0.983385086f, -0.983105481f, -0.982823551f, -0.982539296f, -0.982252717f, -0.981963873f, -0.981672704f, -0.981379211f, -0.981083393f, -0.980785251f, -0.980484843f, -0.980182111f, -0.979877114f, -0.979569793f, -0.979260147f, -0.978948176f, -0.978633940f, -0.978317380f, -0.977998495f, -0.977677345f, -0.977353871f, -0.977028131f, -0.976700068f, -0.976369739f, -0.976037085f, -0.975702107f, -0.975364864f, -0.975025356f, -0.974683523f, -0.974339366f, -0.973992944f, -0.973644257f, -0.973293245f, -0.972939968f, -0.972584367f, -0.972226501f, -0.971866310f, -0.971503913f, -0.971139133f, -0.970772147f, -0.970402837f, -0.970031261f, -0.969657362f, -0.969281256f, -0.968902826f, -0.968522072f, -0.968139112f, -0.967753828f, -0.967366278f, -0.966976464f, -0.966584384f, -0.966189981f, -0.965793371f, -0.965394437f, -0.964993238f, -0.964589775f, -0.964184046f, -0.963776052f, -0.963365793f, -0.962953269f, -0.962538481f, -0.962121427f, -0.961702049f, -0.961280465f, -0.960856616f, -0.960430503f, -0.960002124f, -0.959571540f, -0.959138632f, -0.958703458f, -0.958266079f, -0.957826436f, -0.957384527f, -0.956940353f, -0.956493914f, -0.956045270f, -0.955594361f, -0.955141187f, -0.954685748f, -0.954228103f, -0.953768194f, -0.953306019f, -0.952841640f, -0.952374995f, -0.951906145f, -0.951435030f, -0.950961649f, -0.950486064f, -0.950008273f, -0.949528158f, -0.949045897f, -0.948561370f, -0.948074579f, -0.947585583f, -0.947094381f, -0.946600914f, -0.946105242f, -0.945607305f, -0.945107222f, -0.944604814f, -0.944100261f, -0.943593442f, -0.943084419f, -0.942573190f, -0.942059755f, -0.941544056f, -0.941026151f, -0.940506041f, -0.939983726f, -0.939459205f, -0.938932478f, -0.938403547f, -0.937872350f, -0.937339008f, -0.936803460f, -0.936265647f, -0.935725689f, -0.935183525f, -0.934639156f, -0.934092522f, -0.933543801f, -0.932992816f, -0.932439625f, -0.931884289f, -0.931326687f, -0.930766940f, -0.930205047f, -0.929640889f, -0.929074585f, -0.928506076f, -0.927935421f, -0.927362502f, -0.926787496f, -0.926210225f, -0.925630808f, -0.925049245f, -0.924465477f, -0.923879504f, -0.923291445f, -0.922701120f, -0.922108650f, -0.921514034f, -0.920917213f, -0.920318305f, -0.919717133f, -0.919113874f, -0.918508410f, -0.917900801f, -0.917290986f, -0.916679084f, -0.916064978f, -0.915448725f, -0.914830327f, -0.914209783f, -0.913587034f, -0.912962198f, -0.912335157f, -0.911706030f, -0.911074758f, -0.910441279f, -0.909805715f, -0.909168005f, -0.908528090f, -0.907886088f, -0.907242000f, -0.906595707f, -0.905947268f, -0.905296743f, -0.904644072f, -0.903989315f, -0.903332353f, -0.902673304f, -0.902012169f, -0.901348829f, -0.900683403f, -0.900015891f, -0.899346232f, -0.898674488f, -0.898000598f, -0.897324562f, -0.896646500f, -0.895966232f, -0.895283937f, -0.894599497f, -0.893912971f, -0.893224299f, -0.892533541f, -0.891840696f, -0.891145766f, -0.890448749f, -0.889749587f, -0.889048338f, -0.888345063f, -0.887639642f, -0.886932135f, -0.886222541f, -0.885510862f, -0.884797096f, -0.884081244f, -0.883363366f, -0.882643342f, -0.881921291f, -0.881197095f, -0.880470872f, -0.879742622f, -0.879012227f, -0.878279805f, -0.877545297f, -0.876808703f, -0.876070082f, -0.875329375f, -0.874586642f, -0.873841822f, -0.873094976f, -0.872346044f, -0.871595085f, -0.870842040f, -0.870086968f, -0.869329870f, -0.868570685f, -0.867809474f, -0.867046237f, -0.866280973f, -0.865513623f, -0.864744246f, -0.863972843f, -0.863199413f, -0.862423956f, -0.861646473f, -0.860866964f, -0.860085368f, -0.859301805f, -0.858516216f, -0.857728601f, -0.856938958f, -0.856147349f, -0.855353653f, -0.854557991f, -0.853760302f, -0.852960587f, -0.852158904f, -0.851355195f, -0.850549459f, -0.849741757f, -0.848932028f, -0.848120332f, -0.847306609f, -0.846490920f, -0.845673263f, -0.844853580f, -0.844031870f, -0.843208253f, -0.842382610f, -0.841554999f, -0.840725362f, -0.839893818f, -0.839060247f, -0.838224709f, -0.837387204f, -0.836547732f, -0.835706294f, -0.834862888f, -0.834017515f, -0.833170176f, -0.832320869f, -0.831469595f, -0.830616415f, -0.829761207f, -0.828904092f, -0.828045070f, -0.827184021f, -0.826321065f, -0.825456142f, -0.824589312f, -0.823720515f, -0.822849810f, -0.821977139f, -0.821102500f, -0.820225954f, -0.819347501f, -0.818467140f, -0.817584813f, -0.816700578f, -0.815814435f, -0.814926326f, -0.814036310f, -0.813144386f, -0.812250614f, -0.811354876f, -0.810457170f, -0.809557617f, -0.808656156f, -0.807752848f, -0.806847572f, -0.805940390f, -0.805031359f, -0.804120362f, -0.803207517f, -0.802292824f, -0.801376164f, -0.800457656f, -0.799537241f, -0.798614979f, -0.797690868f, -0.796764791f, -0.795836926f, -0.794907153f, -0.793975472f, -0.793041945f, -0.792106569f, -0.791169345f, -0.790230215f, -0.789289236f, -0.788346410f, -0.787401736f, -0.786455214f, -0.785506845f, -0.784556568f, -0.783604503f, -0.782650590f, -0.781694829f, -0.780737221f, -0.779777765f, -0.778816521f, -0.777853429f, -0.776888490f, -0.775921702f, -0.774953127f, -0.773982704f, -0.773010433f, -0.772036374f, -0.771060526f, -0.770082831f, -0.769103348f, -0.768122017f, -0.767138898f, -0.766153991f, -0.765167236f, -0.764178753f, -0.763188422f, -0.762196302f, -0.761202395f, -0.760206699f, -0.759209216f, -0.758209884f, -0.757208824f, -0.756205976f, -0.755201399f, -0.754194975f, -0.753186822f, -0.752176821f, -0.751165152f, -0.750151634f, -0.749136388f, -0.748119354f, -0.747100592f, -0.746080101f, -0.745057762f, -0.744033754f, -0.743007958f, -0.741980433f, -0.740951121f, -0.739920080f, -0.738887310f, -0.737852812f, -0.736816585f, -0.735778570f, -0.734738886f, -0.733697414f, -0.732654274f, -0.731609404f, -0.730562747f, -0.729514420f, -0.728464365f, -0.727412641f, -0.726359129f, -0.725303948f, -0.724247098f, -0.723188460f, -0.722128212f, -0.721066177f, -0.720002532f, -0.718937099f, -0.717870057f, -0.716801286f, -0.715730846f, -0.714658678f, -0.713584840f, -0.712509394f, -0.711432219f, -0.710353374f, -0.709272802f, -0.708190620f, -0.707106769f, -0.706021249f, -0.704934061f, -0.703845263f, -0.702754736f, -0.701662600f, -0.700568795f, -0.699473321f, -0.698376238f, -0.697277486f, -0.696177125f, -0.695075095f, -0.693971455f, -0.692866147f, -0.691759229f, -0.690650702f, -0.689540565f, -0.688428760f, -0.687315345f, -0.686200321f, -0.685083687f, -0.683965385f, -0.682845533f, -0.681724072f, -0.680601001f, -0.679476321f, -0.678350031f, -0.677222192f, -0.676092684f, -0.674961627f, -0.673829019f, -0.672694743f, -0.671558976f, -0.670421541f, -0.669282615f, -0.668142021f, -0.666999936f, -0.665856242f, -0.664710999f, -0.663564146f, -0.662415802f, -0.661265850f, -0.660114348f, -0.658961296f, -0.657806695f, -0.656650543f, -0.655492842f, -0.654333591f, -0.653172851f, -0.652010560f, -0.650846660f, -0.649681330f, -0.648514390f, -0.647345960f, -0.646176040f, -0.645004511f, -0.643831551f, -0.642657042f, -0.641481042f, -0.640303493f, -0.639124453f, -0.637943923f, -0.636761844f, -0.635578334f, -0.634393275f, -0.633206785f, -0.632018745f, -0.630829215f, -0.629638255f, -0.628445745f, -0.627251804f, -0.626056373f, -0.624859512f, -0.623661101f, -0.622461259f, -0.621259987f, -0.620057225f, -0.618852973f, -0.617647290f, -0.616440177f, -0.615231574f, -0.614021540f, -0.612810075f, -0.611597180f, -0.610382795f, -0.609167039f, -0.607949793f, -0.606731117f, -0.605511069f, -0.604289532f, -0.603066623f, -0.601842225f, -0.600616455f, -0.599389315f, -0.598160684f, -0.596930683f, -0.595699310f, -0.594466507f, -0.593232274f, -0.591996670f, -0.590759695f, -0.589521289f, -0.588281572f, -0.587040365f, -0.585797846f, -0.584553957f, -0.583308637f, -0.582062006f, -0.580813944f, -0.579564571f, -0.578313768f, -0.577061653f, -0.575808167f, -0.574553370f, -0.573297143f, -0.572039604f, -0.570780754f, -0.569520533f, -0.568258941f, -0.566996038f, -0.565731823f, -0.564466238f, -0.563199341f, -0.561931133f, -0.560661554f, -0.559390724f, -0.558118522f, -0.556845009f, -0.555570245f, -0.554294109f, -0.553016722f, -0.551737964f, -0.550457954f, -0.549176633f, -0.547894061f, -0.546610177f, -0.545324981f, -0.544038534f, -0.542750776f, -0.541461766f, -0.540171444f, -0.538879931f, -0.537587047f, -0.536292970f, -0.534997642f, -0.533701003f, -0.532403111f, -0.531104028f, -0.529803634f, -0.528501987f, -0.527199149f, -0.525895000f, -0.524589658f, -0.523283124f, -0.521975279f, -0.520666242f, -0.519356012f, -0.518044531f, -0.516731799f, -0.515417874f, -0.514102757f, -0.512786388f, -0.511468828f, -0.510150075f, -0.508830130f, -0.507508993f, -0.506186664f, -0.504863083f, -0.503538370f, -0.502212465f, -0.500885367f, -0.499557108f, -0.498227656f, -0.496897042f, -0.495565265f, -0.494232297f, -0.492898196f, -0.491562903f, -0.490226477f, -0.488888890f, -0.487550169f, -0.486210287f, -0.484869242f, -0.483527064f, -0.482183784f, -0.480839342f, -0.479493767f, -0.478147060f, -0.476799220f, -0.475450277f, -0.474100202f, -0.472749025f, -0.471396744f, -0.470043331f, -0.468688816f, -0.467333198f, -0.465976506f, -0.464618683f, -0.463259786f, -0.461899787f, -0.460538715f, -0.459176540f, -0.457813293f, -0.456448972f, -0.455083579f, -0.453717113f, -0.452349573f, -0.450980991f, -0.449611336f, -0.448240608f, -0.446868837f, -0.445496023f, -0.444122136f, -0.442747235f, -0.441371262f, -0.439994276f, -0.438616246f, -0.437237173f, -0.435857087f, -0.434475958f, -0.433093816f, -0.431710660f, -0.430326492f, -0.428941280f, -0.427555084f, -0.426167876f, -0.424779683f, -0.423390478f, -0.422000259f, -0.420609087f, -0.419216901f, -0.417823702f, -0.416429549f, -0.415034413f, -0.413638324f, -0.412241220f, -0.410843164f, -0.409444153f, -0.408044159f, -0.406643212f, -0.405241311f, -0.403838456f, -0.402434647f, -0.401029885f, -0.399624199f, -0.398217559f, -0.396809995f, -0.395401478f, -0.393992037f, -0.392581671f, -0.391170382f, -0.389758170f, -0.388345033f, -0.386931002f, -0.385516047f, -0.384100199f, -0.382683426f, -0.381265759f, -0.379847199f, -0.378427744f, -0.377007425f, -0.375586182f, -0.374164075f, -0.372741073f, -0.371317208f, -0.369892448f, -0.368466824f, -0.367040336f, -0.365612984f, -0.364184797f, -0.362755716f, -0.361325800f, -0.359895051f, -0.358463407f, -0.357030958f, -0.355597675f, -0.354163527f, -0.352728546f, -0.351292759f, -0.349856138f, -0.348418683f, -0.346980423f, -0.345541328f, -0.344101429f, -0.342660725f, -0.341219217f, -0.339776874f, -0.338333756f, -0.336889863f, -0.335445136f, -0.333999664f, -0.332553357f, -0.331106305f, -0.329658449f, -0.328209847f, -0.326760441f, -0.325310290f, -0.323859364f, -0.322407693f, -0.320955247f, -0.319502026f, -0.318048090f, -0.316593379f, -0.315137923f, -0.313681751f, -0.312224805f, -0.310767144f, -0.309308767f, -0.307849646f, -0.306389809f, -0.304929227f, -0.303467959f, -0.302005947f, -0.300543249f, -0.299079835f, -0.297615707f, -0.296150893f, -0.294685364f, -0.293219149f, -0.291752249f, -0.290284663f, -0.288816422f, -0.287347466f, -0.285877824f, -0.284407526f, -0.282936573f, -0.281464934f, -0.279992640f, -0.278519690f, -0.277046084f, -0.275571823f, -0.274096906f, -0.272621363f, -0.271145165f, -0.269668311f, -0.268190861f, -0.266712755f, -0.265234023f, -0.263754666f, -0.262274712f, -0.260794103f, -0.259312928f, -0.257831097f, -0.256348670f, -0.254865646f, -0.253382027f, -0.251897812f, -0.250413001f, -0.248927608f, -0.247441620f, -0.245955050f, -0.244467899f, -0.242980182f, -0.241491884f, -0.240003020f, -0.238513589f, -0.237023607f, -0.235533059f, -0.234041959f, -0.232550308f, -0.231058106f, -0.229565367f, -0.228072077f, -0.226578265f, -0.225083917f, -0.223589033f, -0.222093627f, -0.220597684f, -0.219101235f, -0.217604280f, -0.216106802f, -0.214608818f, -0.213110313f, -0.211611331f, -0.210111842f, -0.208611846f, -0.207111374f, -0.205610409f, -0.204108968f, -0.202607036f, -0.201104641f, -0.199601755f, -0.198098406f, -0.196594596f, -0.195090324f, -0.193585590f, -0.192080393f, -0.190574750f, -0.189068660f, -0.187562123f, -0.186055154f, -0.184547737f, -0.183039889f, -0.181531608f, -0.180022895f, -0.178513765f, -0.177004218f, -0.175494254f, -0.173983872f, -0.172473088f, -0.170961887f, -0.169450298f, -0.167938292f, -0.166425899f, -0.164913118f, -0.163399950f, -0.161886394f, -0.160372451f, -0.158858150f, -0.157343462f, -0.155828401f, -0.154312968f, -0.152797192f, -0.151281044f, -0.149764538f, -0.148247674f, -0.146730468f, -0.145212919f, -0.143695027f, -0.142176807f, -0.140658244f, -0.139139339f, -0.137620121f, -0.136100575f, -0.134580702f, -0.133060530f, -0.131540030f, -0.130019218f, -0.128498107f, -0.126976699f, -0.125454977f, -0.123932973f, -0.122410677f, -0.120888084f, -0.119365215f, -0.117842063f, -0.116318628f, -0.114794925f, -0.113270953f, -0.111746714f, -0.110222206f, -0.108697444f, -0.107172422f, -0.105647154f, -0.104121633f, -0.102595866f, -0.101069860f, -0.099543616f, -0.098017141f, -0.096490428f, -0.094963498f, -0.093436338f, -0.091908954f, -0.090381362f, -0.088853553f, -0.087325536f, -0.085797310f, -0.084268890f, -0.082740262f, -0.081211448f, -0.079682440f, -0.078153245f, -0.076623864f, -0.075094298f, -0.073564567f, -0.072034650f, -0.070504576f, -0.068974331f, -0.067443922f, -0.065913349f, -0.064382628f, -0.062851757f, -0.061320737f, -0.059789572f, -0.058258265f, -0.056726821f, -0.055195246f, -0.053663537f, -0.052131705f, -0.050599750f, -0.049067676f, -0.047535483f, -0.046003181f, -0.044470772f, -0.042938258f, -0.041405641f, -0.039872926f, -0.038340122f, -0.036807224f, -0.035274237f, -0.033741172f, -0.032208025f, -0.030674804f, -0.029141508f, -0.027608145f, -0.026074719f, -0.024541229f, -0.023007682f, -0.021474080f, -0.019940428f, -0.018406730f, -0.016872987f, -0.015339206f, -0.0138053885f, -0.012271538f, -0.010737659f, -0.009203754f, -0.007669829f, -0.0061358847f, -0.004601926f, -0.0030679568f, -0.0015339801f, 0.000000000f, 0.0015339801f, 0.0030679568f, 0.004601926f, 0.0061358847f, 0.007669829f, 0.009203754f, 0.010737659f, 0.012271538f, 0.0138053885f, 0.015339206f, 0.016872987f, 0.018406730f, 0.019940428f, 0.021474080f, 0.023007682f, 0.024541229f, 0.026074719f, 0.027608145f, 0.029141508f, 0.030674804f, 0.032208025f, 0.033741172f, 0.035274237f, 0.036807224f, 0.038340122f, 0.039872926f, 0.041405641f, 0.042938258f, 0.044470772f, 0.046003181f, 0.047535483f, 0.049067676f, 0.050599750f, 0.052131705f, 0.053663537f, 0.055195246f, 0.056726821f, 0.058258265f, 0.059789572f, 0.061320737f, 0.062851757f, 0.064382628f, 0.065913349f, 0.067443922f, 0.068974331f, 0.070504576f, 0.072034650f, 0.073564567f, 0.075094298f, 0.076623864f, 0.078153245f, 0.079682440f, 0.081211448f, 0.082740262f, 0.084268890f, 0.085797310f, 0.087325536f, 0.088853553f, 0.090381362f, 0.091908954f, 0.093436338f, 0.094963498f, 0.096490428f, 0.098017141f, 0.099543616f, 0.101069860f, 0.102595866f, 0.104121633f, 0.105647154f, 0.107172422f, 0.108697444f, 0.110222206f, 0.111746714f, 0.113270953f, 0.114794925f, 0.116318628f, 0.117842063f, 0.119365215f, 0.120888084f, 0.122410677f, 0.123932973f, 0.125454977f, 0.126976699f, 0.128498107f, 0.130019218f, 0.131540030f, 0.133060530f, 0.134580702f, 0.136100575f, 0.137620121f, 0.139139339f, 0.140658244f, 0.142176807f, 0.143695027f, 0.145212919f, 0.146730468f, 0.148247674f, 0.149764538f, 0.151281044f, 0.152797192f, 0.154312968f, 0.155828401f, 0.157343462f, 0.158858150f, 0.160372451f, 0.161886394f, 0.163399950f, 0.164913118f, 0.166425899f, 0.167938292f, 0.169450298f, 0.170961887f, 0.172473088f, 0.173983872f, 0.175494254f, 0.177004218f, 0.178513765f, 0.180022895f, 0.181531608f, 0.183039889f, 0.184547737f, 0.186055154f, 0.187562123f, 0.189068660f, 0.190574750f, 0.192080393f, 0.193585590f, 0.195090324f, 0.196594596f, 0.198098406f, 0.199601755f, 0.201104641f, 0.202607036f, 0.204108968f, 0.205610409f, 0.207111374f, 0.208611846f, 0.210111842f, 0.211611331f, 0.213110313f, 0.214608818f, 0.216106802f, 0.217604280f, 0.219101235f, 0.220597684f, 0.222093627f, 0.223589033f, 0.225083917f, 0.226578265f, 0.228072077f, 0.229565367f, 0.231058106f, 0.232550308f, 0.234041959f, 0.235533059f, 0.237023607f, 0.238513589f, 0.240003020f, 0.241491884f, 0.242980182f, 0.244467899f, 0.245955050f, 0.247441620f, 0.248927608f, 0.250413001f, 0.251897812f, 0.253382027f, 0.254865646f, 0.256348670f, 0.257831097f, 0.259312928f, 0.260794103f, 0.262274712f, 0.263754666f, 0.265234023f, 0.266712755f, 0.268190861f, 0.269668311f, 0.271145165f, 0.272621363f, 0.274096906f, 0.275571823f, 0.277046084f, 0.278519690f, 0.279992640f, 0.281464934f, 0.282936573f, 0.284407526f, 0.285877824f, 0.287347466f, 0.288816422f, 0.290284663f, 0.291752249f, 0.293219149f, 0.294685364f, 0.296150893f, 0.297615707f, 0.299079835f, 0.300543249f, 0.302005947f, 0.303467959f, 0.304929227f, 0.306389809f, 0.307849646f, 0.309308767f, 0.310767144f, 0.312224805f, 0.313681751f, 0.315137923f, 0.316593379f, 0.318048090f, 0.319502026f, 0.320955247f, 0.322407693f, 0.323859364f, 0.325310290f, 0.326760441f, 0.328209847f, 0.329658449f, 0.331106305f, 0.332553357f, 0.333999664f, 0.335445136f, 0.336889863f, 0.338333756f, 0.339776874f, 0.341219217f, 0.342660725f, 0.344101429f, 0.345541328f, 0.346980423f, 0.348418683f, 0.349856138f, 0.351292759f, 0.352728546f, 0.354163527f, 0.355597675f, 0.357030958f, 0.358463407f, 0.359895051f, 0.361325800f, 0.362755716f, 0.364184797f, 0.365612984f, 0.367040336f, 0.368466824f, 0.369892448f, 0.371317208f, 0.372741073f, 0.374164075f, 0.375586182f, 0.377007425f, 0.378427744f, 0.379847199f, 0.381265759f, 0.382683426f, 0.384100199f, 0.385516047f, 0.386931002f, 0.388345033f, 0.389758170f, 0.391170382f, 0.392581671f, 0.393992037f, 0.395401478f, 0.396809995f, 0.398217559f, 0.399624199f, 0.401029885f, 0.402434647f, 0.403838456f, 0.405241311f, 0.406643212f, 0.408044159f, 0.409444153f, 0.410843164f, 0.412241220f, 0.413638324f, 0.415034413f, 0.416429549f, 0.417823702f, 0.419216901f, 0.420609087f, 0.422000259f, 0.423390478f, 0.424779683f, 0.426167876f, 0.427555084f, 0.428941280f, 0.430326492f, 0.431710660f, 0.433093816f, 0.434475958f, 0.435857087f, 0.437237173f, 0.438616246f, 0.439994276f, 0.441371262f, 0.442747235f, 0.444122136f, 0.445496023f, 0.446868837f, 0.448240608f, 0.449611336f, 0.450980991f, 0.452349573f, 0.453717113f, 0.455083579f, 0.456448972f, 0.457813293f, 0.459176540f, 0.460538715f, 0.461899787f, 0.463259786f, 0.464618683f, 0.465976506f, 0.467333198f, 0.468688816f, 0.470043331f, 0.471396744f, 0.472749025f, 0.474100202f, 0.475450277f, 0.476799220f, 0.478147060f, 0.479493767f, 0.480839342f, 0.482183784f, 0.483527064f, 0.484869242f, 0.486210287f, 0.487550169f, 0.488888890f, 0.490226477f, 0.491562903f, 0.492898196f, 0.494232297f, 0.495565265f, 0.496897042f, 0.498227656f, 0.499557108f, 0.500885367f, 0.502212465f, 0.503538370f, 0.504863083f, 0.506186664f, 0.507508993f, 0.508830130f, 0.510150075f, 0.511468828f, 0.512786388f, 0.514102757f, 0.515417874f, 0.516731799f, 0.518044531f, 0.519356012f, 0.520666242f, 0.521975279f, 0.523283124f, 0.524589658f, 0.525895000f, 0.527199149f, 0.528501987f, 0.529803634f, 0.531104028f, 0.532403111f, 0.533701003f, 0.534997642f, 0.536292970f, 0.537587047f, 0.538879931f, 0.540171444f, 0.541461766f, 0.542750776f, 0.544038534f, 0.545324981f, 0.546610177f, 0.547894061f, 0.549176633f, 0.550457954f, 0.551737964f, 0.553016722f, 0.554294109f, 0.555570245f, 0.556845009f, 0.558118522f, 0.559390724f, 0.560661554f, 0.561931133f, 0.563199341f, 0.564466238f, 0.565731823f, 0.566996038f, 0.568258941f, 0.569520533f, 0.570780754f, 0.572039604f, 0.573297143f, 0.574553370f, 0.575808167f, 0.577061653f, 0.578313768f, 0.579564571f, 0.580813944f, 0.582062006f, 0.583308637f, 0.584553957f, 0.585797846f, 0.587040365f, 0.588281572f, 0.589521289f, 0.590759695f, 0.591996670f, 0.593232274f, 0.594466507f, 0.595699310f, 0.596930683f, 0.598160684f, 0.599389315f, 0.600616455f, 0.601842225f, 0.603066623f, 0.604289532f, 0.605511069f, 0.606731117f, 0.607949793f, 0.609167039f, 0.610382795f, 0.611597180f, 0.612810075f, 0.614021540f, 0.615231574f, 0.616440177f, 0.617647290f, 0.618852973f, 0.620057225f, 0.621259987f, 0.622461259f, 0.623661101f, 0.624859512f, 0.626056373f, 0.627251804f, 0.628445745f, 0.629638255f, 0.630829215f, 0.632018745f, 0.633206785f, 0.634393275f, 0.635578334f, 0.636761844f, 0.637943923f, 0.639124453f, 0.640303493f, 0.641481042f, 0.642657042f, 0.643831551f, 0.645004511f, 0.646176040f, 0.647345960f, 0.648514390f, 0.649681330f, 0.650846660f, 0.652010560f, 0.653172851f, 0.654333591f, 0.655492842f, 0.656650543f, 0.657806695f, 0.658961296f, 0.660114348f, 0.661265850f, 0.662415802f, 0.663564146f, 0.664710999f, 0.665856242f, 0.666999936f, 0.668142021f, 0.669282615f, 0.670421541f, 0.671558976f, 0.672694743f, 0.673829019f, 0.674961627f, 0.676092684f, 0.677222192f, 0.678350031f, 0.679476321f, 0.680601001f, 0.681724072f, 0.682845533f, 0.683965385f, 0.685083687f, 0.686200321f, 0.687315345f, 0.688428760f, 0.689540565f, 0.690650702f, 0.691759229f, 0.692866147f, 0.693971455f, 0.695075095f, 0.696177125f, 0.697277486f, 0.698376238f, 0.699473321f, 0.700568795f, 0.701662600f, 0.702754736f, 0.703845263f, 0.704934061f, 0.706021249f, 0.707106769f, 0.708190620f, 0.709272802f, 0.710353374f, 0.711432219f, 0.712509394f, 0.713584840f, 0.714658678f, 0.715730846f, 0.716801286f, 0.717870057f, 0.718937099f, 0.720002532f, 0.721066177f, 0.722128212f, 0.723188460f, 0.724247098f, 0.725303948f, 0.726359129f, 0.727412641f, 0.728464365f, 0.729514420f, 0.730562747f, 0.731609404f, 0.732654274f, 0.733697414f, 0.734738886f, 0.735778570f, 0.736816585f, 0.737852812f, 0.738887310f, 0.739920080f, 0.740951121f, 0.741980433f, 0.743007958f, 0.744033754f, 0.745057762f, 0.746080101f, 0.747100592f, 0.748119354f, 0.749136388f, 0.750151634f, 0.751165152f, 0.752176821f, 0.753186822f, 0.754194975f, 0.755201399f, 0.756205976f, 0.757208824f, 0.758209884f, 0.759209216f, 0.760206699f, 0.761202395f, 0.762196302f, 0.763188422f, 0.764178753f, 0.765167236f, 0.766153991f, 0.767138898f, 0.768122017f, 0.769103348f, 0.770082831f, 0.771060526f, 0.772036374f, 0.773010433f, 0.773982704f, 0.774953127f, 0.775921702f, 0.776888490f, 0.777853429f, 0.778816521f, 0.779777765f, 0.780737221f, 0.781694829f, 0.782650590f, 0.783604503f, 0.784556568f, 0.785506845f, 0.786455214f, 0.787401736f, 0.788346410f, 0.789289236f, 0.790230215f, 0.791169345f, 0.792106569f, 0.793041945f, 0.793975472f, 0.794907153f, 0.795836926f, 0.796764791f, 0.797690868f, 0.798614979f, 0.799537241f, 0.800457656f, 0.801376164f, 0.802292824f, 0.803207517f, 0.804120362f, 0.805031359f, 0.805940390f, 0.806847572f, 0.807752848f, 0.808656156f, 0.809557617f, 0.810457170f, 0.811354876f, 0.812250614f, 0.813144386f, 0.814036310f, 0.814926326f, 0.815814435f, 0.816700578f, 0.817584813f, 0.818467140f, 0.819347501f, 0.820225954f, 0.821102500f, 0.821977139f, 0.822849810f, 0.823720515f, 0.824589312f, 0.825456142f, 0.826321065f, 0.827184021f, 0.828045070f, 0.828904092f, 0.829761207f, 0.830616415f, 0.831469595f, 0.832320869f, 0.833170176f, 0.834017515f, 0.834862888f, 0.835706294f, 0.836547732f, 0.837387204f, 0.838224709f, 0.839060247f, 0.839893818f, 0.840725362f, 0.841554999f, 0.842382610f, 0.843208253f, 0.844031870f, 0.844853580f, 0.845673263f, 0.846490920f, 0.847306609f, 0.848120332f, 0.848932028f, 0.849741757f, 0.850549459f, 0.851355195f, 0.852158904f, 0.852960587f, 0.853760302f, 0.854557991f, 0.855353653f, 0.856147349f, 0.856938958f, 0.857728601f, 0.858516216f, 0.859301805f, 0.860085368f, 0.860866964f, 0.861646473f, 0.862423956f, 0.863199413f, 0.863972843f, 0.864744246f, 0.865513623f, 0.866280973f, 0.867046237f, 0.867809474f, 0.868570685f, 0.869329870f, 0.870086968f, 0.870842040f, 0.871595085f, 0.872346044f, 0.873094976f, 0.873841822f, 0.874586642f, 0.875329375f, 0.876070082f, 0.876808703f, 0.877545297f, 0.878279805f, 0.879012227f, 0.879742622f, 0.880470872f, 0.881197095f, 0.881921291f, 0.882643342f, 0.883363366f, 0.884081244f, 0.884797096f, 0.885510862f, 0.886222541f, 0.886932135f, 0.887639642f, 0.888345063f, 0.889048338f, 0.889749587f, 0.890448749f, 0.891145766f, 0.891840696f, 0.892533541f, 0.893224299f, 0.893912971f, 0.894599497f, 0.895283937f, 0.895966232f, 0.896646500f, 0.897324562f, 0.898000598f, 0.898674488f, 0.899346232f, 0.900015891f, 0.900683403f, 0.901348829f, 0.902012169f, 0.902673304f, 0.903332353f, 0.903989315f, 0.904644072f, 0.905296743f, 0.905947268f, 0.906595707f, 0.907242000f, 0.907886088f, 0.908528090f, 0.909168005f, 0.909805715f, 0.910441279f, 0.911074758f, 0.911706030f, 0.912335157f, 0.912962198f, 0.913587034f, 0.914209783f, 0.914830327f, 0.915448725f, 0.916064978f, 0.916679084f, 0.917290986f, 0.917900801f, 0.918508410f, 0.919113874f, 0.919717133f, 0.920318305f, 0.920917213f, 0.921514034f, 0.922108650f, 0.922701120f, 0.923291445f, 0.923879504f, 0.924465477f, 0.925049245f, 0.925630808f, 0.926210225f, 0.926787496f, 0.927362502f, 0.927935421f, 0.928506076f, 0.929074585f, 0.929640889f, 0.930205047f, 0.930766940f, 0.931326687f, 0.931884289f, 0.932439625f, 0.932992816f, 0.933543801f, 0.934092522f, 0.934639156f, 0.935183525f, 0.935725689f, 0.936265647f, 0.936803460f, 0.937339008f, 0.937872350f, 0.938403547f, 0.938932478f, 0.939459205f, 0.939983726f, 0.940506041f, 0.941026151f, 0.941544056f, 0.942059755f, 0.942573190f, 0.943084419f, 0.943593442f, 0.944100261f, 0.944604814f, 0.945107222f, 0.945607305f, 0.946105242f, 0.946600914f, 0.947094381f, 0.947585583f, 0.948074579f, 0.948561370f, 0.949045897f, 0.949528158f, 0.950008273f, 0.950486064f, 0.950961649f, 0.951435030f, 0.951906145f, 0.952374995f, 0.952841640f, 0.953306019f, 0.953768194f, 0.954228103f, 0.954685748f, 0.955141187f, 0.955594361f, 0.956045270f, 0.956493914f, 0.956940353f, 0.957384527f, 0.957826436f, 0.958266079f, 0.958703458f, 0.959138632f, 0.959571540f, 0.960002124f, 0.960430503f, 0.960856616f, 0.961280465f, 0.961702049f, 0.962121427f, 0.962538481f, 0.962953269f, 0.963365793f, 0.963776052f, 0.964184046f, 0.964589775f, 0.964993238f, 0.965394437f, 0.965793371f, 0.966189981f, 0.966584384f, 0.966976464f, 0.967366278f, 0.967753828f, 0.968139112f, 0.968522072f, 0.968902826f, 0.969281256f, 0.969657362f, 0.970031261f, 0.970402837f, 0.970772147f, 0.971139133f, 0.971503913f, 0.971866310f, 0.972226501f, 0.972584367f, 0.972939968f, 0.973293245f, 0.973644257f, 0.973992944f, 0.974339366f, 0.974683523f, 0.975025356f, 0.975364864f, 0.975702107f, 0.976037085f, 0.976369739f, 0.976700068f, 0.977028131f, 0.977353871f, 0.977677345f, 0.977998495f, 0.978317380f, 0.978633940f, 0.978948176f, 0.979260147f, 0.979569793f, 0.979877114f, 0.980182111f, 0.980484843f, 0.980785251f, 0.981083393f, 0.981379211f, 0.981672704f, 0.981963873f, 0.982252717f, 0.982539296f, 0.982823551f, 0.983105481f, 0.983385086f, 0.983662426f, 0.983937442f, 0.984210074f, 0.984480441f, 0.984748483f, 0.985014260f, 0.985277653f, 0.985538721f, 0.985797524f, 0.986053944f, 0.986308098f, 0.986559927f, 0.986809373f, 0.987056553f, 0.987301409f, 0.987543941f, 0.987784147f, 0.988022029f, 0.988257587f, 0.988490820f, 0.988721669f, 0.988950253f, 0.989176512f, 0.989400446f, 0.989621997f, 0.989841282f, 0.990058184f, 0.990272820f, 0.990485072f, 0.990695000f, 0.990902662f, 0.991107941f, 0.991310835f, 0.991511464f, 0.991709769f, 0.991905689f, 0.992099285f, 0.992290616f, 0.992479563f, 0.992666125f, 0.992850423f, 0.993032336f, 0.993211925f, 0.993389189f, 0.993564129f, 0.993736744f, 0.993906975f, 0.994074881f, 0.994240463f, 0.994403660f, 0.994564593f, 0.994723141f, 0.994879305f, 0.995033205f, 0.995184720f, 0.995333910f, 0.995480776f, 0.995625257f, 0.995767415f, 0.995907247f, 0.996044695f, 0.996179819f, 0.996312618f, 0.996443033f, 0.996571124f, 0.996696889f, 0.996820271f, 0.996941328f, 0.997060061f, 0.997176409f, 0.997290432f, 0.997402132f, 0.997511446f, 0.997618437f, 0.997723043f, 0.997825325f, 0.997925282f, 0.998022854f, 0.998118103f, 0.998211026f, 0.998301566f, 0.998389721f, 0.998475552f, 0.998559058f, 0.998640239f, 0.998719037f, 0.998795450f, 0.998869538f, 0.998941302f, 0.999010682f, 0.999077737f, 0.999142408f, 0.999204755f, 0.999264777f, 0.999322355f, 0.999377668f, 0.999430597f, 0.999481201f, 0.999529421f, 0.999575317f, 0.999618828f, 0.999660015f, 0.999698818f, 0.999735296f, 0.999769390f, 0.999801159f, 0.999830604f, 0.999857664f, 0.999882340f, 0.999904692f, 0.999924719f, 0.999942362f, 0.999957621f, 0.999970615f, 0.999981165f, 0.999989390f, 0.999995291f, 0.999998808f };
__device__ int gArctanTableG[8192] = { 0x0000, 0x000A, 0x0014, 0x001F, 0x0029, 0x0033, 0x003D, 0x0047, 0x0051, 0x005C, 0x0066, 0x0070, 0x007A, 0x0084, 0x008F, 0x0099, 0x00A3, 0x00AD, 0x00B7, 0x00C2, 0x00CC, 0x00D6, 0x00E0, 0x00EA, 0x00F4, 0x00FF, 0x0109, 0x0113, 0x011D, 0x0127, 0x0131, 0x013C, 0x0146, 0x0150, 0x015A, 0x0164, 0x016F, 0x0179, 0x0183, 0x018D, 0x0197, 0x01A1, 0x01AC, 0x01B6, 0x01C0, 0x01CA, 0x01D4, 0x01DE, 0x01E9, 0x01F3, 0x01FD, 0x0207, 0x0211, 0x021B, 0x0226, 0x0230, 0x023A, 0x0244, 0x024E, 0x0258, 0x0262, 0x026D, 0x0277, 0x0281, 0x028B, 0x0295, 0x029F, 0x02A9, 0x02B4, 0x02BE, 0x02C8, 0x02D2, 0x02DC, 0x02E6, 0x02F0, 0x02FB, 0x0305, 0x030F, 0x0319, 0x0323, 0x032D, 0x0337, 0x0341, 0x034C, 0x0356, 0x0360, 0x036A, 0x0374, 0x037E, 0x0388, 0x0392, 0x039C, 0x03A7, 0x03B1, 0x03BB, 0x03C5, 0x03CF, 0x03D9, 0x03E3, 0x03ED, 0x03F7, 0x0401, 0x040C, 0x0416, 0x0420, 0x042A, 0x0434, 0x043E, 0x0448, 0x0452, 0x045C, 0x0466, 0x0470, 0x047A, 0x0484, 0x048E, 0x0499, 0x04A3, 0x04AD, 0x04B7, 0x04C1, 0x04CB, 0x04D5, 0x04DF, 0x04E9, 0x04F3, 0x04FD, 0x0507, 0x0511, 0x051B, 0x0525, 0x052F, 0x0539, 0x0543, 0x054D, 0x0557, 0x0561, 0x056B, 0x0575, 0x057F, 0x0589, 0x0593, 0x059D, 0x05A7, 0x05B1, 0x05BB, 0x05C5, 0x05CF, 0x05D9, 0x05E3, 0x05ED, 0x05F7, 0x0601, 0x060B, 0x0615, 0x061F, 0x0629, 0x0633, 0x063D, 0x0647, 0x0651, 0x065B, 0x0665, 0x066E, 0x0678, 0x0682, 0x068C, 0x0696, 0x06A0, 0x06AA, 0x06B4, 0x06BE, 0x06C8, 0x06D2, 0x06DC, 0x06E5, 0x06EF, 0x06F9, 0x0703, 0x070D, 0x0717, 0x0721, 0x072B, 0x0735, 0x073E, 0x0748, 0x0752, 0x075C, 0x0766, 0x0770, 0x077A, 0x0783, 0x078D, 0x0797, 0x07A1, 0x07AB, 0x07B5, 0x07BE, 0x07C8, 0x07D2, 0x07DC, 0x07E6, 0x07EF, 0x07F9, 0x0803, 0x080D, 0x0817, 0x0820, 0x082A, 0x0834, 0x083E, 0x0848, 0x0851, 0x085B, 0x0865, 0x086F, 0x0878, 0x0882, 0x088C, 0x0896, 0x089F, 0x08A9, 0x08B3, 0x08BD, 0x08C6, 0x08D0, 0x08DA, 0x08E3, 0x08ED, 0x08F7, 0x0901, 0x090A, 0x0914, 0x091E, 0x0927, 0x0931, 0x093B, 0x0944, 0x094E, 0x0958, 0x0961, 0x096B, 0x0975, 0x097E, 0x0988, 0x0992, 0x099B, 0x09A5, 0x09AE, 0x09B8, 0x09C2, 0x09CB, 0x09D5, 0x09DE, 0x09E8, 0x09F2, 0x09FB, 0x0A05, 0x0A0E, 0x0A18, 0x0A22, 0x0A2B, 0x0A35, 0x0A3E, 0x0A48, 0x0A51, 0x0A5B, 0x0A64, 0x0A6E, 0x0A77, 0x0A81, 0x0A8B, 0x0A94, 0x0A9E, 0x0AA7, 0x0AB1, 0x0ABA, 0x0AC4, 0x0ACD, 0x0AD7, 0x0AE0, 0x0AE9, 0x0AF3, 0x0AFC, 0x0B06, 0x0B0F, 0x0B19, 0x0B22, 0x0B2C, 0x0B35, 0x0B3F, 0x0B48, 0x0B51, 0x0B5B, 0x0B64, 0x0B6E, 0x0B77, 0x0B80, 0x0B8A, 0x0B93, 0x0B9D, 0x0BA6, 0x0BAF, 0x0BB9, 0x0BC2, 0x0BCB, 0x0BD5, 0x0BDE, 0x0BE7, 0x0BF1, 0x0BFA, 0x0C03, 0x0C0D, 0x0C16, 0x0C1F, 0x0C29, 0x0C32, 0x0C3B, 0x0C45, 0x0C4E, 0x0C57, 0x0C60, 0x0C6A, 0x0C73, 0x0C7C, 0x0C86, 0x0C8F, 0x0C98, 0x0CA1, 0x0CAB, 0x0CB4, 0x0CBD, 0x0CC6, 0x0CCF, 0x0CD9, 0x0CE2, 0x0CEB, 0x0CF4, 0x0CFD, 0x0D07, 0x0D10, 0x0D19, 0x0D22, 0x0D2B, 0x0D34, 0x0D3E, 0x0D47, 0x0D50, 0x0D59, 0x0D62, 0x0D6B, 0x0D74, 0x0D7D, 0x0D87, 0x0D90, 0x0D99, 0x0DA2, 0x0DAB, 0x0DB4, 0x0DBD, 0x0DC6, 0x0DCF, 0x0DD8, 0x0DE1, 0x0DEA, 0x0DF3, 0x0DFC, 0x0E05, 0x0E0F, 0x0E18, 0x0E21, 0x0E2A, 0x0E33, 0x0E3C, 0x0E45, 0x0E4E, 0x0E56, 0x0E5F, 0x0E68, 0x0E71, 0x0E7A, 0x0E83, 0x0E8C, 0x0E95, 0x0E9E, 0x0EA7, 0x0EB0, 0x0EB9, 0x0EC2, 0x0ECB, 0x0ED4, 0x0EDC, 0x0EE5, 0x0EEE, 0x0EF7, 0x0F00, 0x0F09, 0x0F12, 0x0F1B, 0x0F23, 0x0F2C, 0x0F35, 0x0F3E, 0x0F47, 0x0F50, 0x0F58, 0x0F61, 0x0F6A, 0x0F73, 0x0F7C, 0x0F84, 0x0F8D, 0x0F96, 0x0F9F, 0x0FA7, 0x0FB0, 0x0FB9, 0x0FC2, 0x0FCA, 0x0FD3, 0x0FDC, 0x0FE5, 0x0FED, 0x0FF6, 0x0FFF, 0x1007, 0x1010, 0x1019, 0x1021, 0x102A, 0x1033, 0x103B, 0x1044, 0x104D, 0x1055, 0x105E, 0x1067, 0x106F, 0x1078, 0x1080, 0x1089, 0x1092, 0x109A, 0x10A3, 0x10AB, 0x10B4, 0x10BC, 0x10C5, 0x10CE, 0x10D6, 0x10DF, 0x10E7, 0x10F0, 0x10F8, 0x1101, 0x1109, 0x1112, 0x111A, 0x1123, 0x112B, 0x1134, 0x113C, 0x1145, 0x114D, 0x1156, 0x115E, 0x1166, 0x116F, 0x1177, 0x1180, 0x1188, 0x1191, 0x1199, 0x11A1, 0x11AA, 0x11B2, 0x11BB, 0x11C3, 0x11CB, 0x11D4, 0x11DC, 0x11E4, 0x11ED, 0x11F5, 0x11FD, 0x1206, 0x120E, 0x1216, 0x121F, 0x1227, 0x122F, 0x1237, 0x1240, 0x1248, 0x1250, 0x1259, 0x1261, 0x1269, 0x1271, 0x127A, 0x1282, 0x128A, 0x1292, 0x129A, 0x12A3, 0x12AB, 0x12B3, 0x12BB, 0x12C3, 0x12CC, 0x12D4, 0x12DC, 0x12E4, 0x12EC, 0x12F4, 0x12FC, 0x1305, 0x130D, 0x1315, 0x131D, 0x1325, 0x132D, 0x1335, 0x133D, 0x1345, 0x134D, 0x1355, 0x135E, 0x1366, 0x136E, 0x1376, 0x137E, 0x1386, 0x138E, 0x1396, 0x139E, 0x13A6, 0x13AE, 0x13B6, 0x13BE, 0x13C6, 0x13CE, 0x13D6, 0x13DE, 0x13E6, 0x13ED, 0x13F5, 0x13FD, 0x1405, 0x140D, 0x1415, 0x141D, 0x1425, 0x142D, 0x1435, 0x143D, 0x1444, 0x144C, 0x1454, 0x145C, 0x1464, 0x146C, 0x1473, 0x147B, 0x1483, 0x148B, 0x1493, 0x149B, 0x14A2, 0x14AA, 0x14B2, 0x14BA, 0x14C1, 0x14C9, 0x14D1, 0x14D9, 0x14E0, 0x14E8, 0x14F0, 0x14F8, 0x14FF, 0x1507, 0x150F, 0x1516, 0x151E, 0x1526, 0x152D, 0x1535, 0x153D, 0x1544, 0x154C, 0x1554, 0x155B, 0x1563, 0x156B, 0x1572, 0x157A, 0x1581, 0x1589, 0x1591, 0x1598, 0x15A0, 0x15A7, 0x15AF, 0x15B7, 0x15BE, 0x15C6, 0x15CD, 0x15D5, 0x15DC, 0x15E4, 0x15EB, 0x15F3, 0x15FA, 0x1602, 0x1609, 0x1611, 0x1618, 0x1620, 0x1627, 0x162F, 0x1636, 0x163E, 0x1645, 0x164C, 0x1654, 0x165B, 0x1663, 0x166A, 0x1671, 0x1679, 0x1680, 0x1688, 0x168F, 0x1696, 0x169E, 0x16A5, 0x16AC, 0x16B4, 0x16BB, 0x16C2, 0x16CA, 0x16D1, 0x16D8, 0x16E0, 0x16E7, 0x16EE, 0x16F6, 0x16FD, 0x1704, 0x170B, 0x1713, 0x171A, 0x1721, 0x1728, 0x1730, 0x1737, 0x173E, 0x1745, 0x174C, 0x1754, 0x175B, 0x1762, 0x1769, 0x1770, 0x1778, 0x177F, 0x1786, 0x178D, 0x1794, 0x179B, 0x17A2, 0x17AA, 0x17B1, 0x17B8, 0x17BF, 0x17C6, 0x17CD, 0x17D4, 0x17DB, 0x17E2, 0x17E9, 0x17F0, 0x17F7, 0x17FE, 0x1806, 0x180D, 0x1814, 0x181B, 0x1822, 0x1829, 0x1830, 0x1837, 0x183E, 0x1845, 0x184C, 0x1853, 0x185A, 0x1860, 0x1867, 0x186E, 0x1875, 0x187C, 0x1883, 0x188A, 0x1891, 0x1898, 0x189F, 0x18A6, 0x18AD, 0x18B3, 0x18BA, 0x18C1, 0x18C8, 0x18CF, 0x18D6, 0x18DD, 0x18E3, 0x18EA, 0x18F1, 0x18F8, 0x18FF, 0x1906, 0x190C, 0x1913, 0x191A, 0x1921, 0x1928, 0x192E, 0x1935, 0x193C, 0x1943, 0x1949, 0x1950, 0x1957, 0x195D, 0x1964, 0x196B, 0x1972, 0x1978, 0x197F, 0x1986, 0x198C, 0x1993, 0x199A, 0x19A0, 0x19A7, 0x19AE, 0x19B4, 0x19BB, 0x19C2, 0x19C8, 0x19CF, 0x19D5, 0x19DC, 0x19E3, 0x19E9, 0x19F0, 0x19F6, 0x19FD, 0x1A04, 0x1A0A, 0x1A11, 0x1A17, 0x1A1E, 0x1A24, 0x1A2B, 0x1A31, 0x1A38, 0x1A3E, 0x1A45, 0x1A4B, 0x1A52, 0x1A58, 0x1A5F, 0x1A65, 0x1A6C, 0x1A72, 0x1A79, 0x1A7F, 0x1A86, 0x1A8C, 0x1A93, 0x1A99, 0x1A9F, 0x1AA6, 0x1AAC, 0x1AB3, 0x1AB9, 0x1AC0, 0x1AC6, 0x1ACC, 0x1AD3, 0x1AD9, 0x1ADF, 0x1AE6, 0x1AEC, 0x1AF2, 0x1AF9, 0x1AFF, 0x1B05, 0x1B0C, 0x1B12, 0x1B18, 0x1B1F, 0x1B25, 0x1B2B, 0x1B32, 0x1B38, 0x1B3E, 0x1B44, 0x1B4B, 0x1B51, 0x1B57, 0x1B5D, 0x1B64, 0x1B6A, 0x1B70, 0x1B76, 0x1B7D, 0x1B83, 0x1B89, 0x1B8F, 0x1B95, 0x1B9C, 0x1BA2, 0x1BA8, 0x1BAE, 0x1BB4, 0x1BBA, 0x1BC1, 0x1BC7, 0x1BCD, 0x1BD3, 0x1BD9, 0x1BDF, 0x1BE5, 0x1BEB, 0x1BF2, 0x1BF8, 0x1BFE, 0x1C04, 0x1C0A, 0x1C10, 0x1C16, 0x1C1C, 0x1C22, 0x1C28, 0x1C2E, 0x1C34, 0x1C3A, 0x1C40, 0x1C46, 0x1C4C, 0x1C52, 0x1C58, 0x1C5E, 0x1C64, 0x1C6A, 0x1C70, 0x1C76, 0x1C7C, 0x1C82, 0x1C88, 0x1C8E, 0x1C94, 0x1C9A, 0x1CA0, 0x1CA6, 0x1CAC, 0x1CB2, 0x1CB8, 0x1CBE, 0x1CC3, 0x1CC9, 0x1CCF, 0x1CD5, 0x1CDB, 0x1CE1, 0x1CE7, 0x1CED, 0x1CF3, 0x1CF8, 0x1CFE, 0x1D04, 0x1D0A, 0x1D10, 0x1D16, 0x1D1B, 0x1D21, 0x1D27, 0x1D2D, 0x1D33, 0x1D38, 0x1D3E, 0x1D44, 0x1D4A, 0x1D4F, 0x1D55, 0x1D5B, 0x1D61, 0x1D66, 0x1D6C, 0x1D72, 0x1D78, 0x1D7D, 0x1D83, 0x1D89, 0x1D8E, 0x1D94, 0x1D9A, 0x1DA0, 0x1DA5, 0x1DAB, 0x1DB1, 0x1DB6, 0x1DBC, 0x1DC2, 0x1DC7, 0x1DCD, 0x1DD3, 0x1DD8, 0x1DDE, 0x1DE3, 0x1DE9, 0x1DEF, 0x1DF4, 0x1DFA, 0x1DFF, 0x1E05, 0x1E0B, 0x1E10, 0x1E16, 0x1E1B, 0x1E21, 0x1E26, 0x1E2C, 0x1E32, 0x1E37, 0x1E3D, 0x1E42, 0x1E48, 0x1E4D, 0x1E53, 0x1E58, 0x1E5E, 0x1E63, 0x1E69, 0x1E6E, 0x1E74, 0x1E79, 0x1E7F, 0x1E84, 0x1E8A, 0x1E8F, 0x1E94, 0x1E9A, 0x1E9F, 0x1EA5, 0x1EAA, 0x1EB0, 0x1EB5, 0x1EBA, 0x1EC0, 0x1EC5, 0x1ECB, 0x1ED0, 0x1ED5, 0x1EDB, 0x1EE0, 0x1EE6, 0x1EEB, 0x1EF0, 0x1EF6, 0x1EFB, 0x1F00, 0x1F06, 0x1F0B, 0x1F10, 0x1F16, 0x1F1B, 0x1F20, 0x1F26, 0x1F2B, 0x1F30, 0x1F36, 0x1F3B, 0x1F40, 0x1F45, 0x1F4B, 0x1F50, 0x1F55, 0x1F5A, 0x1F60, 0x1F65, 0x1F6A, 0x1F6F, 0x1F75, 0x1F7A, 0x1F7F, 0x1F84, 0x1F8A, 0x1F8F, 0x1F94, 0x1F99, 0x1F9E, 0x1FA4, 0x1FA9, 0x1FAE, 0x1FB3, 0x1FB8, 0x1FBD, 0x1FC3, 0x1FC8, 0x1FCD, 0x1FD2, 0x1FD7, 0x1FDC, 0x1FE1, 0x1FE6, 0x1FEC, 0x1FF1, 0x1FF6, 0x1FFB, 0x2000, 0x2005, 0x200A, 0x200F, 0x2014, 0x201A, 0x201F, 0x2024, 0x2029, 0x202E, 0x2033, 0x2038, 0x203D, 0x2043, 0x2048, 0x204D, 0x2052, 0x2057, 0x205C, 0x2062, 0x2067, 0x206C, 0x2071, 0x2076, 0x207C, 0x2081, 0x2086, 0x208B, 0x2091, 0x2096, 0x209B, 0x20A0, 0x20A6, 0x20AB, 0x20B0, 0x20B5, 0x20BB, 0x20C0, 0x20C5, 0x20CA, 0x20D0, 0x20D5, 0x20DA, 0x20E0, 0x20E5, 0x20EA, 0x20F0, 0x20F5, 0x20FA, 0x2100, 0x2105, 0x210A, 0x2110, 0x2115, 0x211A, 0x2120, 0x2125, 0x212B, 0x2130, 0x2135, 0x213B, 0x2140, 0x2146, 0x214B, 0x2150, 0x2156, 0x215B, 0x2161, 0x2166, 0x216C, 0x2171, 0x2176, 0x217C, 0x2181, 0x2187, 0x218C, 0x2192, 0x2197, 0x219D, 0x21A2, 0x21A8, 0x21AD, 0x21B3, 0x21B8, 0x21BE, 0x21C3, 0x21C9, 0x21CE, 0x21D4, 0x21DA, 0x21DF, 0x21E5, 0x21EA, 0x21F0, 0x21F5, 0x21FB, 0x2201, 0x2206, 0x220C, 0x2211, 0x2217, 0x221D, 0x2222, 0x2228, 0x222D, 0x2233, 0x2239, 0x223E, 0x2244, 0x224A, 0x224F, 0x2255, 0x225B, 0x2260, 0x2266, 0x226C, 0x2272, 0x2277, 0x227D, 0x2283, 0x2288, 0x228E, 0x2294, 0x229A, 0x229F, 0x22A5, 0x22AB, 0x22B1, 0x22B6, 0x22BC, 0x22C2, 0x22C8, 0x22CD, 0x22D3, 0x22D9, 0x22DF, 0x22E5, 0x22EA, 0x22F0, 0x22F6, 0x22FC, 0x2302, 0x2308, 0x230D, 0x2313, 0x2319, 0x231F, 0x2325, 0x232B, 0x2331, 0x2337, 0x233D, 0x2342, 0x2348, 0x234E, 0x2354, 0x235A, 0x2360, 0x2366, 0x236C, 0x2372, 0x2378, 0x237E, 0x2384, 0x238A, 0x2390, 0x2396, 0x239C, 0x23A2, 0x23A8, 0x23AE, 0x23B4, 0x23BA, 0x23C0, 0x23C6, 0x23CC, 0x23D2, 0x23D8, 0x23DE, 0x23E4, 0x23EA, 0x23F0, 0x23F6, 0x23FC, 0x2402, 0x2408, 0x240E, 0x2415, 0x241B, 0x2421, 0x2427, 0x242D, 0x2433, 0x2439, 0x243F, 0x2446, 0x244C, 0x2452, 0x2458, 0x245E, 0x2464, 0x246B, 0x2471, 0x2477, 0x247D, 0x2483, 0x248A, 0x2490, 0x2496, 0x249C, 0x24A3, 0x24A9, 0x24AF, 0x24B5, 0x24BC, 0x24C2, 0x24C8, 0x24CE, 0x24D5, 0x24DB, 0x24E1, 0x24E8, 0x24EE, 0x24F4, 0x24FB, 0x2501, 0x2507, 0x250E, 0x2514, 0x251A, 0x2521, 0x2527, 0x252D, 0x2534, 0x253A, 0x2540, 0x2547, 0x254D, 0x2554, 0x255A, 0x2561, 0x2567, 0x256D, 0x2574, 0x257A, 0x2581, 0x2587, 0x258E, 0x2594, 0x259B, 0x25A1, 0x25A8, 0x25AE, 0x25B5, 0x25BB, 0x25C2, 0x25C8, 0x25CF, 0x25D5, 0x25DC, 0x25E2, 0x25E9, 0x25EF, 0x25F6, 0x25FC, 0x2603, 0x260A, 0x2610, 0x2617, 0x261D, 0x2624, 0x262B, 0x2631, 0x2638, 0x263E, 0x2645, 0x264C, 0x2652, 0x2659, 0x2660, 0x2666, 0x266D, 0x2674, 0x267A, 0x2681, 0x2688, 0x268E, 0x2695, 0x269C, 0x26A3, 0x26A9, 0x26B0, 0x26B7, 0x26BD, 0x26C4, 0x26CB, 0x26D2, 0x26D8, 0x26DF, 0x26E6, 0x26ED, 0x26F4, 0x26FA, 0x2701, 0x2708, 0x270F, 0x2716, 0x271D, 0x2723, 0x272A, 0x2731, 0x2738, 0x273F, 0x2746, 0x274D, 0x2753, 0x275A, 0x2761, 0x2768, 0x276F, 0x2776, 0x277D, 0x2784, 0x278B, 0x2792, 0x2799, 0x27A0, 0x27A6, 0x27AD, 0x27B4, 0x27BB, 0x27C2, 0x27C9, 0x27D0, 0x27D7, 0x27DE, 0x27E5, 0x27EC, 0x27F3, 0x27FA, 0x2802, 0x2809, 0x2810, 0x2817, 0x281E, 0x2825, 0x282C, 0x2833, 0x283A, 0x2841, 0x2848, 0x284F, 0x2856, 0x285E, 0x2865, 0x286C, 0x2873, 0x287A, 0x2881, 0x2888, 0x2890, 0x2897, 0x289E, 0x28A5, 0x28AC, 0x28B4, 0x28BB, 0x28C2, 0x28C9, 0x28D0, 0x28D8, 0x28DF, 0x28E6, 0x28ED, 0x28F5, 0x28FC, 0x2903, 0x290A, 0x2912, 0x2919, 0x2920, 0x2928, 0x292F, 0x2936, 0x293E, 0x2945, 0x294C, 0x2954, 0x295B, 0x2962, 0x296A, 0x2971, 0x2978, 0x2980, 0x2987, 0x298F, 0x2996, 0x299D, 0x29A5, 0x29AC, 0x29B4, 0x29BB, 0x29C2, 0x29CA, 0x29D1, 0x29D9, 0x29E0, 0x29E8, 0x29EF, 0x29F7, 0x29FE, 0x2A06, 0x2A0D, 0x2A15, 0x2A1C, 0x2A24, 0x2A2B, 0x2A33, 0x2A3A, 0x2A42, 0x2A49, 0x2A51, 0x2A59, 0x2A60, 0x2A68, 0x2A6F, 0x2A77, 0x2A7F, 0x2A86, 0x2A8E, 0x2A95, 0x2A9D, 0x2AA5, 0x2AAC, 0x2AB4, 0x2ABC, 0x2AC3, 0x2ACB, 0x2AD3, 0x2ADA, 0x2AE2, 0x2AEA, 0x2AF1, 0x2AF9, 0x2B01, 0x2B08, 0x2B10, 0x2B18, 0x2B20, 0x2B27, 0x2B2F, 0x2B37, 0x2B3F, 0x2B46, 0x2B4E, 0x2B56, 0x2B5E, 0x2B65, 0x2B6D, 0x2B75, 0x2B7D, 0x2B85, 0x2B8D, 0x2B94, 0x2B9C, 0x2BA4, 0x2BAC, 0x2BB4, 0x2BBC, 0x2BC3, 0x2BCB, 0x2BD3, 0x2BDB, 0x2BE3, 0x2BEB, 0x2BF3, 0x2BFB, 0x2C03, 0x2C0B, 0x2C13, 0x2C1A, 0x2C22, 0x2C2A, 0x2C32, 0x2C3A, 0x2C42, 0x2C4A, 0x2C52, 0x2C5A, 0x2C62, 0x2C6A, 0x2C72, 0x2C7A, 0x2C82, 0x2C8A, 0x2C92, 0x2C9A, 0x2CA2, 0x2CAB, 0x2CB3, 0x2CBB, 0x2CC3, 0x2CCB, 0x2CD3, 0x2CDB, 0x2CE3, 0x2CEB, 0x2CF3, 0x2CFB, 0x2D04, 0x2D0C, 0x2D14, 0x2D1C, 0x2D24, 0x2D2C, 0x2D34, 0x2D3D, 0x2D45, 0x2D4D, 0x2D55, 0x2D5D, 0x2D66, 0x2D6E, 0x2D76, 0x2D7E, 0x2D86, 0x2D8F, 0x2D97, 0x2D9F, 0x2DA7, 0x2DB0, 0x2DB8, 0x2DC0, 0x2DC9, 0x2DD1, 0x2DD9, 0x2DE1, 0x2DEA, 0x2DF2, 0x2DFA, 0x2E03, 0x2E0B, 0x2E13, 0x2E1C, 0x2E24, 0x2E2C, 0x2E35, 0x2E3D, 0x2E45, 0x2E4E, 0x2E56, 0x2E5F, 0x2E67, 0x2E6F, 0x2E78, 0x2E80, 0x2E89, 0x2E91, 0x2E9A, 0x2EA2, 0x2EAA, 0x2EB3, 0x2EBB, 0x2EC4, 0x2ECC, 0x2ED5, 0x2EDD, 0x2EE6, 0x2EEE, 0x2EF7, 0x2EFF, 0x2F08, 0x2F10, 0x2F19, 0x2F21, 0x2F2A, 0x2F32, 0x2F3B, 0x2F44, 0x2F4C, 0x2F55, 0x2F5D, 0x2F66, 0x2F6E, 0x2F77, 0x2F80, 0x2F88, 0x2F91, 0x2F99, 0x2FA2, 0x2FAB, 0x2FB3, 0x2FBC, 0x2FC5, 0x2FCD, 0x2FD6, 0x2FDF, 0x2FE7, 0x2FF0, 0x2FF9, 0x3001, 0x300A, 0x3013, 0x301B, 0x3024, 0x302D, 0x3036, 0x303E, 0x3047, 0x3050, 0x3059, 0x3061, 0x306A, 0x3073, 0x307C, 0x3084, 0x308D, 0x3096, 0x309F, 0x30A8, 0x30B0, 0x30B9, 0x30C2, 0x30CB, 0x30D4, 0x30DD, 0x30E5, 0x30EE, 0x30F7, 0x3100, 0x3109, 0x3112, 0x311B, 0x3124, 0x312C, 0x3135, 0x313E, 0x3147, 0x3150, 0x3159, 0x3162, 0x316B, 0x3174, 0x317D, 0x3186, 0x318F, 0x3198, 0x31A1, 0x31AA, 0x31B2, 0x31BB, 0x31C4, 0x31CD, 0x31D6, 0x31DF, 0x31E8, 0x31F1, 0x31FB, 0x3204, 0x320D, 0x3216, 0x321F, 0x3228, 0x3231, 0x323A, 0x3243, 0x324C, 0x3255, 0x325E, 0x3267, 0x3270, 0x3279, 0x3283, 0x328C, 0x3295, 0x329E, 0x32A7, 0x32B0, 0x32B9, 0x32C2, 0x32CC, 0x32D5, 0x32DE, 0x32E7, 0x32F0, 0x32F9, 0x3303, 0x330C, 0x3315, 0x331E, 0x3327, 0x3331, 0x333A, 0x3343, 0x334C, 0x3355, 0x335F, 0x3368, 0x3371, 0x337A, 0x3384, 0x338D, 0x3396, 0x33A0, 0x33A9, 0x33B2, 0x33BB, 0x33C5, 0x33CE, 0x33D7, 0x33E1, 0x33EA, 0x33F3, 0x33FD, 0x3406, 0x340F, 0x3419, 0x3422, 0x342B, 0x3435, 0x343E, 0x3447, 0x3451, 0x345A, 0x3463, 0x346D, 0x3476, 0x3480, 0x3489, 0x3492, 0x349C, 0x34A5, 0x34AF, 0x34B8, 0x34C1, 0x34CB, 0x34D4, 0x34DE, 0x34E7, 0x34F1, 0x34FA, 0x3504, 0x350D, 0x3517, 0x3520, 0x3529, 0x3533, 0x353C, 0x3546, 0x354F, 0x3559, 0x3562, 0x356C, 0x3575, 0x357F, 0x3589, 0x3592, 0x359C, 0x35A5, 0x35AF, 0x35B8, 0x35C2, 0x35CB, 0x35D5, 0x35DE, 0x35E8, 0x35F2, 0x35FB, 0x3605, 0x360E, 0x3618, 0x3622, 0x362B, 0x3635, 0x363E, 0x3648, 0x3652, 0x365B, 0x3665, 0x366E, 0x3678, 0x3682, 0x368B, 0x3695, 0x369F, 0x36A8, 0x36B2, 0x36BC, 0x36C5, 0x36CF, 0x36D9, 0x36E2, 0x36EC, 0x36F6, 0x36FF, 0x3709, 0x3713, 0x371D, 0x3726, 0x3730, 0x373A, 0x3743, 0x374D, 0x3757, 0x3761, 0x376A, 0x3774, 0x377E, 0x3788, 0x3791, 0x379B, 0x37A5, 0x37AF, 0x37B8, 0x37C2, 0x37CC, 0x37D6, 0x37E0, 0x37E9, 0x37F3, 0x37FD, 0x3807, 0x3811, 0x381A, 0x3824, 0x382E, 0x3838, 0x3842, 0x384B, 0x3855, 0x385F, 0x3869, 0x3873, 0x387D, 0x3886, 0x3890, 0x389A, 0x38A4, 0x38AE, 0x38B8, 0x38C2, 0x38CB, 0x38D5, 0x38DF, 0x38E9, 0x38F3, 0x38FD, 0x3907, 0x3911, 0x391B, 0x3924, 0x392E, 0x3938, 0x3942, 0x394C, 0x3956, 0x3960, 0x396A, 0x3974, 0x397E, 0x3988, 0x3992, 0x399B, 0x39A5, 0x39AF, 0x39B9, 0x39C3, 0x39CD, 0x39D7, 0x39E1, 0x39EB, 0x39F5, 0x39FF, 0x3A09, 0x3A13, 0x3A1D, 0x3A27, 0x3A31, 0x3A3B, 0x3A45, 0x3A4F, 0x3A59, 0x3A63, 0x3A6D, 0x3A77, 0x3A81, 0x3A8B, 0x3A95, 0x3A9F, 0x3AA9, 0x3AB3, 0x3ABD, 0x3AC7, 0x3AD1, 0x3ADB, 0x3AE5, 0x3AEF, 0x3AF9, 0x3B03, 0x3B0D, 0x3B17, 0x3B21, 0x3B2B, 0x3B35, 0x3B3F, 0x3B49, 0x3B53, 0x3B5D, 0x3B67, 0x3B72, 0x3B7C, 0x3B86, 0x3B90, 0x3B9A, 0x3BA4, 0x3BAE, 0x3BB8, 0x3BC2, 0x3BCC, 0x3BD6, 0x3BE0, 0x3BEA, 0x3BF4, 0x3BFF, 0x3C09, 0x3C13, 0x3C1D, 0x3C27, 0x3C31, 0x3C3B, 0x3C45, 0x3C4F, 0x3C59, 0x3C64, 0x3C6E, 0x3C78, 0x3C82, 0x3C8C, 0x3C96, 0x3CA0, 0x3CAA, 0x3CB4, 0x3CBF, 0x3CC9, 0x3CD3, 0x3CDD, 0x3CE7, 0x3CF1, 0x3CFB, 0x3D05, 0x3D10, 0x3D1A, 0x3D24, 0x3D2E, 0x3D38, 0x3D42, 0x3D4C, 0x3D57, 0x3D61, 0x3D6B, 0x3D75, 0x3D7F, 0x3D89, 0x3D93, 0x3D9E, 0x3DA8, 0x3DB2, 0x3DBC, 0x3DC6, 0x3DD0, 0x3DDA, 0x3DE5, 0x3DEF, 0x3DF9, 0x3E03, 0x3E0D, 0x3E17, 0x3E22, 0x3E2C, 0x3E36, 0x3E40, 0x3E4A, 0x3E54, 0x3E5F, 0x3E69, 0x3E73, 0x3E7D, 0x3E87, 0x3E91, 0x3E9C, 0x3EA6, 0x3EB0, 0x3EBA, 0x3EC4, 0x3ECF, 0x3ED9, 0x3EE3, 0x3EED, 0x3EF7, 0x3F01, 0x3F0C, 0x3F16, 0x3F20, 0x3F2A, 0x3F34, 0x3F3E, 0x3F49, 0x3F53, 0x3F5D, 0x3F67, 0x3F71, 0x3F7C, 0x3F86, 0x3F90, 0x3F9A, 0x3FA4, 0x3FAF, 0x3FB9, 0x3FC3, 0x3FCD, 0x3FD7, 0x3FE1, 0x3FEC, 0x3FF6, 0x4000, 0x400A, 0x4014, 0x401F, 0x4029, 0x4033, 0x403D, 0x4047, 0x4051, 0x405C, 0x4066, 0x4070, 0x407A, 0x4084, 0x408F, 0x4099, 0x40A3, 0x40AD, 0x40B7, 0x40C2, 0x40CC, 0x40D6, 0x40E0, 0x40EA, 0x40F4, 0x40FF, 0x4109, 0x4113, 0x411D, 0x4127, 0x4131, 0x413C, 0x4146, 0x4150, 0x415A, 0x4164, 0x416F, 0x4179, 0x4183, 0x418D, 0x4197, 0x41A1, 0x41AC, 0x41B6, 0x41C0, 0x41CA, 0x41D4, 0x41DE, 0x41E9, 0x41F3, 0x41FD, 0x4207, 0x4211, 0x421B, 0x4226, 0x4230, 0x423A, 0x4244, 0x424E, 0x4258, 0x4262, 0x426D, 0x4277, 0x4281, 0x428B, 0x4295, 0x429F, 0x42A9, 0x42B4, 0x42BE, 0x42C8, 0x42D2, 0x42DC, 0x42E6, 0x42F0, 0x42FB, 0x4305, 0x430F, 0x4319, 0x4323, 0x432D, 0x4337, 0x4341, 0x434C, 0x4356, 0x4360, 0x436A, 0x4374, 0x437E, 0x4388, 0x4392, 0x439C, 0x43A7, 0x43B1, 0x43BB, 0x43C5, 0x43CF, 0x43D9, 0x43E3, 0x43ED, 0x43F7, 0x4401, 0x440C, 0x4416, 0x4420, 0x442A, 0x4434, 0x443E, 0x4448, 0x4452, 0x445C, 0x4466, 0x4470, 0x447A, 0x4484, 0x448E, 0x4499, 0x44A3, 0x44AD, 0x44B7, 0x44C1, 0x44CB, 0x44D5, 0x44DF, 0x44E9, 0x44F3, 0x44FD, 0x4507, 0x4511, 0x451B, 0x4525, 0x452F, 0x4539, 0x4543, 0x454D, 0x4557, 0x4561, 0x456B, 0x4575, 0x457F, 0x4589, 0x4593, 0x459D, 0x45A7, 0x45B1, 0x45BB, 0x45C5, 0x45CF, 0x45D9, 0x45E3, 0x45ED, 0x45F7, 0x4601, 0x460B, 0x4615, 0x461F, 0x4629, 0x4633, 0x463D, 0x4647, 0x4651, 0x465B, 0x4665, 0x466E, 0x4678, 0x4682, 0x468C, 0x4696, 0x46A0, 0x46AA, 0x46B4, 0x46BE, 0x46C8, 0x46D2, 0x46DC, 0x46E5, 0x46EF, 0x46F9, 0x4703, 0x470D, 0x4717, 0x4721, 0x472B, 0x4735, 0x473E, 0x4748, 0x4752, 0x475C, 0x4766, 0x4770, 0x477A, 0x4783, 0x478D, 0x4797, 0x47A1, 0x47AB, 0x47B5, 0x47BE, 0x47C8, 0x47D2, 0x47DC, 0x47E6, 0x47EF, 0x47F9, 0x4803, 0x480D, 0x4817, 0x4820, 0x482A, 0x4834, 0x483E, 0x4848, 0x4851, 0x485B, 0x4865, 0x486F, 0x4878, 0x4882, 0x488C, 0x4896, 0x489F, 0x48A9, 0x48B3, 0x48BD, 0x48C6, 0x48D0, 0x48DA, 0x48E3, 0x48ED, 0x48F7, 0x4901, 0x490A, 0x4914, 0x491E, 0x4927, 0x4931, 0x493B, 0x4944, 0x494E, 0x4958, 0x4961, 0x496B, 0x4975, 0x497E, 0x4988, 0x4992, 0x499B, 0x49A5, 0x49AE, 0x49B8, 0x49C2, 0x49CB, 0x49D5, 0x49DE, 0x49E8, 0x49F2, 0x49FB, 0x4A05, 0x4A0E, 0x4A18, 0x4A22, 0x4A2B, 0x4A35, 0x4A3E, 0x4A48, 0x4A51, 0x4A5B, 0x4A64, 0x4A6E, 0x4A77, 0x4A81, 0x4A8B, 0x4A94, 0x4A9E, 0x4AA7, 0x4AB1, 0x4ABA, 0x4AC4, 0x4ACD, 0x4AD7, 0x4AE0, 0x4AE9, 0x4AF3, 0x4AFC, 0x4B06, 0x4B0F, 0x4B19, 0x4B22, 0x4B2C, 0x4B35, 0x4B3F, 0x4B48, 0x4B51, 0x4B5B, 0x4B64, 0x4B6E, 0x4B77, 0x4B80, 0x4B8A, 0x4B93, 0x4B9D, 0x4BA6, 0x4BAF, 0x4BB9, 0x4BC2, 0x4BCB, 0x4BD5, 0x4BDE, 0x4BE7, 0x4BF1, 0x4BFA, 0x4C03, 0x4C0D, 0x4C16, 0x4C1F, 0x4C29, 0x4C32, 0x4C3B, 0x4C45, 0x4C4E, 0x4C57, 0x4C60, 0x4C6A, 0x4C73, 0x4C7C, 0x4C86, 0x4C8F, 0x4C98, 0x4CA1, 0x4CAB, 0x4CB4, 0x4CBD, 0x4CC6, 0x4CCF, 0x4CD9, 0x4CE2, 0x4CEB, 0x4CF4, 0x4CFD, 0x4D07, 0x4D10, 0x4D19, 0x4D22, 0x4D2B, 0x4D34, 0x4D3E, 0x4D47, 0x4D50, 0x4D59, 0x4D62, 0x4D6B, 0x4D74, 0x4D7D, 0x4D87, 0x4D90, 0x4D99, 0x4DA2, 0x4DAB, 0x4DB4, 0x4DBD, 0x4DC6, 0x4DCF, 0x4DD8, 0x4DE1, 0x4DEA, 0x4DF3, 0x4DFC, 0x4E05, 0x4E0F, 0x4E18, 0x4E21, 0x4E2A, 0x4E33, 0x4E3C, 0x4E45, 0x4E4E, 0x4E56, 0x4E5F, 0x4E68, 0x4E71, 0x4E7A, 0x4E83, 0x4E8C, 0x4E95, 0x4E9E, 0x4EA7, 0x4EB0, 0x4EB9, 0x4EC2, 0x4ECB, 0x4ED4, 0x4EDC, 0x4EE5, 0x4EEE, 0x4EF7, 0x4F00, 0x4F09, 0x4F12, 0x4F1B, 0x4F23, 0x4F2C, 0x4F35, 0x4F3E, 0x4F47, 0x4F50, 0x4F58, 0x4F61, 0x4F6A, 0x4F73, 0x4F7C, 0x4F84, 0x4F8D, 0x4F96, 0x4F9F, 0x4FA7, 0x4FB0, 0x4FB9, 0x4FC2, 0x4FCA, 0x4FD3, 0x4FDC, 0x4FE5, 0x4FED, 0x4FF6, 0x4FFF, 0x5007, 0x5010, 0x5019, 0x5021, 0x502A, 0x5033, 0x503B, 0x5044, 0x504D, 0x5055, 0x505E, 0x5067, 0x506F, 0x5078, 0x5080, 0x5089, 0x5092, 0x509A, 0x50A3, 0x50AB, 0x50B4, 0x50BC, 0x50C5, 0x50CE, 0x50D6, 0x50DF, 0x50E7, 0x50F0, 0x50F8, 0x5101, 0x5109, 0x5112, 0x511A, 0x5123, 0x512B, 0x5134, 0x513C, 0x5145, 0x514D, 0x5156, 0x515E, 0x5166, 0x516F, 0x5177, 0x5180, 0x5188, 0x5191, 0x5199, 0x51A1, 0x51AA, 0x51B2, 0x51BB, 0x51C3, 0x51CB, 0x51D4, 0x51DC, 0x51E4, 0x51ED, 0x51F5, 0x51FD, 0x5206, 0x520E, 0x5216, 0x521F, 0x5227, 0x522F, 0x5237, 0x5240, 0x5248, 0x5250, 0x5259, 0x5261, 0x5269, 0x5271, 0x527A, 0x5282, 0x528A, 0x5292, 0x529A, 0x52A3, 0x52AB, 0x52B3, 0x52BB, 0x52C3, 0x52CC, 0x52D4, 0x52DC, 0x52E4, 0x52EC, 0x52F4, 0x52FC, 0x5305, 0x530D, 0x5315, 0x531D, 0x5325, 0x532D, 0x5335, 0x533D, 0x5345, 0x534D, 0x5355, 0x535E, 0x5366, 0x536E, 0x5376, 0x537E, 0x5386, 0x538E, 0x5396, 0x539E, 0x53A6, 0x53AE, 0x53B6, 0x53BE, 0x53C6, 0x53CE, 0x53D6, 0x53DE, 0x53E6, 0x53ED, 0x53F5, 0x53FD, 0x5405, 0x540D, 0x5415, 0x541D, 0x5425, 0x542D, 0x5435, 0x543D, 0x5444, 0x544C, 0x5454, 0x545C, 0x5464, 0x546C, 0x5473, 0x547B, 0x5483, 0x548B, 0x5493, 0x549B, 0x54A2, 0x54AA, 0x54B2, 0x54BA, 0x54C1, 0x54C9, 0x54D1, 0x54D9, 0x54E0, 0x54E8, 0x54F0, 0x54F8, 0x54FF, 0x5507, 0x550F, 0x5516, 0x551E, 0x5526, 0x552D, 0x5535, 0x553D, 0x5544, 0x554C, 0x5554, 0x555B, 0x5563, 0x556B, 0x5572, 0x557A, 0x5581, 0x5589, 0x5591, 0x5598, 0x55A0, 0x55A7, 0x55AF, 0x55B7, 0x55BE, 0x55C6, 0x55CD, 0x55D5, 0x55DC, 0x55E4, 0x55EB, 0x55F3, 0x55FA, 0x5602, 0x5609, 0x5611, 0x5618, 0x5620, 0x5627, 0x562F, 0x5636, 0x563E, 0x5645, 0x564C, 0x5654, 0x565B, 0x5663, 0x566A, 0x5671, 0x5679, 0x5680, 0x5688, 0x568F, 0x5696, 0x569E, 0x56A5, 0x56AC, 0x56B4, 0x56BB, 0x56C2, 0x56CA, 0x56D1, 0x56D8, 0x56E0, 0x56E7, 0x56EE, 0x56F6, 0x56FD, 0x5704, 0x570B, 0x5713, 0x571A, 0x5721, 0x5728, 0x5730, 0x5737, 0x573E, 0x5745, 0x574C, 0x5754, 0x575B, 0x5762, 0x5769, 0x5770, 0x5778, 0x577F, 0x5786, 0x578D, 0x5794, 0x579B, 0x57A2, 0x57AA, 0x57B1, 0x57B8, 0x57BF, 0x57C6, 0x57CD, 0x57D4, 0x57DB, 0x57E2, 0x57E9, 0x57F0, 0x57F7, 0x57FE, 0x5806, 0x580D, 0x5814, 0x581B, 0x5822, 0x5829, 0x5830, 0x5837, 0x583E, 0x5845, 0x584C, 0x5853, 0x585A, 0x5860, 0x5867, 0x586E, 0x5875, 0x587C, 0x5883, 0x588A, 0x5891, 0x5898, 0x589F, 0x58A6, 0x58AD, 0x58B3, 0x58BA, 0x58C1, 0x58C8, 0x58CF, 0x58D6, 0x58DD, 0x58E3, 0x58EA, 0x58F1, 0x58F8, 0x58FF, 0x5906, 0x590C, 0x5913, 0x591A, 0x5921, 0x5928, 0x592E, 0x5935, 0x593C, 0x5943, 0x5949, 0x5950, 0x5957, 0x595D, 0x5964, 0x596B, 0x5972, 0x5978, 0x597F, 0x5986, 0x598C, 0x5993, 0x599A, 0x59A0, 0x59A7, 0x59AE, 0x59B4, 0x59BB, 0x59C2, 0x59C8, 0x59CF, 0x59D5, 0x59DC, 0x59E3, 0x59E9, 0x59F0, 0x59F6, 0x59FD, 0x5A04, 0x5A0A, 0x5A11, 0x5A17, 0x5A1E, 0x5A24, 0x5A2B, 0x5A31, 0x5A38, 0x5A3E, 0x5A45, 0x5A4B, 0x5A52, 0x5A58, 0x5A5F, 0x5A65, 0x5A6C, 0x5A72, 0x5A79, 0x5A7F, 0x5A86, 0x5A8C, 0x5A93, 0x5A99, 0x5A9F, 0x5AA6, 0x5AAC, 0x5AB3, 0x5AB9, 0x5AC0, 0x5AC6, 0x5ACC, 0x5AD3, 0x5AD9, 0x5ADF, 0x5AE6, 0x5AEC, 0x5AF2, 0x5AF9, 0x5AFF, 0x5B05, 0x5B0C, 0x5B12, 0x5B18, 0x5B1F, 0x5B25, 0x5B2B, 0x5B32, 0x5B38, 0x5B3E, 0x5B44, 0x5B4B, 0x5B51, 0x5B57, 0x5B5D, 0x5B64, 0x5B6A, 0x5B70, 0x5B76, 0x5B7D, 0x5B83, 0x5B89, 0x5B8F, 0x5B95, 0x5B9C, 0x5BA2, 0x5BA8, 0x5BAE, 0x5BB4, 0x5BBA, 0x5BC1, 0x5BC7, 0x5BCD, 0x5BD3, 0x5BD9, 0x5BDF, 0x5BE5, 0x5BEB, 0x5BF2, 0x5BF8, 0x5BFE, 0x5C04, 0x5C0A, 0x5C10, 0x5C16, 0x5C1C, 0x5C22, 0x5C28, 0x5C2E, 0x5C34, 0x5C3A, 0x5C40, 0x5C46, 0x5C4C, 0x5C52, 0x5C58, 0x5C5E, 0x5C64, 0x5C6A, 0x5C70, 0x5C76, 0x5C7C, 0x5C82, 0x5C88, 0x5C8E, 0x5C94, 0x5C9A, 0x5CA0, 0x5CA6, 0x5CAC, 0x5CB2, 0x5CB8, 0x5CBE, 0x5CC3, 0x5CC9, 0x5CCF, 0x5CD5, 0x5CDB, 0x5CE1, 0x5CE7, 0x5CED, 0x5CF3, 0x5CF8, 0x5CFE, 0x5D04, 0x5D0A, 0x5D10, 0x5D16, 0x5D1B, 0x5D21, 0x5D27, 0x5D2D, 0x5D33, 0x5D38, 0x5D3E, 0x5D44, 0x5D4A, 0x5D4F, 0x5D55, 0x5D5B, 0x5D61, 0x5D66, 0x5D6C, 0x5D72, 0x5D78, 0x5D7D, 0x5D83, 0x5D89, 0x5D8E, 0x5D94, 0x5D9A, 0x5DA0, 0x5DA5, 0x5DAB, 0x5DB1, 0x5DB6, 0x5DBC, 0x5DC2, 0x5DC7, 0x5DCD, 0x5DD3, 0x5DD8, 0x5DDE, 0x5DE3, 0x5DE9, 0x5DEF, 0x5DF4, 0x5DFA, 0x5DFF, 0x5E05, 0x5E0B, 0x5E10, 0x5E16, 0x5E1B, 0x5E21, 0x5E26, 0x5E2C, 0x5E32, 0x5E37, 0x5E3D, 0x5E42, 0x5E48, 0x5E4D, 0x5E53, 0x5E58, 0x5E5E, 0x5E63, 0x5E69, 0x5E6E, 0x5E74, 0x5E79, 0x5E7F, 0x5E84, 0x5E8A, 0x5E8F, 0x5E94, 0x5E9A, 0x5E9F, 0x5EA5, 0x5EAA, 0x5EB0, 0x5EB5, 0x5EBA, 0x5EC0, 0x5EC5, 0x5ECB, 0x5ED0, 0x5ED5, 0x5EDB, 0x5EE0, 0x5EE6, 0x5EEB, 0x5EF0, 0x5EF6, 0x5EFB, 0x5F00, 0x5F06, 0x5F0B, 0x5F10, 0x5F16, 0x5F1B, 0x5F20, 0x5F26, 0x5F2B, 0x5F30, 0x5F36, 0x5F3B, 0x5F40, 0x5F45, 0x5F4B, 0x5F50, 0x5F55, 0x5F5A, 0x5F60, 0x5F65, 0x5F6A, 0x5F6F, 0x5F75, 0x5F7A, 0x5F7F, 0x5F84, 0x5F8A, 0x5F8F, 0x5F94, 0x5F99, 0x5F9E, 0x5FA4, 0x5FA9, 0x5FAE, 0x5FB3, 0x5FB8, 0x5FBD, 0x5FC3, 0x5FC8, 0x5FCD, 0x5FD2, 0x5FD7, 0x5FDC, 0x5FE1, 0x5FE6, 0x5FEC, 0x5FF1, 0x5FF6, 0x5FFB, 0x6000, 0x6005, 0x600A, 0x600F, 0x6014, 0x601A, 0x601F, 0x6024, 0x6029, 0x602E, 0x6033, 0x6038, 0x603D, 0x6043, 0x6048, 0x604D, 0x6052, 0x6057, 0x605C, 0x6062, 0x6067, 0x606C, 0x6071, 0x6076, 0x607C, 0x6081, 0x6086, 0x608B, 0x6091, 0x6096, 0x609B, 0x60A0, 0x60A6, 0x60AB, 0x60B0, 0x60B5, 0x60BB, 0x60C0, 0x60C5, 0x60CA, 0x60D0, 0x60D5, 0x60DA, 0x60E0, 0x60E5, 0x60EA, 0x60F0, 0x60F5, 0x60FA, 0x6100, 0x6105, 0x610A, 0x6110, 0x6115, 0x611A, 0x6120, 0x6125, 0x612B, 0x6130, 0x6135, 0x613B, 0x6140, 0x6146, 0x614B, 0x6150, 0x6156, 0x615B, 0x6161, 0x6166, 0x616C, 0x6171, 0x6176, 0x617C, 0x6181, 0x6187, 0x618C, 0x6192, 0x6197, 0x619D, 0x61A2, 0x61A8, 0x61AD, 0x61B3, 0x61B8, 0x61BE, 0x61C3, 0x61C9, 0x61CE, 0x61D4, 0x61DA, 0x61DF, 0x61E5, 0x61EA, 0x61F0, 0x61F5, 0x61FB, 0x6201, 0x6206, 0x620C, 0x6211, 0x6217, 0x621D, 0x6222, 0x6228, 0x622D, 0x6233, 0x6239, 0x623E, 0x6244, 0x624A, 0x624F, 0x6255, 0x625B, 0x6260, 0x6266, 0x626C, 0x6272, 0x6277, 0x627D, 0x6283, 0x6288, 0x628E, 0x6294, 0x629A, 0x629F, 0x62A5, 0x62AB, 0x62B1, 0x62B6, 0x62BC, 0x62C2, 0x62C8, 0x62CD, 0x62D3, 0x62D9, 0x62DF, 0x62E5, 0x62EA, 0x62F0, 0x62F6, 0x62FC, 0x6302, 0x6308, 0x630D, 0x6313, 0x6319, 0x631F, 0x6325, 0x632B, 0x6331, 0x6337, 0x633D, 0x6342, 0x6348, 0x634E, 0x6354, 0x635A, 0x6360, 0x6366, 0x636C, 0x6372, 0x6378, 0x637E, 0x6384, 0x638A, 0x6390, 0x6396, 0x639C, 0x63A2, 0x63A8, 0x63AE, 0x63B4, 0x63BA, 0x63C0, 0x63C6, 0x63CC, 0x63D2, 0x63D8, 0x63DE, 0x63E4, 0x63EA, 0x63F0, 0x63F6, 0x63FC, 0x6402, 0x6408, 0x640E, 0x6415, 0x641B, 0x6421, 0x6427, 0x642D, 0x6433, 0x6439, 0x643F, 0x6446, 0x644C, 0x6452, 0x6458, 0x645E, 0x6464, 0x646B, 0x6471, 0x6477, 0x647D, 0x6483, 0x648A, 0x6490, 0x6496, 0x649C, 0x64A3, 0x64A9, 0x64AF, 0x64B5, 0x64BC, 0x64C2, 0x64C8, 0x64CE, 0x64D5, 0x64DB, 0x64E1, 0x64E8, 0x64EE, 0x64F4, 0x64FB, 0x6501, 0x6507, 0x650E, 0x6514, 0x651A, 0x6521, 0x6527, 0x652D, 0x6534, 0x653A, 0x6540, 0x6547, 0x654D, 0x6554, 0x655A, 0x6561, 0x6567, 0x656D, 0x6574, 0x657A, 0x6581, 0x6587, 0x658E, 0x6594, 0x659B, 0x65A1, 0x65A8, 0x65AE, 0x65B5, 0x65BB, 0x65C2, 0x65C8, 0x65CF, 0x65D5, 0x65DC, 0x65E2, 0x65E9, 0x65EF, 0x65F6, 0x65FC, 0x6603, 0x660A, 0x6610, 0x6617, 0x661D, 0x6624, 0x662B, 0x6631, 0x6638, 0x663E, 0x6645, 0x664C, 0x6652, 0x6659, 0x6660, 0x6666, 0x666D, 0x6674, 0x667A, 0x6681, 0x6688, 0x668E, 0x6695, 0x669C, 0x66A3, 0x66A9, 0x66B0, 0x66B7, 0x66BD, 0x66C4, 0x66CB, 0x66D2, 0x66D8, 0x66DF, 0x66E6, 0x66ED, 0x66F4, 0x66FA, 0x6701, 0x6708, 0x670F, 0x6716, 0x671D, 0x6723, 0x672A, 0x6731, 0x6738, 0x673F, 0x6746, 0x674D, 0x6753, 0x675A, 0x6761, 0x6768, 0x676F, 0x6776, 0x677D, 0x6784, 0x678B, 0x6792, 0x6799, 0x67A0, 0x67A6, 0x67AD, 0x67B4, 0x67BB, 0x67C2, 0x67C9, 0x67D0, 0x67D7, 0x67DE, 0x67E5, 0x67EC, 0x67F3, 0x67FA, 0x6802, 0x6809, 0x6810, 0x6817, 0x681E, 0x6825, 0x682C, 0x6833, 0x683A, 0x6841, 0x6848, 0x684F, 0x6856, 0x685E, 0x6865, 0x686C, 0x6873, 0x687A, 0x6881, 0x6888, 0x6890, 0x6897, 0x689E, 0x68A5, 0x68AC, 0x68B4, 0x68BB, 0x68C2, 0x68C9, 0x68D0, 0x68D8, 0x68DF, 0x68E6, 0x68ED, 0x68F5, 0x68FC, 0x6903, 0x690A, 0x6912, 0x6919, 0x6920, 0x6928, 0x692F, 0x6936, 0x693E, 0x6945, 0x694C, 0x6954, 0x695B, 0x6962, 0x696A, 0x6971, 0x6978, 0x6980, 0x6987, 0x698F, 0x6996, 0x699D, 0x69A5, 0x69AC, 0x69B4, 0x69BB, 0x69C2, 0x69CA, 0x69D1, 0x69D9, 0x69E0, 0x69E8, 0x69EF, 0x69F7, 0x69FE, 0x6A06, 0x6A0D, 0x6A15, 0x6A1C, 0x6A24, 0x6A2B, 0x6A33, 0x6A3A, 0x6A42, 0x6A49, 0x6A51, 0x6A59, 0x6A60, 0x6A68, 0x6A6F, 0x6A77, 0x6A7F, 0x6A86, 0x6A8E, 0x6A95, 0x6A9D, 0x6AA5, 0x6AAC, 0x6AB4, 0x6ABC, 0x6AC3, 0x6ACB, 0x6AD3, 0x6ADA, 0x6AE2, 0x6AEA, 0x6AF1, 0x6AF9, 0x6B01, 0x6B08, 0x6B10, 0x6B18, 0x6B20, 0x6B27, 0x6B2F, 0x6B37, 0x6B3F, 0x6B46, 0x6B4E, 0x6B56, 0x6B5E, 0x6B65, 0x6B6D, 0x6B75, 0x6B7D, 0x6B85, 0x6B8D, 0x6B94, 0x6B9C, 0x6BA4, 0x6BAC, 0x6BB4, 0x6BBC, 0x6BC3, 0x6BCB, 0x6BD3, 0x6BDB, 0x6BE3, 0x6BEB, 0x6BF3, 0x6BFB, 0x6C03, 0x6C0B, 0x6C13, 0x6C1A, 0x6C22, 0x6C2A, 0x6C32, 0x6C3A, 0x6C42, 0x6C4A, 0x6C52, 0x6C5A, 0x6C62, 0x6C6A, 0x6C72, 0x6C7A, 0x6C82, 0x6C8A, 0x6C92, 0x6C9A, 0x6CA2, 0x6CAB, 0x6CB3, 0x6CBB, 0x6CC3, 0x6CCB, 0x6CD3, 0x6CDB, 0x6CE3, 0x6CEB, 0x6CF3, 0x6CFB, 0x6D04, 0x6D0C, 0x6D14, 0x6D1C, 0x6D24, 0x6D2C, 0x6D34, 0x6D3D, 0x6D45, 0x6D4D, 0x6D55, 0x6D5D, 0x6D66, 0x6D6E, 0x6D76, 0x6D7E, 0x6D86, 0x6D8F, 0x6D97, 0x6D9F, 0x6DA7, 0x6DB0, 0x6DB8, 0x6DC0, 0x6DC9, 0x6DD1, 0x6DD9, 0x6DE1, 0x6DEA, 0x6DF2, 0x6DFA, 0x6E03, 0x6E0B, 0x6E13, 0x6E1C, 0x6E24, 0x6E2C, 0x6E35, 0x6E3D, 0x6E45, 0x6E4E, 0x6E56, 0x6E5F, 0x6E67, 0x6E6F, 0x6E78, 0x6E80, 0x6E89, 0x6E91, 0x6E9A, 0x6EA2, 0x6EAA, 0x6EB3, 0x6EBB, 0x6EC4, 0x6ECC, 0x6ED5, 0x6EDD, 0x6EE6, 0x6EEE, 0x6EF7, 0x6EFF, 0x6F08, 0x6F10, 0x6F19, 0x6F21, 0x6F2A, 0x6F32, 0x6F3B, 0x6F44, 0x6F4C, 0x6F55, 0x6F5D, 0x6F66, 0x6F6E, 0x6F77, 0x6F80, 0x6F88, 0x6F91, 0x6F99, 0x6FA2, 0x6FAB, 0x6FB3, 0x6FBC, 0x6FC5, 0x6FCD, 0x6FD6, 0x6FDF, 0x6FE7, 0x6FF0, 0x6FF9, 0x7001, 0x700A, 0x7013, 0x701B, 0x7024, 0x702D, 0x7036, 0x703E, 0x7047, 0x7050, 0x7059, 0x7061, 0x706A, 0x7073, 0x707C, 0x7084, 0x708D, 0x7096, 0x709F, 0x70A8, 0x70B0, 0x70B9, 0x70C2, 0x70CB, 0x70D4, 0x70DD, 0x70E5, 0x70EE, 0x70F7, 0x7100, 0x7109, 0x7112, 0x711B, 0x7124, 0x712C, 0x7135, 0x713E, 0x7147, 0x7150, 0x7159, 0x7162, 0x716B, 0x7174, 0x717D, 0x7186, 0x718F, 0x7198, 0x71A1, 0x71AA, 0x71B2, 0x71BB, 0x71C4, 0x71CD, 0x71D6, 0x71DF, 0x71E8, 0x71F1, 0x71FB, 0x7204, 0x720D, 0x7216, 0x721F, 0x7228, 0x7231, 0x723A, 0x7243, 0x724C, 0x7255, 0x725E, 0x7267, 0x7270, 0x7279, 0x7283, 0x728C, 0x7295, 0x729E, 0x72A7, 0x72B0, 0x72B9, 0x72C2, 0x72CC, 0x72D5, 0x72DE, 0x72E7, 0x72F0, 0x72F9, 0x7303, 0x730C, 0x7315, 0x731E, 0x7327, 0x7331, 0x733A, 0x7343, 0x734C, 0x7355, 0x735F, 0x7368, 0x7371, 0x737A, 0x7384, 0x738D, 0x7396, 0x73A0, 0x73A9, 0x73B2, 0x73BB, 0x73C5, 0x73CE, 0x73D7, 0x73E1, 0x73EA, 0x73F3, 0x73FD, 0x7406, 0x740F, 0x7419, 0x7422, 0x742B, 0x7435, 0x743E, 0x7447, 0x7451, 0x745A, 0x7463, 0x746D, 0x7476, 0x7480, 0x7489, 0x7492, 0x749C, 0x74A5, 0x74AF, 0x74B8, 0x74C1, 0x74CB, 0x74D4, 0x74DE, 0x74E7, 0x74F1, 0x74FA, 0x7504, 0x750D, 0x7517, 0x7520, 0x7529, 0x7533, 0x753C, 0x7546, 0x754F, 0x7559, 0x7562, 0x756C, 0x7575, 0x757F, 0x7589, 0x7592, 0x759C, 0x75A5, 0x75AF, 0x75B8, 0x75C2, 0x75CB, 0x75D5, 0x75DE, 0x75E8, 0x75F2, 0x75FB, 0x7605, 0x760E, 0x7618, 0x7622, 0x762B, 0x7635, 0x763E, 0x7648, 0x7652, 0x765B, 0x7665, 0x766E, 0x7678, 0x7682, 0x768B, 0x7695, 0x769F, 0x76A8, 0x76B2, 0x76BC, 0x76C5, 0x76CF, 0x76D9, 0x76E2, 0x76EC, 0x76F6, 0x76FF, 0x7709, 0x7713, 0x771D, 0x7726, 0x7730, 0x773A, 0x7743, 0x774D, 0x7757, 0x7761, 0x776A, 0x7774, 0x777E, 0x7788, 0x7791, 0x779B, 0x77A5, 0x77AF, 0x77B8, 0x77C2, 0x77CC, 0x77D6, 0x77E0, 0x77E9, 0x77F3, 0x77FD, 0x7807, 0x7811, 0x781A, 0x7824, 0x782E, 0x7838, 0x7842, 0x784B, 0x7855, 0x785F, 0x7869, 0x7873, 0x787D, 0x7886, 0x7890, 0x789A, 0x78A4, 0x78AE, 0x78B8, 0x78C2, 0x78CB, 0x78D5, 0x78DF, 0x78E9, 0x78F3, 0x78FD, 0x7907, 0x7911, 0x791B, 0x7924, 0x792E, 0x7938, 0x7942, 0x794C, 0x7956, 0x7960, 0x796A, 0x7974, 0x797E, 0x7988, 0x7992, 0x799B, 0x79A5, 0x79AF, 0x79B9, 0x79C3, 0x79CD, 0x79D7, 0x79E1, 0x79EB, 0x79F5, 0x79FF, 0x7A09, 0x7A13, 0x7A1D, 0x7A27, 0x7A31, 0x7A3B, 0x7A45, 0x7A4F, 0x7A59, 0x7A63, 0x7A6D, 0x7A77, 0x7A81, 0x7A8B, 0x7A95, 0x7A9F, 0x7AA9, 0x7AB3, 0x7ABD, 0x7AC7, 0x7AD1, 0x7ADB, 0x7AE5, 0x7AEF, 0x7AF9, 0x7B03, 0x7B0D, 0x7B17, 0x7B21, 0x7B2B, 0x7B35, 0x7B3F, 0x7B49, 0x7B53, 0x7B5D, 0x7B67, 0x7B72, 0x7B7C, 0x7B86, 0x7B90, 0x7B9A, 0x7BA4, 0x7BAE, 0x7BB8, 0x7BC2, 0x7BCC, 0x7BD6, 0x7BE0, 0x7BEA, 0x7BF4, 0x7BFF, 0x7C09, 0x7C13, 0x7C1D, 0x7C27, 0x7C31, 0x7C3B, 0x7C45, 0x7C4F, 0x7C59, 0x7C64, 0x7C6E, 0x7C78, 0x7C82, 0x7C8C, 0x7C96, 0x7CA0, 0x7CAA, 0x7CB4, 0x7CBF, 0x7CC9, 0x7CD3, 0x7CDD, 0x7CE7, 0x7CF1, 0x7CFB, 0x7D05, 0x7D10, 0x7D1A, 0x7D24, 0x7D2E, 0x7D38, 0x7D42, 0x7D4C, 0x7D57, 0x7D61, 0x7D6B, 0x7D75, 0x7D7F, 0x7D89, 0x7D93, 0x7D9E, 0x7DA8, 0x7DB2, 0x7DBC, 0x7DC6, 0x7DD0, 0x7DDA, 0x7DE5, 0x7DEF, 0x7DF9, 0x7E03, 0x7E0D, 0x7E17, 0x7E22, 0x7E2C, 0x7E36, 0x7E40, 0x7E4A, 0x7E54, 0x7E5F, 0x7E69, 0x7E73, 0x7E7D, 0x7E87, 0x7E91, 0x7E9C, 0x7EA6, 0x7EB0, 0x7EBA, 0x7EC4, 0x7ECF, 0x7ED9, 0x7EE3, 0x7EED, 0x7EF7, 0x7F01, 0x7F0C, 0x7F16, 0x7F20, 0x7F2A, 0x7F34, 0x7F3E, 0x7F49, 0x7F53, 0x7F5D, 0x7F67, 0x7F71, 0x7F7C, 0x7F86, 0x7F90, 0x7F9A, 0x7FA4, 0x7FAF, 0x7FB9, 0x7FC3, 0x7FCD, 0x7FD7, 0x7FE1, 0x7FEC, 0x7FF6, 0x8000, 0x800A, 0x8014, 0x801F, 0x8029, 0x8033, 0x803D, 0x8047, 0x8051, 0x805C, 0x8066, 0x8070, 0x807A, 0x8084, 0x808F, 0x8099, 0x80A3, 0x80AD, 0x80B7, 0x80C2, 0x80CC, 0x80D6, 0x80E0, 0x80EA, 0x80F4, 0x80FF, 0x8109, 0x8113, 0x811D, 0x8127, 0x8131, 0x813C, 0x8146, 0x8150, 0x815A, 0x8164, 0x816F, 0x8179, 0x8183, 0x818D, 0x8197, 0x81A1, 0x81AC, 0x81B6, 0x81C0, 0x81CA, 0x81D4, 0x81DE, 0x81E9, 0x81F3, 0x81FD, 0x8207, 0x8211, 0x821B, 0x8226, 0x8230, 0x823A, 0x8244, 0x824E, 0x8258, 0x8262, 0x826D, 0x8277, 0x8281, 0x828B, 0x8295, 0x829F, 0x82A9, 0x82B4, 0x82BE, 0x82C8, 0x82D2, 0x82DC, 0x82E6, 0x82F0, 0x82FB, 0x8305, 0x830F, 0x8319, 0x8323, 0x832D, 0x8337, 0x8341, 0x834C, 0x8356, 0x8360, 0x836A, 0x8374, 0x837E, 0x8388, 0x8392, 0x839C, 0x83A7, 0x83B1, 0x83BB, 0x83C5, 0x83CF, 0x83D9, 0x83E3, 0x83ED, 0x83F7, 0x8401, 0x840C, 0x8416, 0x8420, 0x842A, 0x8434, 0x843E, 0x8448, 0x8452, 0x845C, 0x8466, 0x8470, 0x847A, 0x8484, 0x848E, 0x8499, 0x84A3, 0x84AD, 0x84B7, 0x84C1, 0x84CB, 0x84D5, 0x84DF, 0x84E9, 0x84F3, 0x84FD, 0x8507, 0x8511, 0x851B, 0x8525, 0x852F, 0x8539, 0x8543, 0x854D, 0x8557, 0x8561, 0x856B, 0x8575, 0x857F, 0x8589, 0x8593, 0x859D, 0x85A7, 0x85B1, 0x85BB, 0x85C5, 0x85CF, 0x85D9, 0x85E3, 0x85ED, 0x85F7, 0x8601, 0x860B, 0x8615, 0x861F, 0x8629, 0x8633, 0x863D, 0x8647, 0x8651, 0x865B, 0x8665, 0x866E, 0x8678, 0x8682, 0x868C, 0x8696, 0x86A0, 0x86AA, 0x86B4, 0x86BE, 0x86C8, 0x86D2, 0x86DC, 0x86E5, 0x86EF, 0x86F9, 0x8703, 0x870D, 0x8717, 0x8721, 0x872B, 0x8735, 0x873E, 0x8748, 0x8752, 0x875C, 0x8766, 0x8770, 0x877A, 0x8783, 0x878D, 0x8797, 0x87A1, 0x87AB, 0x87B5, 0x87BE, 0x87C8, 0x87D2, 0x87DC, 0x87E6, 0x87EF, 0x87F9, 0x8803, 0x880D, 0x8817, 0x8820, 0x882A, 0x8834, 0x883E, 0x8848, 0x8851, 0x885B, 0x8865, 0x886F, 0x8878, 0x8882, 0x888C, 0x8896, 0x889F, 0x88A9, 0x88B3, 0x88BD, 0x88C6, 0x88D0, 0x88DA, 0x88E3, 0x88ED, 0x88F7, 0x8901, 0x890A, 0x8914, 0x891E, 0x8927, 0x8931, 0x893B, 0x8944, 0x894E, 0x8958, 0x8961, 0x896B, 0x8975, 0x897E, 0x8988, 0x8992, 0x899B, 0x89A5, 0x89AE, 0x89B8, 0x89C2, 0x89CB, 0x89D5, 0x89DE, 0x89E8, 0x89F2, 0x89FB, 0x8A05, 0x8A0E, 0x8A18, 0x8A22, 0x8A2B, 0x8A35, 0x8A3E, 0x8A48, 0x8A51, 0x8A5B, 0x8A64, 0x8A6E, 0x8A77, 0x8A81, 0x8A8B, 0x8A94, 0x8A9E, 0x8AA7, 0x8AB1, 0x8ABA, 0x8AC4, 0x8ACD, 0x8AD7, 0x8AE0, 0x8AE9, 0x8AF3, 0x8AFC, 0x8B06, 0x8B0F, 0x8B19, 0x8B22, 0x8B2C, 0x8B35, 0x8B3F, 0x8B48, 0x8B51, 0x8B5B, 0x8B64, 0x8B6E, 0x8B77, 0x8B80, 0x8B8A, 0x8B93, 0x8B9D, 0x8BA6, 0x8BAF, 0x8BB9, 0x8BC2, 0x8BCB, 0x8BD5, 0x8BDE, 0x8BE7, 0x8BF1, 0x8BFA, 0x8C03, 0x8C0D, 0x8C16, 0x8C1F, 0x8C29, 0x8C32, 0x8C3B, 0x8C45, 0x8C4E, 0x8C57, 0x8C60, 0x8C6A, 0x8C73, 0x8C7C, 0x8C86, 0x8C8F, 0x8C98, 0x8CA1, 0x8CAB, 0x8CB4, 0x8CBD, 0x8CC6, 0x8CCF, 0x8CD9, 0x8CE2, 0x8CEB, 0x8CF4, 0x8CFD, 0x8D07, 0x8D10, 0x8D19, 0x8D22, 0x8D2B, 0x8D34, 0x8D3E, 0x8D47, 0x8D50, 0x8D59, 0x8D62, 0x8D6B, 0x8D74, 0x8D7D, 0x8D87, 0x8D90, 0x8D99, 0x8DA2, 0x8DAB, 0x8DB4, 0x8DBD, 0x8DC6, 0x8DCF, 0x8DD8, 0x8DE1, 0x8DEA, 0x8DF3, 0x8DFC, 0x8E05, 0x8E0F, 0x8E18, 0x8E21, 0x8E2A, 0x8E33, 0x8E3C, 0x8E45, 0x8E4E, 0x8E56, 0x8E5F, 0x8E68, 0x8E71, 0x8E7A, 0x8E83, 0x8E8C, 0x8E95, 0x8E9E, 0x8EA7, 0x8EB0, 0x8EB9, 0x8EC2, 0x8ECB, 0x8ED4, 0x8EDC, 0x8EE5, 0x8EEE, 0x8EF7, 0x8F00, 0x8F09, 0x8F12, 0x8F1B, 0x8F23, 0x8F2C, 0x8F35, 0x8F3E, 0x8F47, 0x8F50, 0x8F58, 0x8F61, 0x8F6A, 0x8F73, 0x8F7C, 0x8F84, 0x8F8D, 0x8F96, 0x8F9F, 0x8FA7, 0x8FB0, 0x8FB9, 0x8FC2, 0x8FCA, 0x8FD3, 0x8FDC, 0x8FE5, 0x8FED, 0x8FF6, 0x8FFF, 0x9007, 0x9010, 0x9019, 0x9021, 0x902A, 0x9033, 0x903B, 0x9044, 0x904D, 0x9055, 0x905E, 0x9067, 0x906F, 0x9078, 0x9080, 0x9089, 0x9092, 0x909A, 0x90A3, 0x90AB, 0x90B4, 0x90BC, 0x90C5, 0x90CE, 0x90D6, 0x90DF, 0x90E7, 0x90F0, 0x90F8, 0x9101, 0x9109, 0x9112, 0x911A, 0x9123, 0x912B, 0x9134, 0x913C, 0x9145, 0x914D, 0x9156, 0x915E, 0x9166, 0x916F, 0x9177, 0x9180, 0x9188, 0x9191, 0x9199, 0x91A1, 0x91AA, 0x91B2, 0x91BB, 0x91C3, 0x91CB, 0x91D4, 0x91DC, 0x91E4, 0x91ED, 0x91F5, 0x91FD, 0x9206, 0x920E, 0x9216, 0x921F, 0x9227, 0x922F, 0x9237, 0x9240, 0x9248, 0x9250, 0x9259, 0x9261, 0x9269, 0x9271, 0x927A, 0x9282, 0x928A, 0x9292, 0x929A, 0x92A3, 0x92AB, 0x92B3, 0x92BB, 0x92C3, 0x92CC, 0x92D4, 0x92DC, 0x92E4, 0x92EC, 0x92F4, 0x92FC, 0x9305, 0x930D, 0x9315, 0x931D, 0x9325, 0x932D, 0x9335, 0x933D, 0x9345, 0x934D, 0x9355, 0x935E, 0x9366, 0x936E, 0x9376, 0x937E, 0x9386, 0x938E, 0x9396, 0x939E, 0x93A6, 0x93AE, 0x93B6, 0x93BE, 0x93C6, 0x93CE, 0x93D6, 0x93DE, 0x93E6, 0x93ED, 0x93F5, 0x93FD, 0x9405, 0x940D, 0x9415, 0x941D, 0x9425, 0x942D, 0x9435, 0x943D, 0x9444, 0x944C, 0x9454, 0x945C, 0x9464, 0x946C, 0x9473, 0x947B, 0x9483, 0x948B, 0x9493, 0x949B, 0x94A2, 0x94AA, 0x94B2, 0x94BA, 0x94C1, 0x94C9, 0x94D1, 0x94D9, 0x94E0, 0x94E8, 0x94F0, 0x94F8, 0x94FF, 0x9507, 0x950F, 0x9516, 0x951E, 0x9526, 0x952D, 0x9535, 0x953D, 0x9544, 0x954C, 0x9554, 0x955B, 0x9563, 0x956B, 0x9572, 0x957A, 0x9581, 0x9589, 0x9591, 0x9598, 0x95A0, 0x95A7, 0x95AF, 0x95B7, 0x95BE, 0x95C6, 0x95CD, 0x95D5, 0x95DC, 0x95E4, 0x95EB, 0x95F3, 0x95FA, 0x9602, 0x9609, 0x9611, 0x9618, 0x9620, 0x9627, 0x962F, 0x9636, 0x963E, 0x9645, 0x964C, 0x9654, 0x965B, 0x9663, 0x966A, 0x9671, 0x9679, 0x9680, 0x9688, 0x968F, 0x9696, 0x969E, 0x96A5, 0x96AC, 0x96B4, 0x96BB, 0x96C2, 0x96CA, 0x96D1, 0x96D8, 0x96E0, 0x96E7, 0x96EE, 0x96F6, 0x96FD, 0x9704, 0x970B, 0x9713, 0x971A, 0x9721, 0x9728, 0x9730, 0x9737, 0x973E, 0x9745, 0x974C, 0x9754, 0x975B, 0x9762, 0x9769, 0x9770, 0x9778, 0x977F, 0x9786, 0x978D, 0x9794, 0x979B, 0x97A2, 0x97AA, 0x97B1, 0x97B8, 0x97BF, 0x97C6, 0x97CD, 0x97D4, 0x97DB, 0x97E2, 0x97E9, 0x97F0, 0x97F7, 0x97FE, 0x9806, 0x980D, 0x9814, 0x981B, 0x9822, 0x9829, 0x9830, 0x9837, 0x983E, 0x9845, 0x984C, 0x9853, 0x985A, 0x9860, 0x9867, 0x986E, 0x9875, 0x987C, 0x9883, 0x988A, 0x9891, 0x9898, 0x989F, 0x98A6, 0x98AD, 0x98B3, 0x98BA, 0x98C1, 0x98C8, 0x98CF, 0x98D6, 0x98DD, 0x98E3, 0x98EA, 0x98F1, 0x98F8, 0x98FF, 0x9906, 0x990C, 0x9913, 0x991A, 0x9921, 0x9928, 0x992E, 0x9935, 0x993C, 0x9943, 0x9949, 0x9950, 0x9957, 0x995D, 0x9964, 0x996B, 0x9972, 0x9978, 0x997F, 0x9986, 0x998C, 0x9993, 0x999A, 0x99A0, 0x99A7, 0x99AE, 0x99B4, 0x99BB, 0x99C2, 0x99C8, 0x99CF, 0x99D5, 0x99DC, 0x99E3, 0x99E9, 0x99F0, 0x99F6, 0x99FD, 0x9A04, 0x9A0A, 0x9A11, 0x9A17, 0x9A1E, 0x9A24, 0x9A2B, 0x9A31, 0x9A38, 0x9A3E, 0x9A45, 0x9A4B, 0x9A52, 0x9A58, 0x9A5F, 0x9A65, 0x9A6C, 0x9A72, 0x9A79, 0x9A7F, 0x9A86, 0x9A8C, 0x9A93, 0x9A99, 0x9A9F, 0x9AA6, 0x9AAC, 0x9AB3, 0x9AB9, 0x9AC0, 0x9AC6, 0x9ACC, 0x9AD3, 0x9AD9, 0x9ADF, 0x9AE6, 0x9AEC, 0x9AF2, 0x9AF9, 0x9AFF, 0x9B05, 0x9B0C, 0x9B12, 0x9B18, 0x9B1F, 0x9B25, 0x9B2B, 0x9B32, 0x9B38, 0x9B3E, 0x9B44, 0x9B4B, 0x9B51, 0x9B57, 0x9B5D, 0x9B64, 0x9B6A, 0x9B70, 0x9B76, 0x9B7D, 0x9B83, 0x9B89, 0x9B8F, 0x9B95, 0x9B9C, 0x9BA2, 0x9BA8, 0x9BAE, 0x9BB4, 0x9BBA, 0x9BC1, 0x9BC7, 0x9BCD, 0x9BD3, 0x9BD9, 0x9BDF, 0x9BE5, 0x9BEB, 0x9BF2, 0x9BF8, 0x9BFE, 0x9C04, 0x9C0A, 0x9C10, 0x9C16, 0x9C1C, 0x9C22, 0x9C28, 0x9C2E, 0x9C34, 0x9C3A, 0x9C40, 0x9C46, 0x9C4C, 0x9C52, 0x9C58, 0x9C5E, 0x9C64, 0x9C6A, 0x9C70, 0x9C76, 0x9C7C, 0x9C82, 0x9C88, 0x9C8E, 0x9C94, 0x9C9A, 0x9CA0, 0x9CA6, 0x9CAC, 0x9CB2, 0x9CB8, 0x9CBE, 0x9CC3, 0x9CC9, 0x9CCF, 0x9CD5, 0x9CDB, 0x9CE1, 0x9CE7, 0x9CED, 0x9CF3, 0x9CF8, 0x9CFE, 0x9D04, 0x9D0A, 0x9D10, 0x9D16, 0x9D1B, 0x9D21, 0x9D27, 0x9D2D, 0x9D33, 0x9D38, 0x9D3E, 0x9D44, 0x9D4A, 0x9D4F, 0x9D55, 0x9D5B, 0x9D61, 0x9D66, 0x9D6C, 0x9D72, 0x9D78, 0x9D7D, 0x9D83, 0x9D89, 0x9D8E, 0x9D94, 0x9D9A, 0x9DA0, 0x9DA5, 0x9DAB, 0x9DB1, 0x9DB6, 0x9DBC, 0x9DC2, 0x9DC7, 0x9DCD, 0x9DD3, 0x9DD8, 0x9DDE, 0x9DE3, 0x9DE9, 0x9DEF, 0x9DF4, 0x9DFA, 0x9DFF, 0x9E05, 0x9E0B, 0x9E10, 0x9E16, 0x9E1B, 0x9E21, 0x9E26, 0x9E2C, 0x9E32, 0x9E37, 0x9E3D, 0x9E42, 0x9E48, 0x9E4D, 0x9E53, 0x9E58, 0x9E5E, 0x9E63, 0x9E69, 0x9E6E, 0x9E74, 0x9E79, 0x9E7F, 0x9E84, 0x9E8A, 0x9E8F, 0x9E94, 0x9E9A, 0x9E9F, 0x9EA5, 0x9EAA, 0x9EB0, 0x9EB5, 0x9EBA, 0x9EC0, 0x9EC5, 0x9ECB, 0x9ED0, 0x9ED5, 0x9EDB, 0x9EE0, 0x9EE6, 0x9EEB, 0x9EF0, 0x9EF6, 0x9EFB, 0x9F00, 0x9F06, 0x9F0B, 0x9F10, 0x9F16, 0x9F1B, 0x9F20, 0x9F26, 0x9F2B, 0x9F30, 0x9F36, 0x9F3B, 0x9F40, 0x9F45, 0x9F4B, 0x9F50, 0x9F55, 0x9F5A, 0x9F60, 0x9F65, 0x9F6A, 0x9F6F, 0x9F75, 0x9F7A, 0x9F7F, 0x9F84, 0x9F8A, 0x9F8F, 0x9F94, 0x9F99, 0x9F9E, 0x9FA4, 0x9FA9, 0x9FAE, 0x9FB3, 0x9FB8, 0x9FBD, 0x9FC3, 0x9FC8, 0x9FCD, 0x9FD2, 0x9FD7, 0x9FDC, 0x9FE1, 0x9FE6, 0x9FEC, 0x9FF1, 0x9FF6, 0x9FFB, 0xA000, 0xA005, 0xA00A, 0xA00F, 0xA014, 0xA01A, 0xA01F, 0xA024, 0xA029, 0xA02E, 0xA033, 0xA038, 0xA03D, 0xA043, 0xA048, 0xA04D, 0xA052, 0xA057, 0xA05C, 0xA062, 0xA067, 0xA06C, 0xA071, 0xA076, 0xA07C, 0xA081, 0xA086, 0xA08B, 0xA091, 0xA096, 0xA09B, 0xA0A0, 0xA0A6, 0xA0AB, 0xA0B0, 0xA0B5, 0xA0BB, 0xA0C0, 0xA0C5, 0xA0CA, 0xA0D0, 0xA0D5, 0xA0DA, 0xA0E0, 0xA0E5, 0xA0EA, 0xA0F0, 0xA0F5, 0xA0FA, 0xA100, 0xA105, 0xA10A, 0xA110, 0xA115, 0xA11A, 0xA120, 0xA125, 0xA12B, 0xA130, 0xA135, 0xA13B, 0xA140, 0xA146, 0xA14B, 0xA150, 0xA156, 0xA15B, 0xA161, 0xA166, 0xA16C, 0xA171, 0xA176, 0xA17C, 0xA181, 0xA187, 0xA18C, 0xA192, 0xA197, 0xA19D, 0xA1A2, 0xA1A8, 0xA1AD, 0xA1B3, 0xA1B8, 0xA1BE, 0xA1C3, 0xA1C9, 0xA1CE, 0xA1D4, 0xA1DA, 0xA1DF, 0xA1E5, 0xA1EA, 0xA1F0, 0xA1F5, 0xA1FB, 0xA201, 0xA206, 0xA20C, 0xA211, 0xA217, 0xA21D, 0xA222, 0xA228, 0xA22D, 0xA233, 0xA239, 0xA23E, 0xA244, 0xA24A, 0xA24F, 0xA255, 0xA25B, 0xA260, 0xA266, 0xA26C, 0xA272, 0xA277, 0xA27D, 0xA283, 0xA288, 0xA28E, 0xA294, 0xA29A, 0xA29F, 0xA2A5, 0xA2AB, 0xA2B1, 0xA2B6, 0xA2BC, 0xA2C2, 0xA2C8, 0xA2CD, 0xA2D3, 0xA2D9, 0xA2DF, 0xA2E5, 0xA2EA, 0xA2F0, 0xA2F6, 0xA2FC, 0xA302, 0xA308, 0xA30D, 0xA313, 0xA319, 0xA31F, 0xA325, 0xA32B, 0xA331, 0xA337, 0xA33D, 0xA342, 0xA348, 0xA34E, 0xA354, 0xA35A, 0xA360, 0xA366, 0xA36C, 0xA372, 0xA378, 0xA37E, 0xA384, 0xA38A, 0xA390, 0xA396, 0xA39C, 0xA3A2, 0xA3A8, 0xA3AE, 0xA3B4, 0xA3BA, 0xA3C0, 0xA3C6, 0xA3CC, 0xA3D2, 0xA3D8, 0xA3DE, 0xA3E4, 0xA3EA, 0xA3F0, 0xA3F6, 0xA3FC, 0xA402, 0xA408, 0xA40E, 0xA415, 0xA41B, 0xA421, 0xA427, 0xA42D, 0xA433, 0xA439, 0xA43F, 0xA446, 0xA44C, 0xA452, 0xA458, 0xA45E, 0xA464, 0xA46B, 0xA471, 0xA477, 0xA47D, 0xA483, 0xA48A, 0xA490, 0xA496, 0xA49C, 0xA4A3, 0xA4A9, 0xA4AF, 0xA4B5, 0xA4BC, 0xA4C2, 0xA4C8, 0xA4CE, 0xA4D5, 0xA4DB, 0xA4E1, 0xA4E8, 0xA4EE, 0xA4F4, 0xA4FB, 0xA501, 0xA507, 0xA50E, 0xA514, 0xA51A, 0xA521, 0xA527, 0xA52D, 0xA534, 0xA53A, 0xA540, 0xA547, 0xA54D, 0xA554, 0xA55A, 0xA561, 0xA567, 0xA56D, 0xA574, 0xA57A, 0xA581, 0xA587, 0xA58E, 0xA594, 0xA59B, 0xA5A1, 0xA5A8, 0xA5AE, 0xA5B5, 0xA5BB, 0xA5C2, 0xA5C8, 0xA5CF, 0xA5D5, 0xA5DC, 0xA5E2, 0xA5E9, 0xA5EF, 0xA5F6, 0xA5FC, 0xA603, 0xA60A, 0xA610, 0xA617, 0xA61D, 0xA624, 0xA62B, 0xA631, 0xA638, 0xA63E, 0xA645, 0xA64C, 0xA652, 0xA659, 0xA660, 0xA666, 0xA66D, 0xA674, 0xA67A, 0xA681, 0xA688, 0xA68E, 0xA695, 0xA69C, 0xA6A3, 0xA6A9, 0xA6B0, 0xA6B7, 0xA6BD, 0xA6C4, 0xA6CB, 0xA6D2, 0xA6D8, 0xA6DF, 0xA6E6, 0xA6ED, 0xA6F4, 0xA6FA, 0xA701, 0xA708, 0xA70F, 0xA716, 0xA71D, 0xA723, 0xA72A, 0xA731, 0xA738, 0xA73F, 0xA746, 0xA74D, 0xA753, 0xA75A, 0xA761, 0xA768, 0xA76F, 0xA776, 0xA77D, 0xA784, 0xA78B, 0xA792, 0xA799, 0xA7A0, 0xA7A6, 0xA7AD, 0xA7B4, 0xA7BB, 0xA7C2, 0xA7C9, 0xA7D0, 0xA7D7, 0xA7DE, 0xA7E5, 0xA7EC, 0xA7F3, 0xA7FA, 0xA802, 0xA809, 0xA810, 0xA817, 0xA81E, 0xA825, 0xA82C, 0xA833, 0xA83A, 0xA841, 0xA848, 0xA84F, 0xA856, 0xA85E, 0xA865, 0xA86C, 0xA873, 0xA87A, 0xA881, 0xA888, 0xA890, 0xA897, 0xA89E, 0xA8A5, 0xA8AC, 0xA8B4, 0xA8BB, 0xA8C2, 0xA8C9, 0xA8D0, 0xA8D8, 0xA8DF, 0xA8E6, 0xA8ED, 0xA8F5, 0xA8FC, 0xA903, 0xA90A, 0xA912, 0xA919, 0xA920, 0xA928, 0xA92F, 0xA936, 0xA93E, 0xA945, 0xA94C, 0xA954, 0xA95B, 0xA962, 0xA96A, 0xA971, 0xA978, 0xA980, 0xA987, 0xA98F, 0xA996, 0xA99D, 0xA9A5, 0xA9AC, 0xA9B4, 0xA9BB, 0xA9C2, 0xA9CA, 0xA9D1, 0xA9D9, 0xA9E0, 0xA9E8, 0xA9EF, 0xA9F7, 0xA9FE, 0xAA06, 0xAA0D, 0xAA15, 0xAA1C, 0xAA24, 0xAA2B, 0xAA33, 0xAA3A, 0xAA42, 0xAA49, 0xAA51, 0xAA59, 0xAA60, 0xAA68, 0xAA6F, 0xAA77, 0xAA7F, 0xAA86, 0xAA8E, 0xAA95, 0xAA9D, 0xAAA5, 0xAAAC, 0xAAB4, 0xAABC, 0xAAC3, 0xAACB, 0xAAD3, 0xAADA, 0xAAE2, 0xAAEA, 0xAAF1, 0xAAF9, 0xAB01, 0xAB08, 0xAB10, 0xAB18, 0xAB20, 0xAB27, 0xAB2F, 0xAB37, 0xAB3F, 0xAB46, 0xAB4E, 0xAB56, 0xAB5E, 0xAB65, 0xAB6D, 0xAB75, 0xAB7D, 0xAB85, 0xAB8D, 0xAB94, 0xAB9C, 0xABA4, 0xABAC, 0xABB4, 0xABBC, 0xABC3, 0xABCB, 0xABD3, 0xABDB, 0xABE3, 0xABEB, 0xABF3, 0xABFB, 0xAC03, 0xAC0B, 0xAC13, 0xAC1A, 0xAC22, 0xAC2A, 0xAC32, 0xAC3A, 0xAC42, 0xAC4A, 0xAC52, 0xAC5A, 0xAC62, 0xAC6A, 0xAC72, 0xAC7A, 0xAC82, 0xAC8A, 0xAC92, 0xAC9A, 0xACA2, 0xACAB, 0xACB3, 0xACBB, 0xACC3, 0xACCB, 0xACD3, 0xACDB, 0xACE3, 0xACEB, 0xACF3, 0xACFB, 0xAD04, 0xAD0C, 0xAD14, 0xAD1C, 0xAD24, 0xAD2C, 0xAD34, 0xAD3D, 0xAD45, 0xAD4D, 0xAD55, 0xAD5D, 0xAD66, 0xAD6E, 0xAD76, 0xAD7E, 0xAD86, 0xAD8F, 0xAD97, 0xAD9F, 0xADA7, 0xADB0, 0xADB8, 0xADC0, 0xADC9, 0xADD1, 0xADD9, 0xADE1, 0xADEA, 0xADF2, 0xADFA, 0xAE03, 0xAE0B, 0xAE13, 0xAE1C, 0xAE24, 0xAE2C, 0xAE35, 0xAE3D, 0xAE45, 0xAE4E, 0xAE56, 0xAE5F, 0xAE67, 0xAE6F, 0xAE78, 0xAE80, 0xAE89, 0xAE91, 0xAE9A, 0xAEA2, 0xAEAA, 0xAEB3, 0xAEBB, 0xAEC4, 0xAECC, 0xAED5, 0xAEDD, 0xAEE6, 0xAEEE, 0xAEF7, 0xAEFF, 0xAF08, 0xAF10, 0xAF19, 0xAF21, 0xAF2A, 0xAF32, 0xAF3B, 0xAF44, 0xAF4C, 0xAF55, 0xAF5D, 0xAF66, 0xAF6E, 0xAF77, 0xAF80, 0xAF88, 0xAF91, 0xAF99, 0xAFA2, 0xAFAB, 0xAFB3, 0xAFBC, 0xAFC5, 0xAFCD, 0xAFD6, 0xAFDF, 0xAFE7, 0xAFF0, 0xAFF9, 0xB001, 0xB00A, 0xB013, 0xB01B, 0xB024, 0xB02D, 0xB036, 0xB03E, 0xB047, 0xB050, 0xB059, 0xB061, 0xB06A, 0xB073, 0xB07C, 0xB084, 0xB08D, 0xB096, 0xB09F, 0xB0A8, 0xB0B0, 0xB0B9, 0xB0C2, 0xB0CB, 0xB0D4, 0xB0DD, 0xB0E5, 0xB0EE, 0xB0F7, 0xB100, 0xB109, 0xB112, 0xB11B, 0xB124, 0xB12C, 0xB135, 0xB13E, 0xB147, 0xB150, 0xB159, 0xB162, 0xB16B, 0xB174, 0xB17D, 0xB186, 0xB18F, 0xB198, 0xB1A1, 0xB1AA, 0xB1B2, 0xB1BB, 0xB1C4, 0xB1CD, 0xB1D6, 0xB1DF, 0xB1E8, 0xB1F1, 0xB1FB, 0xB204, 0xB20D, 0xB216, 0xB21F, 0xB228, 0xB231, 0xB23A, 0xB243, 0xB24C, 0xB255, 0xB25E, 0xB267, 0xB270, 0xB279, 0xB283, 0xB28C, 0xB295, 0xB29E, 0xB2A7, 0xB2B0, 0xB2B9, 0xB2C2, 0xB2CC, 0xB2D5, 0xB2DE, 0xB2E7, 0xB2F0, 0xB2F9, 0xB303, 0xB30C, 0xB315, 0xB31E, 0xB327, 0xB331, 0xB33A, 0xB343, 0xB34C, 0xB355, 0xB35F, 0xB368, 0xB371, 0xB37A, 0xB384, 0xB38D, 0xB396, 0xB3A0, 0xB3A9, 0xB3B2, 0xB3BB, 0xB3C5, 0xB3CE, 0xB3D7, 0xB3E1, 0xB3EA, 0xB3F3, 0xB3FD, 0xB406, 0xB40F, 0xB419, 0xB422, 0xB42B, 0xB435, 0xB43E, 0xB447, 0xB451, 0xB45A, 0xB463, 0xB46D, 0xB476, 0xB480, 0xB489, 0xB492, 0xB49C, 0xB4A5, 0xB4AF, 0xB4B8, 0xB4C1, 0xB4CB, 0xB4D4, 0xB4DE, 0xB4E7, 0xB4F1, 0xB4FA, 0xB504, 0xB50D, 0xB517, 0xB520, 0xB529, 0xB533, 0xB53C, 0xB546, 0xB54F, 0xB559, 0xB562, 0xB56C, 0xB575, 0xB57F, 0xB589, 0xB592, 0xB59C, 0xB5A5, 0xB5AF, 0xB5B8, 0xB5C2, 0xB5CB, 0xB5D5, 0xB5DE, 0xB5E8, 0xB5F2, 0xB5FB, 0xB605, 0xB60E, 0xB618, 0xB622, 0xB62B, 0xB635, 0xB63E, 0xB648, 0xB652, 0xB65B, 0xB665, 0xB66E, 0xB678, 0xB682, 0xB68B, 0xB695, 0xB69F, 0xB6A8, 0xB6B2, 0xB6BC, 0xB6C5, 0xB6CF, 0xB6D9, 0xB6E2, 0xB6EC, 0xB6F6, 0xB6FF, 0xB709, 0xB713, 0xB71D, 0xB726, 0xB730, 0xB73A, 0xB743, 0xB74D, 0xB757, 0xB761, 0xB76A, 0xB774, 0xB77E, 0xB788, 0xB791, 0xB79B, 0xB7A5, 0xB7AF, 0xB7B8, 0xB7C2, 0xB7CC, 0xB7D6, 0xB7E0, 0xB7E9, 0xB7F3, 0xB7FD, 0xB807, 0xB811, 0xB81A, 0xB824, 0xB82E, 0xB838, 0xB842, 0xB84B, 0xB855, 0xB85F, 0xB869, 0xB873, 0xB87D, 0xB886, 0xB890, 0xB89A, 0xB8A4, 0xB8AE, 0xB8B8, 0xB8C2, 0xB8CB, 0xB8D5, 0xB8DF, 0xB8E9, 0xB8F3, 0xB8FD, 0xB907, 0xB911, 0xB91B, 0xB924, 0xB92E, 0xB938, 0xB942, 0xB94C, 0xB956, 0xB960, 0xB96A, 0xB974, 0xB97E, 0xB988, 0xB992, 0xB99B, 0xB9A5, 0xB9AF, 0xB9B9, 0xB9C3, 0xB9CD, 0xB9D7, 0xB9E1, 0xB9EB, 0xB9F5, 0xB9FF, 0xBA09, 0xBA13, 0xBA1D, 0xBA27, 0xBA31, 0xBA3B, 0xBA45, 0xBA4F, 0xBA59, 0xBA63, 0xBA6D, 0xBA77, 0xBA81, 0xBA8B, 0xBA95, 0xBA9F, 0xBAA9, 0xBAB3, 0xBABD, 0xBAC7, 0xBAD1, 0xBADB, 0xBAE5, 0xBAEF, 0xBAF9, 0xBB03, 0xBB0D, 0xBB17, 0xBB21, 0xBB2B, 0xBB35, 0xBB3F, 0xBB49, 0xBB53, 0xBB5D, 0xBB67, 0xBB72, 0xBB7C, 0xBB86, 0xBB90, 0xBB9A, 0xBBA4, 0xBBAE, 0xBBB8, 0xBBC2, 0xBBCC, 0xBBD6, 0xBBE0, 0xBBEA, 0xBBF4, 0xBBFF, 0xBC09, 0xBC13, 0xBC1D, 0xBC27, 0xBC31, 0xBC3B, 0xBC45, 0xBC4F, 0xBC59, 0xBC64, 0xBC6E, 0xBC78, 0xBC82, 0xBC8C, 0xBC96, 0xBCA0, 0xBCAA, 0xBCB4, 0xBCBF, 0xBCC9, 0xBCD3, 0xBCDD, 0xBCE7, 0xBCF1, 0xBCFB, 0xBD05, 0xBD10, 0xBD1A, 0xBD24, 0xBD2E, 0xBD38, 0xBD42, 0xBD4C, 0xBD57, 0xBD61, 0xBD6B, 0xBD75, 0xBD7F, 0xBD89, 0xBD93, 0xBD9E, 0xBDA8, 0xBDB2, 0xBDBC, 0xBDC6, 0xBDD0, 0xBDDA, 0xBDE5, 0xBDEF, 0xBDF9, 0xBE03, 0xBE0D, 0xBE17, 0xBE22, 0xBE2C, 0xBE36, 0xBE40, 0xBE4A, 0xBE54, 0xBE5F, 0xBE69, 0xBE73, 0xBE7D, 0xBE87, 0xBE91, 0xBE9C, 0xBEA6, 0xBEB0, 0xBEBA, 0xBEC4, 0xBECF, 0xBED9, 0xBEE3, 0xBEED, 0xBEF7, 0xBF01, 0xBF0C, 0xBF16, 0xBF20, 0xBF2A, 0xBF34, 0xBF3E, 0xBF49, 0xBF53, 0xBF5D, 0xBF67, 0xBF71, 0xBF7C, 0xBF86, 0xBF90, 0xBF9A, 0xBFA4, 0xBFAF, 0xBFB9, 0xBFC3, 0xBFCD, 0xBFD7, 0xBFE1, 0xBFEC, 0xBFF6, 0xC000, 0xC00A, 0xC014, 0xC01F, 0xC029, 0xC033, 0xC03D, 0xC047, 0xC051, 0xC05C, 0xC066, 0xC070, 0xC07A, 0xC084, 0xC08F, 0xC099, 0xC0A3, 0xC0AD, 0xC0B7, 0xC0C2, 0xC0CC, 0xC0D6, 0xC0E0, 0xC0EA, 0xC0F4, 0xC0FF, 0xC109, 0xC113, 0xC11D, 0xC127, 0xC131, 0xC13C, 0xC146, 0xC150, 0xC15A, 0xC164, 0xC16F, 0xC179, 0xC183, 0xC18D, 0xC197, 0xC1A1, 0xC1AC, 0xC1B6, 0xC1C0, 0xC1CA, 0xC1D4, 0xC1DE, 0xC1E9, 0xC1F3, 0xC1FD, 0xC207, 0xC211, 0xC21B, 0xC226, 0xC230, 0xC23A, 0xC244, 0xC24E, 0xC258, 0xC262, 0xC26D, 0xC277, 0xC281, 0xC28B, 0xC295, 0xC29F, 0xC2A9, 0xC2B4, 0xC2BE, 0xC2C8, 0xC2D2, 0xC2DC, 0xC2E6, 0xC2F0, 0xC2FB, 0xC305, 0xC30F, 0xC319, 0xC323, 0xC32D, 0xC337, 0xC341, 0xC34C, 0xC356, 0xC360, 0xC36A, 0xC374, 0xC37E, 0xC388, 0xC392, 0xC39C, 0xC3A7, 0xC3B1, 0xC3BB, 0xC3C5, 0xC3CF, 0xC3D9, 0xC3E3, 0xC3ED, 0xC3F7, 0xC401, 0xC40C, 0xC416, 0xC420, 0xC42A, 0xC434, 0xC43E, 0xC448, 0xC452, 0xC45C, 0xC466, 0xC470, 0xC47A, 0xC484, 0xC48E, 0xC499, 0xC4A3, 0xC4AD, 0xC4B7, 0xC4C1, 0xC4CB, 0xC4D5, 0xC4DF, 0xC4E9, 0xC4F3, 0xC4FD, 0xC507, 0xC511, 0xC51B, 0xC525, 0xC52F, 0xC539, 0xC543, 0xC54D, 0xC557, 0xC561, 0xC56B, 0xC575, 0xC57F, 0xC589, 0xC593, 0xC59D, 0xC5A7, 0xC5B1, 0xC5BB, 0xC5C5, 0xC5CF, 0xC5D9, 0xC5E3, 0xC5ED, 0xC5F7, 0xC601, 0xC60B, 0xC615, 0xC61F, 0xC629, 0xC633, 0xC63D, 0xC647, 0xC651, 0xC65B, 0xC665, 0xC66E, 0xC678, 0xC682, 0xC68C, 0xC696, 0xC6A0, 0xC6AA, 0xC6B4, 0xC6BE, 0xC6C8, 0xC6D2, 0xC6DC, 0xC6E5, 0xC6EF, 0xC6F9, 0xC703, 0xC70D, 0xC717, 0xC721, 0xC72B, 0xC735, 0xC73E, 0xC748, 0xC752, 0xC75C, 0xC766, 0xC770, 0xC77A, 0xC783, 0xC78D, 0xC797, 0xC7A1, 0xC7AB, 0xC7B5, 0xC7BE, 0xC7C8, 0xC7D2, 0xC7DC, 0xC7E6, 0xC7EF, 0xC7F9, 0xC803, 0xC80D, 0xC817, 0xC820, 0xC82A, 0xC834, 0xC83E, 0xC848, 0xC851, 0xC85B, 0xC865, 0xC86F, 0xC878, 0xC882, 0xC88C, 0xC896, 0xC89F, 0xC8A9, 0xC8B3, 0xC8BD, 0xC8C6, 0xC8D0, 0xC8DA, 0xC8E3, 0xC8ED, 0xC8F7, 0xC901, 0xC90A, 0xC914, 0xC91E, 0xC927, 0xC931, 0xC93B, 0xC944, 0xC94E, 0xC958, 0xC961, 0xC96B, 0xC975, 0xC97E, 0xC988, 0xC992, 0xC99B, 0xC9A5, 0xC9AE, 0xC9B8, 0xC9C2, 0xC9CB, 0xC9D5, 0xC9DE, 0xC9E8, 0xC9F2, 0xC9FB, 0xCA05, 0xCA0E, 0xCA18, 0xCA22, 0xCA2B, 0xCA35, 0xCA3E, 0xCA48, 0xCA51, 0xCA5B, 0xCA64, 0xCA6E, 0xCA77, 0xCA81, 0xCA8B, 0xCA94, 0xCA9E, 0xCAA7, 0xCAB1, 0xCABA, 0xCAC4, 0xCACD, 0xCAD7, 0xCAE0, 0xCAE9, 0xCAF3, 0xCAFC, 0xCB06, 0xCB0F, 0xCB19, 0xCB22, 0xCB2C, 0xCB35, 0xCB3F, 0xCB48, 0xCB51, 0xCB5B, 0xCB64, 0xCB6E, 0xCB77, 0xCB80, 0xCB8A, 0xCB93, 0xCB9D, 0xCBA6, 0xCBAF, 0xCBB9, 0xCBC2, 0xCBCB, 0xCBD5, 0xCBDE, 0xCBE7, 0xCBF1, 0xCBFA, 0xCC03, 0xCC0D, 0xCC16, 0xCC1F, 0xCC29, 0xCC32, 0xCC3B, 0xCC45, 0xCC4E, 0xCC57, 0xCC60, 0xCC6A, 0xCC73, 0xCC7C, 0xCC86, 0xCC8F, 0xCC98, 0xCCA1, 0xCCAB, 0xCCB4, 0xCCBD, 0xCCC6, 0xCCCF, 0xCCD9, 0xCCE2, 0xCCEB, 0xCCF4, 0xCCFD, 0xCD07, 0xCD10, 0xCD19, 0xCD22, 0xCD2B, 0xCD34, 0xCD3E, 0xCD47, 0xCD50, 0xCD59, 0xCD62, 0xCD6B, 0xCD74, 0xCD7D, 0xCD87, 0xCD90, 0xCD99, 0xCDA2, 0xCDAB, 0xCDB4, 0xCDBD, 0xCDC6, 0xCDCF, 0xCDD8, 0xCDE1, 0xCDEA, 0xCDF3, 0xCDFC, 0xCE05, 0xCE0F, 0xCE18, 0xCE21, 0xCE2A, 0xCE33, 0xCE3C, 0xCE45, 0xCE4E, 0xCE56, 0xCE5F, 0xCE68, 0xCE71, 0xCE7A, 0xCE83, 0xCE8C, 0xCE95, 0xCE9E, 0xCEA7, 0xCEB0, 0xCEB9, 0xCEC2, 0xCECB, 0xCED4, 0xCEDC, 0xCEE5, 0xCEEE, 0xCEF7, 0xCF00, 0xCF09, 0xCF12, 0xCF1B, 0xCF23, 0xCF2C, 0xCF35, 0xCF3E, 0xCF47, 0xCF50, 0xCF58, 0xCF61, 0xCF6A, 0xCF73, 0xCF7C, 0xCF84, 0xCF8D, 0xCF96, 0xCF9F, 0xCFA7, 0xCFB0, 0xCFB9, 0xCFC2, 0xCFCA, 0xCFD3, 0xCFDC, 0xCFE5, 0xCFED, 0xCFF6, 0xCFFF, 0xD007, 0xD010, 0xD019, 0xD021, 0xD02A, 0xD033, 0xD03B, 0xD044, 0xD04D, 0xD055, 0xD05E, 0xD067, 0xD06F, 0xD078, 0xD080, 0xD089, 0xD092, 0xD09A, 0xD0A3, 0xD0AB, 0xD0B4, 0xD0BC, 0xD0C5, 0xD0CE, 0xD0D6, 0xD0DF, 0xD0E7, 0xD0F0, 0xD0F8, 0xD101, 0xD109, 0xD112, 0xD11A, 0xD123, 0xD12B, 0xD134, 0xD13C, 0xD145, 0xD14D, 0xD156, 0xD15E, 0xD166, 0xD16F, 0xD177, 0xD180, 0xD188, 0xD191, 0xD199, 0xD1A1, 0xD1AA, 0xD1B2, 0xD1BB, 0xD1C3, 0xD1CB, 0xD1D4, 0xD1DC, 0xD1E4, 0xD1ED, 0xD1F5, 0xD1FD, 0xD206, 0xD20E, 0xD216, 0xD21F, 0xD227, 0xD22F, 0xD237, 0xD240, 0xD248, 0xD250, 0xD259, 0xD261, 0xD269, 0xD271, 0xD27A, 0xD282, 0xD28A, 0xD292, 0xD29A, 0xD2A3, 0xD2AB, 0xD2B3, 0xD2BB, 0xD2C3, 0xD2CC, 0xD2D4, 0xD2DC, 0xD2E4, 0xD2EC, 0xD2F4, 0xD2FC, 0xD305, 0xD30D, 0xD315, 0xD31D, 0xD325, 0xD32D, 0xD335, 0xD33D, 0xD345, 0xD34D, 0xD355, 0xD35E, 0xD366, 0xD36E, 0xD376, 0xD37E, 0xD386, 0xD38E, 0xD396, 0xD39E, 0xD3A6, 0xD3AE, 0xD3B6, 0xD3BE, 0xD3C6, 0xD3CE, 0xD3D6, 0xD3DE, 0xD3E6, 0xD3ED, 0xD3F5, 0xD3FD, 0xD405, 0xD40D, 0xD415, 0xD41D, 0xD425, 0xD42D, 0xD435, 0xD43D, 0xD444, 0xD44C, 0xD454, 0xD45C, 0xD464, 0xD46C, 0xD473, 0xD47B, 0xD483, 0xD48B, 0xD493, 0xD49B, 0xD4A2, 0xD4AA, 0xD4B2, 0xD4BA, 0xD4C1, 0xD4C9, 0xD4D1, 0xD4D9, 0xD4E0, 0xD4E8, 0xD4F0, 0xD4F8, 0xD4FF, 0xD507, 0xD50F, 0xD516, 0xD51E, 0xD526, 0xD52D, 0xD535, 0xD53D, 0xD544, 0xD54C, 0xD554, 0xD55B, 0xD563, 0xD56B, 0xD572, 0xD57A, 0xD581, 0xD589, 0xD591, 0xD598, 0xD5A0, 0xD5A7, 0xD5AF, 0xD5B7, 0xD5BE, 0xD5C6, 0xD5CD, 0xD5D5, 0xD5DC, 0xD5E4, 0xD5EB, 0xD5F3, 0xD5FA, 0xD602, 0xD609, 0xD611, 0xD618, 0xD620, 0xD627, 0xD62F, 0xD636, 0xD63E, 0xD645, 0xD64C, 0xD654, 0xD65B, 0xD663, 0xD66A, 0xD671, 0xD679, 0xD680, 0xD688, 0xD68F, 0xD696, 0xD69E, 0xD6A5, 0xD6AC, 0xD6B4, 0xD6BB, 0xD6C2, 0xD6CA, 0xD6D1, 0xD6D8, 0xD6E0, 0xD6E7, 0xD6EE, 0xD6F6, 0xD6FD, 0xD704, 0xD70B, 0xD713, 0xD71A, 0xD721, 0xD728, 0xD730, 0xD737, 0xD73E, 0xD745, 0xD74C, 0xD754, 0xD75B, 0xD762, 0xD769, 0xD770, 0xD778, 0xD77F, 0xD786, 0xD78D, 0xD794, 0xD79B, 0xD7A2, 0xD7AA, 0xD7B1, 0xD7B8, 0xD7BF, 0xD7C6, 0xD7CD, 0xD7D4, 0xD7DB, 0xD7E2, 0xD7E9, 0xD7F0, 0xD7F7, 0xD7FE, 0xD806, 0xD80D, 0xD814, 0xD81B, 0xD822, 0xD829, 0xD830, 0xD837, 0xD83E, 0xD845, 0xD84C, 0xD853, 0xD85A, 0xD860, 0xD867, 0xD86E, 0xD875, 0xD87C, 0xD883, 0xD88A, 0xD891, 0xD898, 0xD89F, 0xD8A6, 0xD8AD, 0xD8B3, 0xD8BA, 0xD8C1, 0xD8C8, 0xD8CF, 0xD8D6, 0xD8DD, 0xD8E3, 0xD8EA, 0xD8F1, 0xD8F8, 0xD8FF, 0xD906, 0xD90C, 0xD913, 0xD91A, 0xD921, 0xD928, 0xD92E, 0xD935, 0xD93C, 0xD943, 0xD949, 0xD950, 0xD957, 0xD95D, 0xD964, 0xD96B, 0xD972, 0xD978, 0xD97F, 0xD986, 0xD98C, 0xD993, 0xD99A, 0xD9A0, 0xD9A7, 0xD9AE, 0xD9B4, 0xD9BB, 0xD9C2, 0xD9C8, 0xD9CF, 0xD9D5, 0xD9DC, 0xD9E3, 0xD9E9, 0xD9F0, 0xD9F6, 0xD9FD, 0xDA04, 0xDA0A, 0xDA11, 0xDA17, 0xDA1E, 0xDA24, 0xDA2B, 0xDA31, 0xDA38, 0xDA3E, 0xDA45, 0xDA4B, 0xDA52, 0xDA58, 0xDA5F, 0xDA65, 0xDA6C, 0xDA72, 0xDA79, 0xDA7F, 0xDA86, 0xDA8C, 0xDA93, 0xDA99, 0xDA9F, 0xDAA6, 0xDAAC, 0xDAB3, 0xDAB9, 0xDAC0, 0xDAC6, 0xDACC, 0xDAD3, 0xDAD9, 0xDADF, 0xDAE6, 0xDAEC, 0xDAF2, 0xDAF9, 0xDAFF, 0xDB05, 0xDB0C, 0xDB12, 0xDB18, 0xDB1F, 0xDB25, 0xDB2B, 0xDB32, 0xDB38, 0xDB3E, 0xDB44, 0xDB4B, 0xDB51, 0xDB57, 0xDB5D, 0xDB64, 0xDB6A, 0xDB70, 0xDB76, 0xDB7D, 0xDB83, 0xDB89, 0xDB8F, 0xDB95, 0xDB9C, 0xDBA2, 0xDBA8, 0xDBAE, 0xDBB4, 0xDBBA, 0xDBC1, 0xDBC7, 0xDBCD, 0xDBD3, 0xDBD9, 0xDBDF, 0xDBE5, 0xDBEB, 0xDBF2, 0xDBF8, 0xDBFE, 0xDC04, 0xDC0A, 0xDC10, 0xDC16, 0xDC1C, 0xDC22, 0xDC28, 0xDC2E, 0xDC34, 0xDC3A, 0xDC40, 0xDC46, 0xDC4C, 0xDC52, 0xDC58, 0xDC5E, 0xDC64, 0xDC6A, 0xDC70, 0xDC76, 0xDC7C, 0xDC82, 0xDC88, 0xDC8E, 0xDC94, 0xDC9A, 0xDCA0, 0xDCA6, 0xDCAC, 0xDCB2, 0xDCB8, 0xDCBE, 0xDCC3, 0xDCC9, 0xDCCF, 0xDCD5, 0xDCDB, 0xDCE1, 0xDCE7, 0xDCED, 0xDCF3, 0xDCF8, 0xDCFE, 0xDD04, 0xDD0A, 0xDD10, 0xDD16, 0xDD1B, 0xDD21, 0xDD27, 0xDD2D, 0xDD33, 0xDD38, 0xDD3E, 0xDD44, 0xDD4A, 0xDD4F, 0xDD55, 0xDD5B, 0xDD61, 0xDD66, 0xDD6C, 0xDD72, 0xDD78, 0xDD7D, 0xDD83, 0xDD89, 0xDD8E, 0xDD94, 0xDD9A, 0xDDA0, 0xDDA5, 0xDDAB, 0xDDB1, 0xDDB6, 0xDDBC, 0xDDC2, 0xDDC7, 0xDDCD, 0xDDD3, 0xDDD8, 0xDDDE, 0xDDE3, 0xDDE9, 0xDDEF, 0xDDF4, 0xDDFA, 0xDDFF, 0xDE05, 0xDE0B, 0xDE10, 0xDE16, 0xDE1B, 0xDE21, 0xDE26, 0xDE2C, 0xDE32, 0xDE37, 0xDE3D, 0xDE42, 0xDE48, 0xDE4D, 0xDE53, 0xDE58, 0xDE5E, 0xDE63, 0xDE69, 0xDE6E, 0xDE74, 0xDE79, 0xDE7F, 0xDE84, 0xDE8A, 0xDE8F, 0xDE94, 0xDE9A, 0xDE9F, 0xDEA5, 0xDEAA, 0xDEB0, 0xDEB5, 0xDEBA, 0xDEC0, 0xDEC5, 0xDECB, 0xDED0, 0xDED5, 0xDEDB, 0xDEE0, 0xDEE6, 0xDEEB, 0xDEF0, 0xDEF6, 0xDEFB, 0xDF00, 0xDF06, 0xDF0B, 0xDF10, 0xDF16, 0xDF1B, 0xDF20, 0xDF26, 0xDF2B, 0xDF30, 0xDF36, 0xDF3B, 0xDF40, 0xDF45, 0xDF4B, 0xDF50, 0xDF55, 0xDF5A, 0xDF60, 0xDF65, 0xDF6A, 0xDF6F, 0xDF75, 0xDF7A, 0xDF7F, 0xDF84, 0xDF8A, 0xDF8F, 0xDF94, 0xDF99, 0xDF9E, 0xDFA4, 0xDFA9, 0xDFAE, 0xDFB3, 0xDFB8, 0xDFBD, 0xDFC3, 0xDFC8, 0xDFCD, 0xDFD2, 0xDFD7, 0xDFDC, 0xDFE1, 0xDFE6, 0xDFEC, 0xDFF1, 0xDFF6, 0xDFFB, -0x2000, -0x1FFB, -0x1FF6, -0x1FF1, -0x1FEC, -0x1FE6, -0x1FE1, -0x1FDC, -0x1FD7, -0x1FD2, -0x1FCD, -0x1FC8, -0x1FC3, -0x1FBD, -0x1FB8, -0x1FB3, -0x1FAE, -0x1FA9, -0x1FA4, -0x1F9E, -0x1F99, -0x1F94, -0x1F8F, -0x1F8A, -0x1F84, -0x1F7F, -0x1F7A, -0x1F75, -0x1F6F, -0x1F6A, -0x1F65, -0x1F60, -0x1F5A, -0x1F55, -0x1F50, -0x1F4B, -0x1F45, -0x1F40, -0x1F3B, -0x1F36, -0x1F30, -0x1F2B, -0x1F26, -0x1F20, -0x1F1B, -0x1F16, -0x1F10, -0x1F0B, -0x1F06, -0x1F00, -0x1EFB, -0x1EF6, -0x1EF0, -0x1EEB, -0x1EE6, -0x1EE0, -0x1EDB, -0x1ED5, -0x1ED0, -0x1ECB, -0x1EC5, -0x1EC0, -0x1EBA, -0x1EB5, -0x1EB0, -0x1EAA, -0x1EA5, -0x1E9F, -0x1E9A, -0x1E94, -0x1E8F, -0x1E8A, -0x1E84, -0x1E7F, -0x1E79, -0x1E74, -0x1E6E, -0x1E69, -0x1E63, -0x1E5E, -0x1E58, -0x1E53, -0x1E4D, -0x1E48, -0x1E42, -0x1E3D, -0x1E37, -0x1E32, -0x1E2C, -0x1E26, -0x1E21, -0x1E1B, -0x1E16, -0x1E10, -0x1E0B, -0x1E05, -0x1DFF, -0x1DFA, -0x1DF4, -0x1DEF, -0x1DE9, -0x1DE3, -0x1DDE, -0x1DD8, -0x1DD3, -0x1DCD, -0x1DC7, -0x1DC2, -0x1DBC, -0x1DB6, -0x1DB1, -0x1DAB, -0x1DA5, -0x1DA0, -0x1D9A, -0x1D94, -0x1D8E, -0x1D89, -0x1D83, -0x1D7D, -0x1D78, -0x1D72, -0x1D6C, -0x1D66, -0x1D61, -0x1D5B, -0x1D55, -0x1D4F, -0x1D4A, -0x1D44, -0x1D3E, -0x1D38, -0x1D33, -0x1D2D, -0x1D27, -0x1D21, -0x1D1B, -0x1D16, -0x1D10, -0x1D0A, -0x1D04, -0x1CFE, -0x1CF8, -0x1CF3, -0x1CED, -0x1CE7, -0x1CE1, -0x1CDB, -0x1CD5, -0x1CCF, -0x1CC9, -0x1CC3, -0x1CBE, -0x1CB8, -0x1CB2, -0x1CAC, -0x1CA6, -0x1CA0, -0x1C9A, -0x1C94, -0x1C8E, -0x1C88, -0x1C82, -0x1C7C, -0x1C76, -0x1C70, -0x1C6A, -0x1C64, -0x1C5E, -0x1C58, -0x1C52, -0x1C4C, -0x1C46, -0x1C40, -0x1C3A, -0x1C34, -0x1C2E, -0x1C28, -0x1C22, -0x1C1C, -0x1C16, -0x1C10, -0x1C0A, -0x1C04, -0x1BFE, -0x1BF8, -0x1BF2, -0x1BEB, -0x1BE5, -0x1BDF, -0x1BD9, -0x1BD3, -0x1BCD, -0x1BC7, -0x1BC1, -0x1BBA, -0x1BB4, -0x1BAE, -0x1BA8, -0x1BA2, -0x1B9C, -0x1B95, -0x1B8F, -0x1B89, -0x1B83, -0x1B7D, -0x1B76, -0x1B70, -0x1B6A, -0x1B64, -0x1B5D, -0x1B57, -0x1B51, -0x1B4B, -0x1B44, -0x1B3E, -0x1B38, -0x1B32, -0x1B2B, -0x1B25, -0x1B1F, -0x1B18, -0x1B12, -0x1B0C, -0x1B05, -0x1AFF, -0x1AF9, -0x1AF2, -0x1AEC, -0x1AE6, -0x1ADF, -0x1AD9, -0x1AD3, -0x1ACC, -0x1AC6, -0x1AC0, -0x1AB9, -0x1AB3, -0x1AAC, -0x1AA6, -0x1A9F, -0x1A99, -0x1A93, -0x1A8C, -0x1A86, -0x1A7F, -0x1A79, -0x1A72, -0x1A6C, -0x1A65, -0x1A5F, -0x1A58, -0x1A52, -0x1A4B, -0x1A45, -0x1A3E, -0x1A38, -0x1A31, -0x1A2B, -0x1A24, -0x1A1E, -0x1A17, -0x1A11, -0x1A0A, -0x1A04, -0x19FD, -0x19F6, -0x19F0, -0x19E9, -0x19E3, -0x19DC, -0x19D5, -0x19CF, -0x19C8, -0x19C2, -0x19BB, -0x19B4, -0x19AE, -0x19A7, -0x19A0, -0x199A, -0x1993, -0x198C, -0x1986, -0x197F, -0x1978, -0x1972, -0x196B, -0x1964, -0x195D, -0x1957, -0x1950, -0x1949, -0x1943, -0x193C, -0x1935, -0x192E, -0x1928, -0x1921, -0x191A, -0x1913, -0x190C, -0x1906, -0x18FF, -0x18F8, -0x18F1, -0x18EA, -0x18E3, -0x18DD, -0x18D6, -0x18CF, -0x18C8, -0x18C1, -0x18BA, -0x18B3, -0x18AD, -0x18A6, -0x189F, -0x1898, -0x1891, -0x188A, -0x1883, -0x187C, -0x1875, -0x186E, -0x1867, -0x1860, -0x185A, -0x1853, -0x184C, -0x1845, -0x183E, -0x1837, -0x1830, -0x1829, -0x1822, -0x181B, -0x1814, -0x180D, -0x1806, -0x17FE, -0x17F7, -0x17F0, -0x17E9, -0x17E2, -0x17DB, -0x17D4, -0x17CD, -0x17C6, -0x17BF, -0x17B8, -0x17B1, -0x17AA, -0x17A2, -0x179B, -0x1794, -0x178D, -0x1786, -0x177F, -0x1778, -0x1770, -0x1769, -0x1762, -0x175B, -0x1754, -0x174C, -0x1745, -0x173E, -0x1737, -0x1730, -0x1728, -0x1721, -0x171A, -0x1713, -0x170B, -0x1704, -0x16FD, -0x16F6, -0x16EE, -0x16E7, -0x16E0, -0x16D8, -0x16D1, -0x16CA, -0x16C2, -0x16BB, -0x16B4, -0x16AC, -0x16A5, -0x169E, -0x1696, -0x168F, -0x1688, -0x1680, -0x1679, -0x1671, -0x166A, -0x1663, -0x165B, -0x1654, -0x164C, -0x1645, -0x163E, -0x1636, -0x162F, -0x1627, -0x1620, -0x1618, -0x1611, -0x1609, -0x1602, -0x15FA, -0x15F3, -0x15EB, -0x15E4, -0x15DC, -0x15D5, -0x15CD, -0x15C6, -0x15BE, -0x15B7, -0x15AF, -0x15A7, -0x15A0, -0x1598, -0x1591, -0x1589, -0x1581, -0x157A, -0x1572, -0x156B, -0x1563, -0x155B, -0x1554, -0x154C, -0x1544, -0x153D, -0x1535, -0x152D, -0x1526, -0x151E, -0x1516, -0x150F, -0x1507, -0x14FF, -0x14F8, -0x14F0, -0x14E8, -0x14E0, -0x14D9, -0x14D1, -0x14C9, -0x14C1, -0x14BA, -0x14B2, -0x14AA, -0x14A2, -0x149B, -0x1493, -0x148B, -0x1483, -0x147B, -0x1473, -0x146C, -0x1464, -0x145C, -0x1454, -0x144C, -0x1444, -0x143D, -0x1435, -0x142D, -0x1425, -0x141D, -0x1415, -0x140D, -0x1405, -0x13FD, -0x13F5, -0x13ED, -0x13E6, -0x13DE, -0x13D6, -0x13CE, -0x13C6, -0x13BE, -0x13B6, -0x13AE, -0x13A6, -0x139E, -0x1396, -0x138E, -0x1386, -0x137E, -0x1376, -0x136E, -0x1366, -0x135E, -0x1355, -0x134D, -0x1345, -0x133D, -0x1335, -0x132D, -0x1325, -0x131D, -0x1315, -0x130D, -0x1305, -0x12FC, -0x12F4, -0x12EC, -0x12E4, -0x12DC, -0x12D4, -0x12CC, -0x12C3, -0x12BB, -0x12B3, -0x12AB, -0x12A3, -0x129A, -0x1292, -0x128A, -0x1282, -0x127A, -0x1271, -0x1269, -0x1261, -0x1259, -0x1250, -0x1248, -0x1240, -0x1237, -0x122F, -0x1227, -0x121F, -0x1216, -0x120E, -0x1206, -0x11FD, -0x11F5, -0x11ED, -0x11E4, -0x11DC, -0x11D4, -0x11CB, -0x11C3, -0x11BB, -0x11B2, -0x11AA, -0x11A1, -0x1199, -0x1191, -0x1188, -0x1180, -0x1177, -0x116F, -0x1166, -0x115E, -0x1156, -0x114D, -0x1145, -0x113C, -0x1134, -0x112B, -0x1123, -0x111A, -0x1112, -0x1109, -0x1101, -0x10F8, -0x10F0, -0x10E7, -0x10DF, -0x10D6, -0x10CE, -0x10C5, -0x10BC, -0x10B4, -0x10AB, -0x10A3, -0x109A, -0x1092, -0x1089, -0x1080, -0x1078, -0x106F, -0x1067, -0x105E, -0x1055, -0x104D, -0x1044, -0x103B, -0x1033, -0x102A, -0x1021, -0x1019, -0x1010, -0x1007, -0x0FFF, -0x0FF6, -0x0FED, -0x0FE5, -0x0FDC, -0x0FD3, -0x0FCA, -0x0FC2, -0x0FB9, -0x0FB0, -0x0FA7, -0x0F9F, -0x0F96, -0x0F8D, -0x0F84, -0x0F7C, -0x0F73, -0x0F6A, -0x0F61, -0x0F58, -0x0F50, -0x0F47, -0x0F3E, -0x0F35, -0x0F2C, -0x0F23, -0x0F1B, -0x0F12, -0x0F09, -0x0F00, -0x0EF7, -0x0EEE, -0x0EE5, -0x0EDC, -0x0ED4, -0x0ECB, -0x0EC2, -0x0EB9, -0x0EB0, -0x0EA7, -0x0E9E, -0x0E95, -0x0E8C, -0x0E83, -0x0E7A, -0x0E71, -0x0E68, -0x0E5F, -0x0E56, -0x0E4E, -0x0E45, -0x0E3C, -0x0E33, -0x0E2A, -0x0E21, -0x0E18, -0x0E0F, -0x0E05, -0x0DFC, -0x0DF3, -0x0DEA, -0x0DE1, -0x0DD8, -0x0DCF, -0x0DC6, -0x0DBD, -0x0DB4, -0x0DAB, -0x0DA2, -0x0D99, -0x0D90, -0x0D87, -0x0D7D, -0x0D74, -0x0D6B, -0x0D62, -0x0D59, -0x0D50, -0x0D47, -0x0D3E, -0x0D34, -0x0D2B, -0x0D22, -0x0D19, -0x0D10, -0x0D07, -0x0CFD, -0x0CF4, -0x0CEB, -0x0CE2, -0x0CD9, -0x0CCF, -0x0CC6, -0x0CBD, -0x0CB4, -0x0CAB, -0x0CA1, -0x0C98, -0x0C8F, -0x0C86, -0x0C7C, -0x0C73, -0x0C6A, -0x0C60, -0x0C57, -0x0C4E, -0x0C45, -0x0C3B, -0x0C32, -0x0C29, -0x0C1F, -0x0C16, -0x0C0D, -0x0C03, -0x0BFA, -0x0BF1, -0x0BE7, -0x0BDE, -0x0BD5, -0x0BCB, -0x0BC2, -0x0BB9, -0x0BAF, -0x0BA6, -0x0B9D, -0x0B93, -0x0B8A, -0x0B80, -0x0B77, -0x0B6E, -0x0B64, -0x0B5B, -0x0B51, -0x0B48, -0x0B3F, -0x0B35, -0x0B2C, -0x0B22, -0x0B19, -0x0B0F, -0x0B06, -0x0AFC, -0x0AF3, -0x0AE9, -0x0AE0, -0x0AD7, -0x0ACD, -0x0AC4, -0x0ABA, -0x0AB1, -0x0AA7, -0x0A9E, -0x0A94, -0x0A8B, -0x0A81, -0x0A77, -0x0A6E, -0x0A64, -0x0A5B, -0x0A51, -0x0A48, -0x0A3E, -0x0A35, -0x0A2B, -0x0A22, -0x0A18, -0x0A0E, -0x0A05, -0x09FB, -0x09F2, -0x09E8, -0x09DE, -0x09D5, -0x09CB, -0x09C2, -0x09B8, -0x09AE, -0x09A5, -0x099B, -0x0992, -0x0988, -0x097E, -0x0975, -0x096B, -0x0961, -0x0958, -0x094E, -0x0944, -0x093B, -0x0931, -0x0927, -0x091E, -0x0914, -0x090A, -0x0901, -0x08F7, -0x08ED, -0x08E3, -0x08DA, -0x08D0, -0x08C6, -0x08BD, -0x08B3, -0x08A9, -0x089F, -0x0896, -0x088C, -0x0882, -0x0878, -0x086F, -0x0865, -0x085B, -0x0851, -0x0848, -0x083E, -0x0834, -0x082A, -0x0820, -0x0817, -0x080D, -0x0803, -0x07F9, -0x07EF, -0x07E6, -0x07DC, -0x07D2, -0x07C8, -0x07BE, -0x07B5, -0x07AB, -0x07A1, -0x0797, -0x078D, -0x0783, -0x077A, -0x0770, -0x0766, -0x075C, -0x0752, -0x0748, -0x073E, -0x0735, -0x072B, -0x0721, -0x0717, -0x070D, -0x0703, -0x06F9, -0x06EF, -0x06E5, -0x06DC, -0x06D2, -0x06C8, -0x06BE, -0x06B4, -0x06AA, -0x06A0, -0x0696, -0x068C, -0x0682, -0x0678, -0x066E, -0x0665, -0x065B, -0x0651, -0x0647, -0x063D, -0x0633, -0x0629, -0x061F, -0x0615, -0x060B, -0x0601, -0x05F7, -0x05ED, -0x05E3, -0x05D9, -0x05CF, -0x05C5, -0x05BB, -0x05B1, -0x05A7, -0x059D, -0x0593, -0x0589, -0x057F, -0x0575, -0x056B, -0x0561, -0x0557, -0x054D, -0x0543, -0x0539, -0x052F, -0x0525, -0x051B, -0x0511, -0x0507, -0x04FD, -0x04F3, -0x04E9, -0x04DF, -0x04D5, -0x04CB, -0x04C1, -0x04B7, -0x04AD, -0x04A3, -0x0499, -0x048E, -0x0484, -0x047A, -0x0470, -0x0466, -0x045C, -0x0452, -0x0448, -0x043E, -0x0434, -0x042A, -0x0420, -0x0416, -0x040C, -0x0401, -0x03F7, -0x03ED, -0x03E3, -0x03D9, -0x03CF, -0x03C5, -0x03BB, -0x03B1, -0x03A7, -0x039C, -0x0392, -0x0388, -0x037E, -0x0374, -0x036A, -0x0360, -0x0356, -0x034C, -0x0341, -0x0337, -0x032D, -0x0323, -0x0319, -0x030F, -0x0305, -0x02FB, -0x02F0, -0x02E6, -0x02DC, -0x02D2, -0x02C8, -0x02BE, -0x02B4, -0x02A9, -0x029F, -0x0295, -0x028B, -0x0281, -0x0277, -0x026D, -0x0262, -0x0258, -0x024E, -0x0244, -0x023A, -0x0230, -0x0226, -0x021B, -0x0211, -0x0207, -0x01FD, -0x01F3, -0x01E9, -0x01DE, -0x01D4, -0x01CA, -0x01C0, -0x01B6, -0x01AC, -0x01A1, -0x0197, -0x018D, -0x0183, -0x0179, -0x016F, -0x0164, -0x015A, -0x0150, -0x0146, -0x013C, -0x0131, -0x0127, -0x011D, -0x0113, -0x0109, -0x00FF, -0x00F4, -0x00EA, -0x00E0, -0x00D6, -0x00CC, -0x00C2, -0x00B7, -0x00AD, -0x00A3, -0x0099, -0x008F, -0x0084, -0x007A, -0x0070, -0x0066, -0x005C, -0x0051, -0x0047, -0x003D, -0x0033, -0x0029, -0x001F, -0x0014, -0x000A };
__device__ int gReverseArctanTableG[65537];

__device__ bool validCameraAngle[65537];

__device__ float platform_pos[3];

__device__ bool squishCeilings[4];

__device__ short preSquishCeilingTriangles[4][3][3];
__device__ float preSquishCeilingNormals[4][3];

__device__ short squishCeilingTriangles[4][3][3];
__device__ float squishCeilingNormals[4][3];
__device__ short squishTriangles[2][3][3];
__device__ float squishNormals[2][3];

__device__ short startCeilingTriangles[4][3][3];
__device__ float startCeilingNormals[4][3];
__device__ short startTriangles[2][3][3];
__device__ float startNormals[2][3];
__device__ float platformNormal[3];

__device__ const int total_floorsG = 350;
__device__ SurfaceG floorsG[total_floorsG];

__global__ void initialise_floors() {
    floorsG[0] = SurfaceG(1536, 5478, -262, 922, 5478, -262, 922, 5478, 403);
    floorsG[1] = SurfaceG(1536, 5478, -262, 922, 5478, 403, 1536, 5478, 403);
    floorsG[2] = SurfaceG(2150, 5248, -262, 1536, 5248, -210, 2150, 5248, -210);
    floorsG[3] = SurfaceG(2150, 5248, -262, 1536, 5248, -262, 1536, 5248, -210);
    floorsG[4] = SurfaceG(2765, 5248, -262, 2150, 5248, 403, 2765, 5248, 403);
    floorsG[5] = SurfaceG(2765, 5248, -262, 2150, 5248, -262, 2150, 5248, 403);
    floorsG[6] = SurfaceG(3994, 5018, -262, 2765, 5018, -262, 2765, 5018, -210);
    floorsG[7] = SurfaceG(3994, 5018, -262, 2765, 5018, -210, 3994, 5018, -210);
    floorsG[8] = SurfaceG(7384, 4506, 371, 7513, 4403, -236, 7384, 4506, -181);
    floorsG[9] = SurfaceG(7384, 4506, 371, 7513, 4403, 426, 7513, 4403, -236);
    floorsG[10] = SurfaceG(7384, 4506, -181, 7513, 4403, -236, 7071, 4403, -678);
    floorsG[11] = SurfaceG(7384, 4506, -181, 7071, 4403, -678, 7015, 4506, -549);
    floorsG[12] = SurfaceG(7015, 4506, -549, 7071, 4403, -678, 6407, 4403, -678);
    floorsG[13] = SurfaceG(7015, 4506, -549, 6407, 4403, -678, 6462, 4506, -549);
    floorsG[14] = SurfaceG(6462, 4506, -549, 6407, 4403, -678, 5965, 4403, -236);
    floorsG[15] = SurfaceG(6462, 4506, -549, 5965, 4403, -236, 6094, 4506, -181);
    floorsG[16] = SurfaceG(7384, 4506, -181, 6912, 4019, 170, 7384, 4506, 371);
    floorsG[17] = SurfaceG(7015, 4506, -549, 6912, 4019, 20, 7384, 4506, -181);
    floorsG[18] = SurfaceG(7015, 4506, -549, 6462, 4506, -549, 6661, 4019, -79);
    floorsG[19] = SurfaceG(7384, 4506, -181, 6912, 4019, 20, 6912, 4019, 170);
    floorsG[20] = SurfaceG(6462, 4506, 740, 6561, 4019, 170, 6094, 4506, 371);
    floorsG[21] = SurfaceG(6462, 4506, 740, 6661, 4019, 271, 6561, 4019, 170);
    floorsG[22] = SurfaceG(6094, 4506, 371, 6561, 4019, 170, 6561, 4019, 20);
    floorsG[23] = SurfaceG(6094, 4506, 371, 6561, 4019, 20, 6094, 4506, -181);
    floorsG[24] = SurfaceG(7015, 4506, -549, 6811, 4019, -79, 6912, 4019, 20);
    floorsG[25] = SurfaceG(7015, 4506, -549, 6661, 4019, -79, 6811, 4019, -79);
    floorsG[26] = SurfaceG(6094, 4506, -181, 5965, 4403, -236, 5965, 4403, 426);
    floorsG[27] = SurfaceG(6094, 4506, -181, 5965, 4403, 426, 6094, 4506, 371);
    floorsG[28] = SurfaceG(7071, 4403, 869, 7015, 4506, 740, 6462, 4506, 740);
    floorsG[29] = SurfaceG(7071, 4403, 869, 6462, 4506, 740, 6407, 4403, 869);
    floorsG[30] = SurfaceG(7071, 4403, 869, 7513, 4403, 426, 7384, 4506, 371);
    floorsG[31] = SurfaceG(7071, 4403, 869, 7384, 4506, 371, 7015, 4506, 740);
    floorsG[32] = SurfaceG(5965, 4403, 426, 6407, 4403, 869, 6462, 4506, 740);
    floorsG[33] = SurfaceG(5965, 4403, 426, 6462, 4506, 740, 6094, 4506, 371);
    floorsG[34] = SurfaceG(3994, 4403, -210, 3379, 4403, -210, 3379, 4403, 403);
    floorsG[35] = SurfaceG(4403, 4403, -210, 3994, 4403, -210, 3994, 4403, 403);
    floorsG[36] = SurfaceG(4403, 4403, -210, 3994, 4403, 403, 4403, 4403, 403);
    floorsG[37] = SurfaceG(3994, 4403, -210, 3379, 4403, 403, 3994, 4403, 403);
    floorsG[38] = SurfaceG(1536, 4403, -210, 922, 4403, -210, 922, 4403, 403);
    floorsG[39] = SurfaceG(1536, 4403, -210, 922, 4403, 403, 1536, 4403, 403);
    floorsG[40] = SurfaceG(5555, 4403, 403, 5965, 4403, -210, 5555, 4403, -210);
    floorsG[41] = SurfaceG(1536, 4403, 403, 2150, 4403, 403, 1946, 4403, 198);
    floorsG[42] = SurfaceG(1536, 4403, 403, 1946, 4403, 198, 1741, 4403, 198);
    floorsG[43] = SurfaceG(1536, 4403, 403, 1741, 4403, -6, 1536, 4403, -210);
    floorsG[44] = SurfaceG(1536, 4403, 403, 1741, 4403, 198, 1741, 4403, -6);
    floorsG[45] = SurfaceG(1536, 4403, -210, 1741, 4403, -6, 1946, 4403, -6);
    floorsG[46] = SurfaceG(1536, 4403, -210, 1946, 4403, -6, 2150, 4403, -210);
    floorsG[47] = SurfaceG(2150, 4403, -210, 1946, 4403, 198, 2150, 4403, 403);
    floorsG[48] = SurfaceG(2150, 4403, -210, 1946, 4403, -6, 1946, 4403, 198);
    floorsG[49] = SurfaceG(5555, 4403, 403, 5965, 4403, 403, 5965, 4403, -210);
    floorsG[50] = SurfaceG(5965, 4255, 426, 5965, 4403, 403, 5555, 4403, 403);
    floorsG[51] = SurfaceG(6811, 4019, 271, 7015, 4506, 740, 7384, 4506, 371);
    floorsG[52] = SurfaceG(6661, 4019, 271, 6462, 4506, 740, 7015, 4506, 740);
    floorsG[53] = SurfaceG(6661, 4019, 271, 7015, 4506, 740, 6811, 4019, 271);
    floorsG[54] = SurfaceG(6811, 4019, 271, 7384, 4506, 371, 6912, 4019, 170);
    floorsG[55] = SurfaceG(6561, 4019, 20, 6661, 4019, -79, 6462, 4506, -549);
    floorsG[56] = SurfaceG(6561, 4019, 20, 6462, 4506, -549, 6094, 4506, -181);
    floorsG[57] = SurfaceG(-4965, 3789, 404, -5017, 3789, 404, -5017, 3789, 761);
    floorsG[58] = SurfaceG(-4965, 3789, 404, -5017, 3789, 761, -4965, 3789, 813);
    floorsG[59] = SurfaceG(-5017, 3789, -971, -5017, 3789, -209, -4965, 3789, -209);
    floorsG[60] = SurfaceG(-4965, 3789, -1022, -5017, 3789, -971, -4965, 3789, -209);
    floorsG[61] = SurfaceG(-4965, 3789, 813, -5631, 3789, 761, -5682, 3789, 813);
    floorsG[62] = SurfaceG(-5682, 3789, -1022, -5682, 3789, -971, -5017, 3789, -971);
    floorsG[63] = SurfaceG(-5682, 3789, -1022, -5017, 3789, -971, -4965, 3789, -1022);
    floorsG[64] = SurfaceG(-5682, 3789, -1022, -6911, 3174, -1022, -6911, 3174, -971);
    floorsG[65] = SurfaceG(-5682, 3789, -971, -5682, 3789, -1022, -6911, 3174, -971);
    floorsG[66] = SurfaceG(-5631, 3789, -663, -5682, 3789, -663, -5682, 3789, 813);
    floorsG[67] = SurfaceG(-5631, 3789, -663, -5682, 3789, 813, -5631, 3789, 761);
    floorsG[68] = SurfaceG(-4965, 3789, 813, -5017, 3789, 761, -5631, 3789, 761);
    floorsG[69] = SurfaceG(2765, 3789, -210, 2150, 3789, -210, 2150, 3789, 403);
    floorsG[70] = SurfaceG(2765, 3789, -210, 2150, 3789, 403, 2765, 3789, 403);
    floorsG[71] = SurfaceG(307, 3789, -518, -306, 3789, 710, 307, 3789, 710);
    floorsG[72] = SurfaceG(307, 3789, -518, -306, 3789, -518, -306, 3789, 710);
    floorsG[73] = SurfaceG(-3173, 3686, -876, -3276, 3686, -876, -3276, 3686, -774);
    floorsG[74] = SurfaceG(-3173, 3686, -876, -3276, 3686, -774, -3173, 3686, -774);
    floorsG[75] = SurfaceG(-3276, 3686, -774, -3276, 3686, -876, -3378, 3482, -978);
    floorsG[76] = SurfaceG(-1330, 3686, -872, -1433, 3686, -872, -1433, 3686, -770);
    floorsG[77] = SurfaceG(-1330, 3686, -872, -1433, 3686, -770, -1330, 3686, -770);
    floorsG[78] = SurfaceG(-1433, 3686, -770, -1433, 3686, -872, -1535, 3482, -975);
    floorsG[79] = SurfaceG(-5017, 3686, 404, -4965, 3686, 404, -4965, 3686, -209);
    floorsG[80] = SurfaceG(-5017, 3686, 404, -4965, 3686, -209, -5017, 3686, -209);
    floorsG[81] = SurfaceG(-5631, 3686, -971, -6911, 3072, -971, -6962, 3072, -663);
    floorsG[82] = SurfaceG(-5631, 3686, -971, -6962, 3072, -663, -5631, 3686, -663);
    floorsG[83] = SurfaceG(-4965, 3686, 404, -4484, 3686, 404, -4484, 3686, -209);
    floorsG[84] = SurfaceG(-4965, 3686, 404, -4484, 3686, -209, -4965, 3686, -209);
    floorsG[85] = SurfaceG(-5631, 3686, -971, -5631, 3686, 761, -5017, 3686, 761);
    floorsG[86] = SurfaceG(-5017, 3686, -971, -5631, 3686, -971, -5017, 3686, 761);
    floorsG[87] = SurfaceG(-4607, 3533, 1126, 563, 3533, 1126, 563, 3482, 1024);
    floorsG[88] = SurfaceG(-4607, 3533, 1126, 563, 3482, 1024, -4530, 3482, 1050);
    floorsG[89] = SurfaceG(-4607, 3533, 1126, -4530, 3482, 1050, -4530, 3482, -1106);
    floorsG[90] = SurfaceG(-4607, 3533, 1126, -4530, 3482, -1106, -4607, 3533, -1183);
    floorsG[91] = SurfaceG(5734, 3533, -1183, 563, 3533, -1183, 5658, 3482, -1106);
    floorsG[92] = SurfaceG(563, 3533, -1183, 563, 3482, -1081, 5658, 3482, -1106);
    floorsG[93] = SurfaceG(5734, 3533, -1183, 5658, 3482, -1106, 5734, 3533, 1126);
    floorsG[94] = SurfaceG(-4146, 3533, -209, -4484, 3686, -209, -4484, 3686, 404);
    floorsG[95] = SurfaceG(-4146, 3533, -209, -4484, 3686, 404, -4146, 3533, 404);
    floorsG[96] = SurfaceG(-3378, 3482, -978, -3276, 3686, -876, -3173, 3686, -876);
    floorsG[97] = SurfaceG(-3378, 3482, -978, -3173, 3686, -876, -3071, 3482, -978);
    floorsG[98] = SurfaceG(-3071, 3482, -978, -3173, 3686, -876, -3173, 3686, -774);
    floorsG[99] = SurfaceG(-3327, 3482, -620, -3276, 3686, -774, -3378, 3482, -978);
    floorsG[100] = SurfaceG(-3122, 3482, -620, -3173, 3686, -774, -3276, 3686, -774);
    floorsG[101] = SurfaceG(-3122, 3482, -620, -3276, 3686, -774, -3327, 3482, -620);
    floorsG[102] = SurfaceG(-3071, 3482, -978, -3173, 3686, -774, -3122, 3482, -620);
    floorsG[103] = SurfaceG(-1535, 3482, -975, -1330, 3686, -872, -1228, 3482, -975);
    floorsG[104] = SurfaceG(-1228, 3482, -975, -1330, 3686, -872, -1330, 3686, -770);
    floorsG[105] = SurfaceG(-1228, 3482, -975, -1330, 3686, -770, -1279, 3482, -616);
    floorsG[106] = SurfaceG(-1535, 3482, -975, -1433, 3686, -872, -1330, 3686, -872);
    floorsG[107] = SurfaceG(-1279, 3482, -616, -1330, 3686, -770, -1433, 3686, -770);
    floorsG[108] = SurfaceG(-1279, 3482, -616, -1433, 3686, -770, -1484, 3482, -616);
    floorsG[109] = SurfaceG(-1484, 3482, -616, -1433, 3686, -770, -1535, 3482, -975);
    floorsG[110] = SurfaceG(-4530, 3482, -1106, 563, 3533, -1183, -4607, 3533, -1183);
    floorsG[111] = SurfaceG(-4530, 3482, -1106, 563, 3482, -1081, 563, 3533, -1183);
    floorsG[112] = SurfaceG(5658, 3482, 1050, 563, 3482, 1024, 5734, 3533, 1126);
    floorsG[113] = SurfaceG(563, 3482, 1024, 563, 3533, 1126, 5734, 3533, 1126);
    floorsG[114] = SurfaceG(5658, 3482, -1106, 5658, 3482, 1050, 5734, 3533, 1126);
    floorsG[115] = SurfaceG(-4530, 3482, 1050, -2000, 3482, -26, -4530, 3482, -1106, true);
    floorsG[116] = SurfaceG(-4530, 3482, 1050, 563, 3482, 1024, -2000, 3482, -26, true);
    floorsG[117] = SurfaceG(-4530, 3482, -1106, -2000, 3482, -26, 563, 3482, -1081, true);
    floorsG[118] = SurfaceG(563, 3482, -1081, -2000, 3482, -26, 563, 3482, 1024, true);
    floorsG[119] = SurfaceG(563, 3482, 1024, 3128, 3482, -26, 563, 3482, -1081, true);
    floorsG[120] = SurfaceG(563, 3482, -1081, 3128, 3482, -26, 5658, 3482, -1106, true);
    floorsG[121] = SurfaceG(3128, 3482, -26, 563, 3482, 1024, 5658, 3482, 1050, true);
    floorsG[122] = SurfaceG(5658, 3482, -1106, 3128, 3482, -26, 5658, 3482, 1050, true);
    floorsG[123] = SurfaceG(-7474, 3174, -612, -7525, 2867, 1, -7474, 2867, 1);
    floorsG[124] = SurfaceG(-7474, 3174, -612, -7525, 3174, -612, -7525, 2867, 1);
    floorsG[125] = SurfaceG(-7525, 3174, -612, -7474, 3174, -612, -7321, 3174, -971);
    floorsG[126] = SurfaceG(-7525, 3174, -612, -7321, 3174, -971, -7372, 3174, -1022);
    floorsG[127] = SurfaceG(-7372, 3174, -1021, -7321, 3174, -971, -6911, 3174, -971);
    floorsG[128] = SurfaceG(-7372, 3174, -1021, -6911, 3174, -971, -6911, 3174, -1022);
    floorsG[129] = SurfaceG(-6911, 3174, -663, -6962, 3174, -663, -6962, 3174, -612);
    floorsG[130] = SurfaceG(-6911, 3174, -612, -5682, 3789, -612, -5682, 3789, -663);
    floorsG[131] = SurfaceG(-6911, 3174, -663, -6911, 3174, -612, -5682, 3789, -663);
    floorsG[132] = SurfaceG(-6911, 3174, -663, -6962, 3174, -612, -6911, 3174, -612);
    floorsG[133] = SurfaceG(-6962, 3072, -612, -6962, 3072, -663, -7474, 3072, -612);
    floorsG[134] = SurfaceG(-6962, 3072, -663, -6911, 3072, -971, -7474, 3072, -612);
    floorsG[135] = SurfaceG(-6911, 3072, -971, -7321, 3072, -971, -7474, 3072, -612);
    floorsG[136] = SurfaceG(-6962, 3072, -612, -7474, 3072, -612, -6962, 2765, 52);
    floorsG[137] = SurfaceG(-7474, 3072, -612, -7474, 2765, 1, -6962, 2765, 52);
    floorsG[138] = SurfaceG(6640, 2899, -122, 6640, 2899, 321, 6830, 2899, 321);
    floorsG[139] = SurfaceG(6640, 2899, -122, 6830, 2899, 321, 6957, 2899, 194);
    floorsG[140] = SurfaceG(6640, 2899, -122, 6513, 2899, 194, 6640, 2899, 321);
    floorsG[141] = SurfaceG(6640, 2899, -122, 6957, 2899, 194, 6957, 2899, 4);
    floorsG[142] = SurfaceG(6640, 2899, -122, 6957, 2899, 4, 6830, 2899, -122);
    floorsG[143] = SurfaceG(6640, 2899, -122, 6513, 2899, 4, 6513, 2899, 194);
    floorsG[144] = SurfaceG(-6911, 2867, 1, -6297, 2867, 52, -6297, 2867, 1);
    floorsG[145] = SurfaceG(-6911, 2867, 1, -6911, 2867, 52, -6297, 2867, 52);
    floorsG[146] = SurfaceG(-7474, 2867, 1, -7525, 2867, 1, -7218, 2867, 616);
    floorsG[147] = SurfaceG(-7218, 2867, 616, -7187, 2867, 564, -7474, 2867, 1);
    floorsG[148] = SurfaceG(-7218, 2867, 616, -6297, 2867, 616, -6297, 2867, 564);
    floorsG[149] = SurfaceG(-7218, 2867, 616, -6297, 2867, 564, -7187, 2867, 564);
    floorsG[150] = SurfaceG(-6962, 2867, 1, -6911, 3174, -612, -6962, 3174, -612);
    floorsG[151] = SurfaceG(-6962, 2867, 1, -6911, 2867, 1, -6911, 3174, -612);
    floorsG[152] = SurfaceG(-6962, 2867, 52, -6911, 2867, 1, -6962, 2867, 1);
    floorsG[153] = SurfaceG(-6962, 2867, 52, -6911, 2867, 52, -6911, 2867, 1);
    floorsG[154] = SurfaceG(-6962, 2765, 52, -6297, 2765, 564, -6297, 2765, 52);
    floorsG[155] = SurfaceG(-6962, 2765, 52, -7187, 2765, 564, -6297, 2765, 564);
    floorsG[156] = SurfaceG(-6962, 2765, 52, -7474, 2765, 1, -7187, 2765, 564);
    floorsG[157] = SurfaceG(-2354, 1331, -613, -1637, 1331, 0, -1330, 1331, -306);
    floorsG[158] = SurfaceG(-2354, 1331, -613, -2354, 1331, -306, -2047, 1331, 0);
    floorsG[159] = SurfaceG(-2354, 1331, -613, -2047, 1331, 0, -1637, 1331, 0);
    floorsG[160] = SurfaceG(-2354, 1331, -613, -1330, 1331, -613, -1637, 1331, -921);
    floorsG[161] = SurfaceG(-2354, 1331, -613, -1637, 1331, -921, -2047, 1331, -921);
    floorsG[162] = SurfaceG(-2354, 1331, -613, -1330, 1331, -306, -1330, 1331, -613);
    floorsG[163] = SurfaceG(-1381, 819, -25, -1407, 819, 0, -1356, 819, 0);
    floorsG[164] = SurfaceG(-1356, 819, 614, -1407, 819, 614, -1381, 819, 640);
    floorsG[165] = SurfaceG(-2380, 819, 614, -2431, 819, 614, -2405, 819, 640);
    floorsG[166] = SurfaceG(-2405, 819, -25, -2431, 819, 0, -2380, 819, 0);
    floorsG[167] = SurfaceG(-562, 819, -306, -665, 819, 0, -562, 819, 0);
    floorsG[168] = SurfaceG(-562, 819, -306, -665, 819, -306, -665, 819, 0);
    floorsG[169] = SurfaceG(-665, 819, 614, -1074, 410, 0, -1074, 410, 614);
    floorsG[170] = SurfaceG(-665, 819, 614, -665, 819, 0, -1074, 410, 0);
    floorsG[171] = SurfaceG(-665, 819, 614, -562, 819, 614, -562, 819, 0);
    floorsG[172] = SurfaceG(-562, 819, 0, -562, 819, 614, -50, 410, 614);
    floorsG[173] = SurfaceG(-562, 819, 0, -50, 410, 614, -50, 410, 0);
    floorsG[174] = SurfaceG(-665, 819, 614, -562, 819, 0, -665, 819, 0);
    floorsG[175] = SurfaceG(-767, 819, -613, -1330, 1331, -306, -767, 819, -306);
    floorsG[176] = SurfaceG(-767, 819, -306, -460, 819, -306, -460, 819, -613);
    floorsG[177] = SurfaceG(-767, 819, -306, -460, 819, -613, -767, 819, -613);
    floorsG[178] = SurfaceG(-767, 819, -613, -1330, 1331, -613, -1330, 1331, -306);
    floorsG[179] = SurfaceG(-1330, 788, 614, -2457, 742, 640, -1330, 742, 640);
    floorsG[180] = SurfaceG(-1330, 788, 614, -2457, 788, 614, -2457, 742, 640);
    floorsG[181] = SurfaceG(-1330, 753, 0, -2457, 753, 614, -1330, 753, 614);
    floorsG[182] = SurfaceG(-1330, 753, 0, -2457, 753, 0, -2457, 753, 614);
    floorsG[183] = SurfaceG(-1330, 742, -25, -2457, 742, -25, -2457, 788, 0);
    floorsG[184] = SurfaceG(-1330, 742, -25, -2457, 788, 0, -1330, 788, 0);
    floorsG[185] = SurfaceG(1280, 410, -462, 1178, 410, -462, 1178, 410, -359);
    floorsG[186] = SurfaceG(1280, 410, -462, 1178, 410, -359, 1280, 410, -359);
    floorsG[187] = SurfaceG(1178, 410, -359, 1178, 410, -462, 1075, 205, -564);
    floorsG[188] = SurfaceG(922, 410, 102, 205, 410, 102, 205, 410, 512);
    floorsG[189] = SurfaceG(-5836, 410, 1, -4197, 410, 1, -4505, 410, -305);
    floorsG[190] = SurfaceG(-5836, 410, 1, -4505, 410, -305, -5529, 410, -305);
    floorsG[191] = SurfaceG(-5836, 410, 1, -4197, 410, 617, -4197, 410, 1);
    floorsG[192] = SurfaceG(-5836, 410, 1, -5836, 410, 617, -5529, 410, 924);
    floorsG[193] = SurfaceG(-5836, 410, 1, -5529, 410, 924, -4505, 410, 924);
    floorsG[194] = SurfaceG(-5836, 410, 1, -4505, 410, 924, -4197, 410, 617);
    floorsG[195] = SurfaceG(2458, 410, 102, 1741, 410, 512, 2458, 410, 512);
    floorsG[196] = SurfaceG(922, 410, 102, 205, 410, 512, 922, 410, 512);
    floorsG[197] = SurfaceG(-2969, 410, 617, -2149, 307, 2, -2969, 410, 2);
    floorsG[198] = SurfaceG(-2969, 410, 617, -2149, 307, 617, -2149, 307, 2);
    floorsG[199] = SurfaceG(2458, 410, 102, 1741, 410, 102, 1741, 410, 512);
    floorsG[200] = SurfaceG(2662, 410, 512, 2458, 410, 717, 3277, 410, 717);
    floorsG[201] = SurfaceG(2458, 410, 717, 2662, 410, 512, 2662, 410, 102);
    floorsG[202] = SurfaceG(2458, 410, 717, 2662, 410, 102, 2458, 410, -101);
    floorsG[203] = SurfaceG(2458, 410, -101, 2662, 410, 102, 3072, 410, 102);
    floorsG[204] = SurfaceG(2458, 410, -101, 3072, 410, 102, 3277, 410, -101);
    floorsG[205] = SurfaceG(3277, 410, 717, 3277, 410, -101, 3072, 410, 102);
    floorsG[206] = SurfaceG(3277, 410, 717, 3072, 410, 102, 3072, 410, 512);
    floorsG[207] = SurfaceG(2662, 410, 512, 3277, 410, 717, 3072, 410, 512);
    floorsG[208] = SurfaceG(-50, 410, 614, 205, 410, 0, -50, 410, 0);
    floorsG[209] = SurfaceG(-1433, 410, 614, -1074, 410, 0, -1433, 410, 0);
    floorsG[210] = SurfaceG(-1433, 410, 614, -1074, 410, 614, -1074, 410, 0);
    floorsG[211] = SurfaceG(-50, 410, 614, 205, 410, 614, 205, 410, 0);
    floorsG[212] = SurfaceG(-2354, 256, 1126, 1126, 256, 1126, 1126, 205, 1050);
    floorsG[213] = SurfaceG(-7525, 256, 1126, -2354, 256, 1126, -2354, 205, 1024);
    floorsG[214] = SurfaceG(1126, 256, -1183, -2354, 256, -1183, -2354, 205, -1081);
    floorsG[215] = SurfaceG(1126, 256, -1183, -2354, 205, -1081, 1126, 205, -1106);
    floorsG[216] = SurfaceG(4915, 256, 1126, 4915, 256, -1183, 4838, 205, -1106);
    floorsG[217] = SurfaceG(4915, 256, 1126, 4838, 205, -1106, 4838, 205, 1050);
    floorsG[218] = SurfaceG(-7525, 256, 1126, -2354, 205, 1024, -7449, 205, 1050);
    floorsG[219] = SurfaceG(-7525, 256, 1126, -7449, 205, 1050, -7449, 205, -1106);
    floorsG[220] = SurfaceG(-7525, 256, 1126, -7449, 205, -1106, -7525, 256, -1183);
    floorsG[221] = SurfaceG(2662, 207, 512, -2354, 205, -1081, -2354, 205, 1024, true);
    floorsG[222] = SurfaceG(2662, 207, 512, 2663, 205, 101, -2354, 205, -1081, true);
    floorsG[223] = SurfaceG(1126, 205, 1050, -2354, 205, 1024, -2354, 256, 1126);
    floorsG[224] = SurfaceG(4838, 205, 1050, 1126, 256, 1126, 4915, 256, 1126);
    floorsG[225] = SurfaceG(4838, 205, 1050, 1126, 205, 1050, 1126, 256, 1126);
    floorsG[226] = SurfaceG(1075, 205, -564, 1280, 410, -462, 1382, 205, -564);
    floorsG[227] = SurfaceG(1382, 205, -564, 1280, 410, -462, 1280, 410, -359);
    floorsG[228] = SurfaceG(1075, 205, -564, 1178, 410, -462, 1280, 410, -462);
    floorsG[229] = SurfaceG(1126, 205, -206, 1178, 410, -359, 1075, 205, -564);
    floorsG[230] = SurfaceG(1331, 205, -206, 1280, 410, -359, 1178, 410, -359);
    floorsG[231] = SurfaceG(1331, 205, -206, 1178, 410, -359, 1126, 205, -206);
    floorsG[232] = SurfaceG(1382, 205, -564, 1280, 410, -359, 1331, 205, -206);
    floorsG[233] = SurfaceG(-7449, 205, -1106, -2354, 205, -1081, -2354, 256, -1183);
    floorsG[234] = SurfaceG(1126, 205, -1106, 4838, 205, -1106, 4915, 256, -1183);
    floorsG[235] = SurfaceG(1126, 205, -1106, 4915, 256, -1183, 1126, 256, -1183);
    floorsG[236] = SurfaceG(-7449, 205, -1106, -2354, 256, -1183, -7525, 256, -1183);
    floorsG[237] = SurfaceG(1126, 205, 1050, 3072, 205, 512, 2662, 207, 512, true);
    floorsG[238] = SurfaceG(1126, 205, 1050, 4838, 205, 1050, 3072, 205, 512, true);
    floorsG[239] = SurfaceG(4838, 205, -1106, 3072, 205, 512, 4838, 205, 1050, true);
    floorsG[240] = SurfaceG(4838, 205, -1106, 3072, 205, 102, 3072, 205, 512, true);
    floorsG[241] = SurfaceG(1126, 205, 1050, 2662, 207, 512, -2354, 205, 1024, true);
    floorsG[242] = SurfaceG(2663, 205, 101, 3072, 205, 102, 4838, 205, -1106, true);
    floorsG[243] = SurfaceG(2663, 205, 101, 1126, 205, -1106, -2354, 205, -1081, true);
    floorsG[244] = SurfaceG(2663, 205, 101, 4838, 205, -1106, 1126, 205, -1106, true);
    floorsG[245] = SurfaceG(-7449, 205, -1106, -4919, 205, -26, -2354, 205, -1081, true);
    floorsG[246] = SurfaceG(-2354, 205, -1081, -4919, 205, -26, -2354, 205, 1024, true);
    floorsG[247] = SurfaceG(-7449, 205, 1050, -2354, 205, 1024, -4919, 205, -26, true);
    floorsG[248] = SurfaceG(-7449, 205, 1050, -4919, 205, -26, -7449, 205, -1106, true);
    floorsG[249] = SurfaceG(4403, -665, 819, 4454, -665, 819, 4454, -665, -255);
    floorsG[250] = SurfaceG(4403, -665, 819, 4454, -665, -255, 4403, -665, -204);
    floorsG[251] = SurfaceG(4454, -665, -255, 3379, -665, -204, 4403, -665, -204);
    floorsG[252] = SurfaceG(4454, -665, -255, 3379, -665, -255, 3379, -665, -204);
    floorsG[253] = SurfaceG(3379, -665, -204, 3379, -665, -255, 3072, -665, 102);
    floorsG[254] = SurfaceG(3379, -1279, 819, 3738, -1279, 461, 3738, -1279, 154);
    floorsG[255] = SurfaceG(3738, -1279, 461, 4403, -1279, 819, 4045, -1279, 461);
    floorsG[256] = SurfaceG(3738, -1279, 461, 3379, -1279, 819, 4403, -1279, 819);
    floorsG[257] = SurfaceG(3379, -1279, 819, 3072, -1125, 102, 3072, -1125, 512);
    floorsG[258] = SurfaceG(3379, -1279, 819, 3738, -1279, 154, 3379, -1279, -204);
    floorsG[259] = SurfaceG(3379, -1279, 819, 3379, -1279, -204, 3072, -1125, 102);
    floorsG[260] = SurfaceG(4045, -1279, 154, 4045, -1279, 461, 4403, -1279, 819);
    floorsG[261] = SurfaceG(4045, -1279, 154, 4403, -1279, 819, 4403, -1279, -204);
    floorsG[262] = SurfaceG(3379, -1279, -204, 3738, -1279, 154, 4045, -1279, 154);
    floorsG[263] = SurfaceG(3379, -1279, -204, 4045, -1279, 154, 4403, -1279, -204);
    floorsG[264] = SurfaceG(5070, -2042, 317, 5070, -2042, 215, 4967, -2042, 215);
    floorsG[265] = SurfaceG(5070, -2042, 317, 4967, -2042, 215, 4967, -2042, 317);
    floorsG[266] = SurfaceG(3941, -2042, 317, 3941, -2042, 215, 3839, -2042, 317);
    floorsG[267] = SurfaceG(3941, -2042, 215, 3839, -2042, 215, 3839, -2042, 317);
    floorsG[268] = SurfaceG(4967, -2042, 215, 5070, -2042, 215, 5070, -2124, 164);
    floorsG[269] = SurfaceG(4967, -2042, 215, 5070, -2124, 164, 4967, -2124, 164);
    floorsG[270] = SurfaceG(3941, -2042, 317, 3839, -2042, 317, 3941, -2124, 369);
    floorsG[271] = SurfaceG(3839, -2042, 317, 3839, -2124, 369, 3941, -2124, 369);
    floorsG[272] = SurfaceG(5172, -2093, 215, 5070, -2042, 215, 5070, -2042, 317);
    floorsG[273] = SurfaceG(5172, -2093, 215, 5070, -2042, 317, 5172, -2093, 317);
    floorsG[274] = SurfaceG(3839, -2124, 164, 3839, -2042, 215, 3941, -2042, 215);
    floorsG[275] = SurfaceG(4967, -2124, 369, 5070, -2124, 369, 5070, -2042, 317);
    floorsG[276] = SurfaceG(4967, -2124, 369, 5070, -2042, 317, 4967, -2042, 317);
    floorsG[277] = SurfaceG(3941, -2124, 164, 3839, -2124, 164, 3941, -2042, 215);
    floorsG[278] = SurfaceG(7526, -2149, -40, 6912, -2149, -40, 6912, -2149, 573);
    floorsG[279] = SurfaceG(7526, -2149, -40, 6912, -2149, 573, 7526, -2149, 573);
    floorsG[280] = SurfaceG(1024, -2149, -1289, 1434, -2457, -921, 1434, -2149, -1289);
    floorsG[281] = SurfaceG(1024, -2149, -1289, 1024, -2457, -921, 1434, -2457, -921);
    floorsG[282] = SurfaceG(1690, -2149, -1289, 1382, -2149, -1596, 1075, -2149, -1596);
    floorsG[283] = SurfaceG(1690, -2149, -1289, 1075, -2149, -1596, 768, -2149, -1289);
    floorsG[284] = SurfaceG(1690, -2149, -2211, 1382, -2149, -1596, 1690, -2149, -1289);
    floorsG[285] = SurfaceG(1690, -2149, -2211, 1382, -2149, -1904, 1382, -2149, -1596);
    floorsG[286] = SurfaceG(768, -2149, -1289, 1075, -2149, -1596, 1075, -2149, -1904);
    floorsG[287] = SurfaceG(768, -2149, -1289, 1075, -2149, -1904, 768, -2149, -2211);
    floorsG[288] = SurfaceG(768, -2149, -2211, 1075, -2149, -1904, 1382, -2149, -1904);
    floorsG[289] = SurfaceG(768, -2149, -2211, 1382, -2149, -1904, 1690, -2149, -2211);
    floorsG[290] = SurfaceG(5273, -2196, 215, 5170, -2196, 215, 5170, -2196, 317);
    floorsG[291] = SurfaceG(5273, -2196, 317, 5273, -2196, 215, 5170, -2196, 317);
    floorsG[292] = SurfaceG(6401, -2196, 317, 6299, -2196, 215, 6299, -2196, 317);
    floorsG[293] = SurfaceG(6401, -2196, 317, 6401, -2196, 215, 6299, -2196, 215);
    floorsG[294] = SurfaceG(5273, -2196, 317, 5170, -2196, 317, 5273, -2278, 369);
    floorsG[295] = SurfaceG(5170, -2196, 317, 5170, -2278, 369, 5273, -2278, 369);
    floorsG[296] = SurfaceG(6299, -2196, 215, 6401, -2278, 164, 6299, -2278, 164);
    floorsG[297] = SurfaceG(6299, -2196, 215, 6401, -2196, 215, 6401, -2278, 164);
    floorsG[298] = SurfaceG(6299, -2278, 369, 6401, -2196, 317, 6299, -2196, 317);
    floorsG[299] = SurfaceG(5170, -2278, 164, 5170, -2196, 215, 5273, -2196, 215);
    floorsG[300] = SurfaceG(5273, -2278, 164, 5170, -2278, 164, 5273, -2196, 215);
    floorsG[301] = SurfaceG(6299, -2278, 369, 6401, -2278, 369, 6401, -2196, 317);
    floorsG[302] = SurfaceG(2662, -2457, -306, 2662, -2764, 61, 3072, -2764, 61);
    floorsG[303] = SurfaceG(2662, -2457, -306, 3072, -2764, 61, 3072, -2457, -306);
    floorsG[304] = SurfaceG(2662, -2457, -613, 3072, -2457, -921, 1843, -2457, -921);
    floorsG[305] = SurfaceG(2662, -2457, -613, 2662, -2457, -306, 3072, -2457, -306);
    floorsG[306] = SurfaceG(2662, -2457, -613, 3072, -2457, -306, 3072, -2457, -921);
    floorsG[307] = SurfaceG(2253, -2457, -613, 2662, -2457, -613, 1843, -2457, -921);
    floorsG[308] = SurfaceG(2253, -2457, -613, 1843, -2457, -921, 1843, -2457, -613);
    floorsG[309] = SurfaceG(1843, -2457, -613, 2253, -2457, -306, 2253, -2457, -613);
    floorsG[310] = SurfaceG(1843, -2457, -613, 1434, -2457, -613, 2253, -2457, -306);
    floorsG[311] = SurfaceG(1434, -2457, -613, 1024, -2457, -306, 2253, -2457, -306);
    floorsG[312] = SurfaceG(1434, -2457, -613, 1024, -2457, -921, 1024, -2457, -306);
    floorsG[313] = SurfaceG(1434, -2457, -613, 1434, -2457, -921, 1024, -2457, -921);
    floorsG[314] = SurfaceG(-4453, -2661, -613, -4607, -3071, -306, -4453, -2661, -306);
    floorsG[315] = SurfaceG(-4453, -2661, -613, -4607, -3071, -613, -4607, -3071, -306);
    floorsG[316] = SurfaceG(-4453, -2661, -306, -4146, -2661, -306, -4146, -2661, -613);
    floorsG[317] = SurfaceG(-4453, -2661, -306, -4146, -2661, -613, -4453, -2661, -613);
    floorsG[318] = SurfaceG(-4453, -2743, -306, -4453, -2743, 307, -4146, -2743, 307);
    floorsG[319] = SurfaceG(-4453, -2743, -306, -4146, -2743, 307, -4146, -2743, -306);
    floorsG[320] = SurfaceG(3379, -2764, -347, 4301, -2764, -40, 3994, -2764, -347);
    floorsG[321] = SurfaceG(3379, -2764, -347, 4301, -2764, 573, 4301, -2764, -40);
    floorsG[322] = SurfaceG(3379, -2764, -347, 3072, -2764, -40, 3072, -2764, 573);
    floorsG[323] = SurfaceG(3379, -2764, -347, 3072, -2764, 573, 3379, -2764, 881);
    floorsG[324] = SurfaceG(3379, -2764, -347, 3994, -2764, 881, 4301, -2764, 573);
    floorsG[325] = SurfaceG(3379, -2764, -347, 3379, -2764, 881, 3994, -2764, 881);
    floorsG[326] = SurfaceG(2662, -2764, -347, 2048, -2764, -347, 2048, -2764, 881);
    floorsG[327] = SurfaceG(2662, -2764, -347, 2048, -2764, 881, 2662, -2764, 881);
    floorsG[328] = SurfaceG(3072, -2764, 61, 2662, -2764, 471, 3072, -2764, 471);
    floorsG[329] = SurfaceG(3072, -2764, 61, 2662, -2764, 61, 2662, -2764, 471);
    floorsG[330] = SurfaceG(-7065, -2764, -511, -7986, -2764, 512, -7065, -2764, 512);
    floorsG[331] = SurfaceG(-7065, -2764, -511, -7986, -2764, -511, -7986, -2764, 512);
    floorsG[332] = SurfaceG(-7065, -2764, 307, -6553, -2866, 307, -6553, -2866, -306);
    floorsG[333] = SurfaceG(-7065, -2764, 307, -6553, -2866, -306, -7065, -2764, -306);
    floorsG[334] = SurfaceG(-6553, -2866, 307, -7065, -3071, 322, -6041, -3071, 307);
    floorsG[335] = SurfaceG(-306, -2866, 307, 0, -2866, 922, 0, -2866, -306);
    floorsG[336] = SurfaceG(-306, -2866, 307, 0, -2866, -306, -306, -2866, -306);
    floorsG[337] = SurfaceG(-6041, -2866, -306, -6553, -2866, 307, -6041, -2866, 307);
    floorsG[338] = SurfaceG(-6041, -2866, -306, -6553, -2866, -306, -6553, -2866, 307);
    floorsG[339] = SurfaceG(5222, -2917, 573, 6298, -2917, 573, 6298, -2917, -40);
    floorsG[340] = SurfaceG(5222, -2917, 573, 4301, -2764, -40, 4301, -2764, 573);
    floorsG[341] = SurfaceG(5222, -2917, 573, 5222, -2917, -40, 4301, -2764, -40);
    floorsG[342] = SurfaceG(5222, -2917, 573, 6298, -2917, -40, 5222, -2917, -40);
    floorsG[343] = SurfaceG(-921, -3020, 307, -921, -3020, 922, -306, -2866, 307);
    floorsG[344] = SurfaceG(-921, -3020, 922, 0, -2866, 922, -306, -2866, 307);
    floorsG[345] = SurfaceG(-3993, -3071, -613, -4146, -2661, -306, -3993, -3071, -306);
    floorsG[346] = SurfaceG(-3993, -3071, -613, -4146, -2661, -613, -4146, -2661, -306);
    floorsG[347] = SurfaceG(-7065, -3071, 322, -6553, -2866, 307, -7065, -2866, 307);
    floorsG[348] = SurfaceG(-8191, -3071, 8192, 8192, -3071, -8191, -8191, -3071, -8191, true);
    floorsG[349] = SurfaceG(-8191, -3071, 8192, 8192, -3071, 8192, 8192, -3071, -8191, true);
}

__device__ bool check_inbounds(const float* mario_pos) {
    short x_mod = (short)(int)mario_pos[0];
    short y_mod = (short)(int)mario_pos[1];
    short z_mod = (short)(int)mario_pos[2];

    return x_mod >= -8191 && x_mod <= 8192 && y_mod > -3149 && z_mod >= -8191 && z_mod <= 8192;
}

__global__ void set_platform_pos(float x, float y, float z) {
    platform_pos[0] = x;
    platform_pos[1] = y;
    platform_pos[2] = z;
}

__global__ void init_reverse_atanG() {
    for (int i = 0; i < 8192; i++) {
        gReverseArctanTableG[(unsigned short)gArctanTableG[i]] = i;
    }
}

__global__ void set_start_triangle(short* tris, float* norms) {
    for (int x = 0; x < 2; x++) {
        for (int y = 0; y < 3; y++) {
            startTriangles[x][y][0] = tris[9 * x + 3 * y];
            startTriangles[x][y][1] = tris[9 * x + 3 * y + 1];
            startTriangles[x][y][2] = tris[9 * x + 3 * y + 2];
            startNormals[x][y] = norms[3 * x + y];
            squishTriangles[x][y][0] = tris[18 + 9 * x + 3 * y];
            squishTriangles[x][y][1] = tris[18 + 9 * x + 3 * y + 1];
            squishTriangles[x][y][2] = tris[18 + 9 * x + 3 * y + 2];
            squishNormals[x][y] = norms[6 + 3 * x + y];
        }
    }
}

__global__ void set_platform_normal(float nx, float ny, float nz) {
    platformNormal[0] = nx;
    platformNormal[1] = ny;
    platformNormal[2] = nz;
}

__device__ int16_t atan2_lookupG(float z, float x) {
    int16_t angle = 0;

    if (x == 0) {
        angle = gArctanTableG[0];
    }
    else {
        angle = gArctanTableG[uint16_t(float(float(z / x) * 1024.0 + 0.5))];
    }

    return angle;
}

__device__ int16_t atan2sG(float z, float x) {
    int16_t angle = 0;

    if (x >= 0) {
        if (z >= 0) {
            if (z >= x) {
                angle = atan2_lookupG(x, z);
            }
            else {
                angle = 0x4000 - atan2_lookupG(z, x);
            }
        }
        else {
            z = -z;

            if (z < x) {
                angle = 0x4000 + atan2_lookupG(z, x);
            }
            else {
                angle = 0x8000 - atan2_lookupG(x, z);
            }
        }
    }
    else {
        x = -x;

        if (z < 0) {
            z = -z;

            if (z >= x) {
                angle = 0x8000 + atan2_lookupG(x, z);
            }
            else {
                angle = 0xC000 - atan2_lookupG(z, x);
            }
        }
        else {
            if (z < x) {
                angle = 0xC000 + atan2_lookupG(z, x);
            }
            else {
                angle = -atan2_lookupG(x, z);
            }
        }
    }

    return (short)angle;
}

__device__ int find_ceil(float* pos, short(&triangles)[4][3][3], float(&normals)[4][3], float* pheight) {
    int idx = -1;

    int16_t x = static_cast<int16_t>(static_cast<int>(pos[0]));
    int16_t y = static_cast<int16_t>(static_cast<int>(pos[1]));
    int16_t z = static_cast<int16_t>(static_cast<int>(pos[2]));

    for (int i = 0; i < 4; i++) {
        int16_t x1 = triangles[i][0][0];
        int16_t z1 = triangles[i][0][2];
        int16_t x2 = triangles[i][1][0];
        int16_t z2 = triangles[i][1][2];

        // Check that the point is within the triangle bounds.
        if ((z1 - z) * (x2 - x1) - (x1 - x) * (z2 - z1) > 0) {
            continue;
        }

        // To slightly save on computation time, set this later.
        int16_t x3 = triangles[i][2][0];
        int16_t z3 = triangles[i][2][2];

        if ((z2 - z) * (x3 - x2) - (x2 - x) * (z3 - z2) > 0) {
            continue;
        }
        if ((z3 - z) * (x1 - x3) - (x3 - x) * (z1 - z3) > 0) {
            continue;
        }

        float nx = normals[i][0];
        float ny = normals[i][1];
        float nz = normals[i][2];
        float oo = -(nx * x1 + ny * triangles[i][0][1] + nz * z1);

        // Find the height of the floor at a given location.
        float height = -(x * nx + nz * z + oo) / ny;
        // Checks for floor interaction with a 78 unit buffer.
        if (y - (height - -78.0f) > 0.0f) {
            continue;
        }

        *pheight = height;
        idx = i;
        break;
    }

    //! (Surface Cucking) Since only the first floor is returned and not the highest,
    //  higher floors can be "cucked" by lower floors.
    return idx;
}

__device__ int find_floor(float* pos, short(&triangles)[2][3][3], float(&normals)[2][3], float* pheight) {
    int idx = -1;

    int16_t x = static_cast<int16_t>(static_cast<int>(pos[0]));
    int16_t y = static_cast<int16_t>(static_cast<int>(pos[1]));
    int16_t z = static_cast<int16_t>(static_cast<int>(pos[2]));

    for (int i = 0; i < 2; i++) {
        int16_t x1 = triangles[i][0][0];
        int16_t z1 = triangles[i][0][2];
        int16_t x2 = triangles[i][1][0];
        int16_t z2 = triangles[i][1][2];

        // Check that the point is within the triangle bounds.
        if ((z1 - z) * (x2 - x1) - (x1 - x) * (z2 - z1) < 0) {
            continue;
        }

        // To slightly save on computation time, set this later.
        int16_t x3 = triangles[i][2][0];
        int16_t z3 = triangles[i][2][2];

        if ((z2 - z) * (x3 - x2) - (x2 - x) * (z3 - z2) < 0) {
            continue;
        }
        if ((z3 - z) * (x1 - x3) - (x3 - x) * (z1 - z3) < 0) {
            continue;
        }

        float nx = normals[i][0];
        float ny = normals[i][1];
        float nz = normals[i][2];
        float oo = -(nx * x1 + ny * triangles[i][0][1] + nz * z1);

        // Find the height of the floor at a given location.
        float height = -(x * nx + nz * z + oo) / ny;
        // Checks for floor interaction with a 78 unit buffer.
        if (y - (height + -78.0f) < 0.0f) {
            continue;
        }

        *pheight = height;
        idx = i;
        break;
    }

    //! (Surface Cucking) Since only the first floor is returned and not the highest,
    //  higher floors can be "cucked" by lower floors.
    return idx;
}

__device__ int find_floor(float* position, SurfaceG** floor, float& floor_y, SurfaceG floor_set[], int n_floor_set) {
    short x = (short)(int)position[0];
    short y = (short)(int)position[1];
    short z = (short)(int)position[2];

    int floor_idx = -1;

    for (int i = 0; i < n_floor_set; ++i) {
        if (x < floor_set[i].min_x || x > floor_set[i].max_x || z < floor_set[i].min_z || z > floor_set[i].max_z) {
            continue;
        }

        if ((floor_set[i].vertices[0][2] - z) * (floor_set[i].vertices[1][0] - floor_set[i].vertices[0][0]) - (floor_set[i].vertices[0][0] - x) * (floor_set[i].vertices[1][2] - floor_set[i].vertices[0][2]) < 0) {
            continue;
        }
        if ((floor_set[i].vertices[1][2] - z) * (floor_set[i].vertices[2][0] - floor_set[i].vertices[1][0]) - (floor_set[i].vertices[1][0] - x) * (floor_set[i].vertices[2][2] - floor_set[i].vertices[1][2]) < 0) {
            continue;
        }
        if ((floor_set[i].vertices[2][2] - z) * (floor_set[i].vertices[0][0] - floor_set[i].vertices[2][0]) - (floor_set[i].vertices[2][0] - x) * (floor_set[i].vertices[0][2] - floor_set[i].vertices[2][2]) < 0) {
            continue;
        }

        float height = -(x * floor_set[i].normal[0] + floor_set[i].normal[2] * z + floor_set[i].origin_offset) / floor_set[i].normal[1];

        if (y - (height + -78.0f) < 0.0f) {
            continue;
        }

        floor_y = height;
        *floor = &floor_set[i];
        floor_idx = i;
        break;
    }

    return floor_idx;
}

__global__ void init_camera_angles() {
    for (int i = 0; i < 65536; i += 16) {
        int angle = atan2sG(cossG(i), sinsG(i));
        validCameraAngle[(unsigned short)angle] = true;
    }
}

__global__ void init_mag_set() {
    magCount = 0;

    bool magCheck[4097];

    for (int i = 0; i <= 4096; i++) {
        magCheck[i] = false;
    }

    for (int x = -128; x < 128; x++) {
        for (int y = -128; y < 128; y++) {
            int xS;
            if (x < 8) {
                if (x > -8) {
                    xS = 0;
                }
                else {
                    xS = x + 6;
                }
            }
            else {
                xS = x - 6;
            }
            int yS;
            if (y < 8) {
                if (y > -8) {
                    yS = 0;
                }
                else {
                    yS = y + 6;
                }
            }
            else {
                yS = y - 6;
            }

            int mag2 = xS * xS + yS * yS;
            mag2 = mag2 > 4096 ? 4096 : mag2;

            magCheck[mag2] = true;
        }
    }

    for (int i = 0; i <= 4096; i++) {
        if (magCheck[i]) {
            float mag = sqrtf((float)i);
            mag = (mag / 64.0f) * (mag / 64.0f) * 32.0f;
            magSet[magCount] = mag;
            magCount++;
        }
    }
}

__global__ void init_unique_stick_positions() {
    nUniqueSticks = 0;
    bool angleCheck[65536];

    for (int i = 0; i <= 65536; i++) {
        angleCheck[i] = false;
    }

    for (int xS = -122; xS < 122; xS++) {
        if (abs(xS) == 1) continue;

        for (int yS = -122; yS < 122; yS++) {
            if (abs(yS) == 1) continue;

            int mag = xS * xS + yS * yS;
            int yaw = atan2sG(-yS, xS);
            
            if (mag > 0 && (mag < 4096 || !angleCheck[(unsigned short)yaw])) {
                if (mag >= 4096) {
                    angleCheck[(unsigned short)yaw] = true;
                }
                uniqueSticks[nUniqueSticks][0] = xS + 6 * sign(xS);
                uniqueSticks[nUniqueSticks][1] = yS + 6 * sign(yS);
                nUniqueSticks++;
            }
        }
    }
}

__device__ float find_pre10K_speed(float post10KSpeed, float strainX, float strainZ, float& post10KVelX, float& post10KVelZ, int solIdx) {
    struct SKPhase6* sol6 = &(solutions.sk6Solutions[solIdx]);
    struct SKPhase5* sol5 = &(solutions.sk5Solutions[sol6->p5Idx]);
    struct SKPhase4* sol4 = &(solutions.sk4Solutions[sol5->p4Idx]);
    struct SKPhase3* sol3 = &(solutions.sk3Solutions[sol4->p3Idx]);
    struct SKPhase2* sol2 = (sol3->p2Type / 2 == 0) ? ((sol3->p2Type % 2 == 0) ? &(solutions.sk2ASolutions[sol3->p2Idx]) : &(solutions.sk2BSolutions[sol3->p2Idx])) : ((sol3->p2Type % 2 == 0) ? &(solutions.sk2CSolutions[sol3->p2Idx]) : &(solutions.sk2DSolutions[sol3->p2Idx]));

    float pre10KSpeed = NAN;
    post10KVelX = NAN;
    post10KVelZ = NAN;

    float mag = sqrtf((float)(sol5->stickX * sol5->stickX + sol5->stickY * sol5->stickY));

    float xS = sol5->stickX;
    float yS = sol5->stickY;

    if (mag > 64.0f) {
        xS = xS * (64.0f / mag);
        yS = yS * (64.0f / mag);
        mag = 64.0f;
    }

    float intendedMag = ((mag / 64.0f) * (mag / 64.0f)) * 32.0f;
    int intendedYaw = atan2sG(-yS, xS) + sol4->cameraYaw;
    int intendedDYaw = intendedYaw - sol5->f1Angle;

    double w = intendedMag * cossG(intendedDYaw);
    double eqB = (50.0 + 147200.0 / w);
    double eqC = -(320000.0 / w) * post10KSpeed;
    double eqDet = eqB * eqB - eqC;

    if (eqDet >= 0) {
        pre10KSpeed = sqrt(eqDet) - eqB;

        if (pre10KSpeed >= 0) {
            bool searchLoop = true;

            float upperSpeed = 2.0f * pre10KSpeed;
            float lowerSpeed = 0.0f;

            while (searchLoop) {
                pre10KSpeed = fmaxf((upperSpeed + lowerSpeed) / 2.0f, nextafterf(lowerSpeed, INFINITY));

                float pre10KVelX = (pre10KSpeed * sinsG(sol2->f2Angle)) + strainX;
                float pre10KVelZ = (pre10KSpeed * cossG(sol2->f2Angle)) + strainZ;

                post10KVelX = pre10KVelX;
                post10KVelZ = pre10KVelZ;

                float oldSpeed = sqrtf(post10KVelX * post10KVelX + post10KVelZ * post10KVelZ);

                post10KVelX += post10KVelZ * (intendedMag / 32.0f) * sinsG(intendedDYaw) * 0.05f;
                post10KVelZ -= post10KVelX * (intendedMag / 32.0f) * sinsG(intendedDYaw) * 0.05f;

                float newSpeed = sqrtf(post10KVelX * post10KVelX + post10KVelZ * post10KVelZ);

                post10KVelX = post10KVelX * oldSpeed / newSpeed;
                post10KVelZ = post10KVelZ * oldSpeed / newSpeed;

                post10KVelX += 7.0f * tenKFloors[sol2->tenKFloorIdx][6];
                post10KVelZ += 7.0f * tenKFloors[sol2->tenKFloorIdx][8];

                float forward = cossG(intendedDYaw) * (0.5f + 0.5f * pre10KSpeed / 100.0f);
                float lossFactor = intendedMag / 32.0f * forward * 0.02f + 0.92f;

                post10KVelX *= lossFactor;
                post10KVelZ *= lossFactor;

                float post10KSpeedTest = -sqrtf(post10KVelX * post10KVelX + post10KVelZ * post10KVelZ);

                if (post10KSpeedTest == post10KSpeed) {
                    searchLoop = false;
                }
                else {
                    if (post10KSpeedTest < post10KSpeed) {
                        upperSpeed = pre10KSpeed;
                    }
                    else {
                        lowerSpeed = pre10KSpeed;
                    }

                    if (nextafterf(lowerSpeed, INFINITY) == upperSpeed) {
                        searchLoop = false;
                        pre10KSpeed = NAN;
                        post10KVelX = NAN;
                        post10KVelZ = NAN;
                    }
                }
            }
        }
    }

    return pre10KSpeed;
}

__device__ void adjust_position_to_ints(float* a, float* b, float p[2][3]) {
    short x1 = (short)(int)a[0];
    short z1 = (short)(int)a[2];

    int roundDirX = (x1 > a[0]) - (x1 < a[0]);
    int roundDirZ = (z1 > a[2]) - (z1 < a[2]);

    float z2 = ((double)p[1][2] - (double)p[0][2]) * ((double)x1 - (double)p[0][0]) / ((double)p[1][0] - (double)p[0][0]) + (double)p[0][2];
    float x2 = ((double)p[1][0] - (double)p[0][0]) * ((double)z1 - (double)p[0][2]) / ((double)p[1][2] - (double)p[0][2]) + (double)p[0][0];

    int lookDirX = (x2 > x1) - (x2 < x1);
    int lookDirZ = (z2 > z1) - (z2 < z1);

    x2 = (short)(int)x2 - roundDirX;
    z2 = (short)(int)z2 - roundDirZ;

    x2 = (lookDirX == roundDirX) ? nextafterf(x2, roundDirX * INFINITY) : x2;
    z2 = (lookDirZ == roundDirZ) ? nextafterf(z2, roundDirZ * INFINITY) : z2;

    double rX = ((double)x2 - (double)a[0]) / ((double)b[0] - (double)a[0]);
    double rZ = ((double)z2 - (double)a[2]) / ((double)b[2] - (double)a[2]);

    if (fabs(rX) < fabs(rZ)) {
        a[0] = (b[0] - a[0]) * rX + a[0];
        a[1] = (b[1] - a[1]) * rX + a[1];
        a[2] = (b[2] - a[2]) * rX + a[2];
    }
    else {
        a[0] = (b[0] - a[0]) * rZ + a[0];
        a[1] = (b[1] - a[1]) * rZ + a[1];
        a[2] = (b[2] - a[2]) * rZ + a[2];
    }
}

__global__ void test_speed_solution(int* squishEdges, const int nPoints, float floorNormalY, int uphillAngle, float maxSlidingSpeed, float maxSlidingSpeedToPlatform) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(counts.nSpeedSolutions, limits.MAX_SPEED_SOLUTIONS)) {
        struct SpeedSolution* sol = &(solutions.speedSolutions[idx]);
        struct SKUpwarpSolution* skuwSol = &(solutions.skuwSolutions[sol->skuwSolutionIdx]);
        struct UpwarpSolution* uwSol = &(solutions.upwarpSolutions[skuwSol->uwIdx]);
        struct PlatformSolution* platSol = &(solutions.platSolutions[uwSol->platformSolutionIdx]);
        struct SKPhase6* sol6 = &(solutions.sk6Solutions[skuwSol->skIdx]);
        struct SKPhase5* sol5 = &(solutions.sk5Solutions[sol6->p5Idx]);
        struct SKPhase4* sol4 = &(solutions.sk4Solutions[sol5->p4Idx]);
        struct SKPhase3* sol3 = &(solutions.sk3Solutions[sol4->p3Idx]);
        struct SKPhase2* sol2 = (sol3->p2Type / 2 == 0) ? ((sol3->p2Type % 2 == 0) ? &(solutions.sk2ASolutions[sol3->p2Idx]) : &(solutions.sk2BSolutions[sol3->p2Idx])) : ((sol3->p2Type % 2 == 0) ? &(solutions.sk2CSolutions[sol3->p2Idx]) : &(solutions.sk2DSolutions[sol3->p2Idx]));
        struct SKPhase1* sol1 = &(solutions.sk1Solutions[sol2->p1Idx]);

        float returnVelX;
        float returnVelZ;
        float pre10KSpeed = find_pre10K_speed(sol->returnSpeed, sol->xStrain, sol->zStrain, returnVelX, returnVelZ, skuwSol->skIdx);

        if (!isnan(pre10KSpeed)) {
            float frame2Position[3] = { platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (returnVelX / 4.0f), platSol->returnPosition[1], platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (returnVelZ / 4.0f) };

            SurfaceG* floor;
            float floorHeight;

            int floorIdx = find_floor(frame2Position, &floor, floorHeight, floorsG, total_floorsG);

            if (floorIdx != -1 && floor->normal[1] == tenKFloors[sol2->tenKFloorIdx][7] && floorHeight < platSol->returnPosition[1] && floorHeight >= platSol->returnPosition[1] - 78.0f && floorHeight > -2971.0f) {
                int returnSlideYaw = atan2sG(returnVelZ, returnVelX);

                if ((unsigned short)returnSlideYaw == (unsigned short)sol6->f3Angle) {
                    int newFacingDYaw = (short)(sol2->f2Angle - returnSlideYaw);

                    if (newFacingDYaw > 0 && newFacingDYaw <= 0x4000) {
                        if ((newFacingDYaw -= 0x200) < 0) {
                            newFacingDYaw = 0;
                        }
                    }
                    else if (newFacingDYaw > -0x4000 && newFacingDYaw < 0) {
                        if ((newFacingDYaw += 0x200) > 0) {
                            newFacingDYaw = 0;
                        }
                    }
                    else if (newFacingDYaw > 0x4000 && newFacingDYaw < 0x8000) {
                        if ((newFacingDYaw += 0x200) > 0x8000) {
                            newFacingDYaw = 0x8000;
                        }
                    }
                    else if (newFacingDYaw > -0x8000 && newFacingDYaw < -0x4000) {
                        if ((newFacingDYaw -= 0x200) < -0x8000) {
                            newFacingDYaw = -0x8000;
                        }
                    }

                    int returnFaceAngle = returnSlideYaw + newFacingDYaw;

                    float postReturnVelX = sol->returnSpeed * sinsG(returnFaceAngle);
                    float postReturnVelZ = sol->returnSpeed * cossG(returnFaceAngle);

                    float intendedPosition[3] = { platSol->returnPosition[0] + postReturnVelX / 4.0f, platSol->returnPosition[1], platSol->returnPosition[2] + postReturnVelZ / 4.0f };

                    bool outOfBoundsTest = !check_inbounds(intendedPosition);

                    for (int f = 0; outOfBoundsTest && f < 3; f++) {
                        intendedPosition[0] = platSol->landingPositions[f][0] + platSol->landingFloorNormalsY[f] * (postReturnVelX / 4.0f);
                        intendedPosition[1] = platSol->landingPositions[f][1];
                        intendedPosition[2] = platSol->landingPositions[f][2] + platSol->landingFloorNormalsY[f] * (postReturnVelZ / 4.0f);

                        outOfBoundsTest = !check_inbounds(intendedPosition);
                    }

                    if (outOfBoundsTest) {
                        frame2Position[1] = floorHeight;

                        float pre10KVelX = pre10KSpeed * sinsG(sol2->f2Angle) + sol->xStrain;
                        float pre10KVelZ = pre10KSpeed * cossG(sol2->f2Angle) + sol->zStrain;

                        float frame1Position[3] = { frame2Position[0], frame2Position[1], frame2Position[2] };

                        bool inBoundsTest = true;

                        for (int q = 0; q < sol1->q2; q++) {
                            frame1Position[0] = frame1Position[0] - (pre10KVelX / 4.0f);
                            frame1Position[2] = frame1Position[2] - (pre10KVelZ / 4.0f);

                            if (!check_inbounds(frame1Position)) {
                                inBoundsTest = false;
                                break;
                            }
                        }

                        if (inBoundsTest) {
                            floorIdx = find_floor(frame1Position, startTriangles, startNormals, &floorHeight);

                            if (floorIdx != -1 && startNormals[floorIdx][1] == floorNormalY && floorHeight + (sol1->q2 * 20.0f / 4.0f) < frame2Position[1] && floorHeight + (sol1->q2 * 20.0f / 4.0f) >= frame2Position[1] - 78.0f && floorHeight > -3071.0f) {
                                frame1Position[1] = floorHeight;

                                float startSpeed = pre10KSpeed + 1.0f;
                                startSpeed = startSpeed - sol->forwardStrain;
                                startSpeed = startSpeed + 0.35f;

                                float startPositions[2][2][3];
                                int intersectionIdxs[2];
                                int intersections = 0;

                                for (int i = 0; i < nPoints; i++) {
                                    if (squishEdges[i] != -1 && nSquishSpots[squishEdges[i]] > 0) {
                                        int surfAngle = atan2sG(squishCeilingNormals[squishEdges[i]][2], squishCeilingNormals[squishEdges[i]][0]);

                                        float xPushVel = sinsG(surfAngle) * 10.0f;
                                        float zPushVel = cossG(surfAngle) * 10.0f;

                                        int squishFloorIdx = (squishEdges[i] == 0 || squishEdges[i] == 2) ? 0 : 1;

                                        float xOffset = squishNormals[squishFloorIdx][1] * (xPushVel / 4.0f);
                                        float zOffset = squishNormals[squishFloorIdx][1] * (zPushVel / 4.0f);

                                        float p[2][3];
                                        float q[2][3];
                                        int pIdx = 0;

                                        for (int j = 0; j < 3; j++) {
                                            if (squishCeilingTriangles[squishEdges[i]][j][0] != platform_pos[0] || squishCeilingTriangles[squishEdges[i]][j][1] != platform_pos[1] || startCeilingTriangles[squishEdges[i]][j][2] != platform_pos[2]) {
                                                float oo = -(startNormals[squishFloorIdx][0] * startTriangles[squishFloorIdx][0][0] + startNormals[squishFloorIdx][1] * startTriangles[squishFloorIdx][0][1] + startNormals[squishFloorIdx][2] * startTriangles[squishFloorIdx][0][2]);

                                                p[pIdx][0] = squishCeilingTriangles[squishEdges[i]][j][0] + xOffset;
                                                p[pIdx][2] = squishCeilingTriangles[squishEdges[i]][j][2] + zOffset;
                                                p[pIdx][1] = -(p[pIdx][0] * startNormals[squishFloorIdx][0] + startNormals[squishFloorIdx][2] * p[pIdx][2] + oo) / startNormals[squishFloorIdx][1];

                                                q[pIdx][0] = squishCeilingTriangles[squishEdges[i]][j][0];
                                                q[pIdx][2] = squishCeilingTriangles[squishEdges[i]][j][2];
                                                q[pIdx][1] = -(q[pIdx][0] * startNormals[squishFloorIdx][0] + startNormals[squishFloorIdx][2] * q[pIdx][2] + oo) / startNormals[squishFloorIdx][1];

                                                pIdx++;
                                            }
                                        }

                                        double eqA1 = ((double)p[1][0] - (double)p[0][0]) * ((double)p[1][0] - (double)p[0][0]) + ((double)p[1][2] - (double)p[0][2]) * ((double)p[1][2] - (double)p[0][2]);
                                        double eqB1 = 2.0 * (((double)p[1][0] - (double)p[0][0]) * ((double)p[0][0] - frame1Position[0]) + ((double)p[1][2] - (double)p[0][2]) * ((double)p[0][2] - frame1Position[2]));
                                        double eqC1 = ((double)p[0][0] - frame1Position[0]) * ((double)p[0][0] - frame1Position[0]) + ((double)p[0][2] - frame1Position[2]) * ((double)p[0][2] - frame1Position[2]) - ((double)startSpeed * (double)floorNormalY) * ((double)startSpeed * (double)floorNormalY);
                                        double eqDet1 = eqB1 * eqB1 - 4.0 * eqA1 * eqC1;

                                        double eqA2 = ((double)q[1][0] - (double)q[0][0]) * ((double)q[1][0] - (double)q[0][0]) + ((double)q[1][2] - (double)q[0][2]) * ((double)q[1][2] - (double)q[0][2]);
                                        double eqB2 = 2.0 * (((double)q[1][0] - (double)q[0][0]) * ((double)q[0][0] - frame1Position[0]) + ((double)q[1][2] - (double)q[0][2]) * ((double)q[0][2] - frame1Position[2]));
                                        double eqC2 = ((double)q[0][0] - frame1Position[0]) * ((double)q[0][0] - frame1Position[0]) + ((double)q[0][2] - frame1Position[2]) * ((double)q[0][2] - frame1Position[2]) - ((double)startSpeed * (double)floorNormalY) * ((double)startSpeed * (double)floorNormalY);
                                        double eqDet2 = eqB2 * eqB2 - 4.0 * eqA2 * eqC2;

                                        if (eqDet1 >= 0 && eqDet2 >= 0) {
                                            double s = (-eqB1 + sqrt(eqDet1)) / (2.0 * eqA1);
                                            double t = (-eqB2 + sqrt(eqDet2)) / (2.0 * eqA2);

                                            if (s >= 0.0 && s <= 1.0 || t >= 0.0 && t <= 1.0) {
                                                intersectionIdxs[intersections] = squishEdges[i];
                                                startPositions[intersections][0][0] = ((double)p[1][0] - (double)p[0][0]) * s + (double)p[0][0];
                                                startPositions[intersections][0][1] = ((double)p[1][1] - (double)p[0][1]) * s + (double)p[0][1];
                                                startPositions[intersections][0][2] = ((double)p[1][2] - (double)p[0][2]) * s + (double)p[0][2];
                                                startPositions[intersections][1][0] = ((double)q[1][0] - (double)q[0][0]) * t + (double)q[0][0];
                                                startPositions[intersections][1][1] = ((double)q[1][1] - (double)q[0][1]) * t + (double)q[0][1];
                                                startPositions[intersections][1][2] = ((double)q[1][2] - (double)q[0][2]) * t + (double)q[0][2];

                                                adjust_position_to_ints(startPositions[intersections][0], startPositions[intersections][1], p);
                                                adjust_position_to_ints(startPositions[intersections][1], startPositions[intersections][0], q);

                                                intersections++;
                                                continue;
                                            }

                                            s = (-eqB1 - sqrt(eqDet1)) / (2.0 * eqA1);
                                            t = (-eqB2 - sqrt(eqDet2)) / (2.0 * eqA2);

                                            if (s >= 0.0 && s <= 1.0 || t >= 0.0 && t <= 1.0) {
                                                intersectionIdxs[intersections] = squishEdges[i];
                                                startPositions[intersections][0][0] = ((double)p[1][0] - (double)p[0][0]) * s + (double)p[0][0];
                                                startPositions[intersections][0][1] = ((double)p[1][1] - (double)p[0][1]) * s + (double)p[0][1];
                                                startPositions[intersections][0][2] = ((double)p[1][2] - (double)p[0][2]) * s + (double)p[0][2];
                                                startPositions[intersections][1][0] = ((double)q[1][0] - (double)q[0][0]) * t + (double)q[0][0];
                                                startPositions[intersections][1][1] = ((double)q[1][1] - (double)q[0][1]) * t + (double)q[0][1];
                                                startPositions[intersections][1][2] = ((double)q[1][2] - (double)q[0][2]) * t + (double)q[0][2];

                                                adjust_position_to_ints(startPositions[intersections][0], startPositions[intersections][1], p);
                                                adjust_position_to_ints(startPositions[intersections][1], startPositions[intersections][0], q);

                                                intersections++;
                                            }
                                        }
                                    }
                                }

                                for (int i = 0; i < intersections; i++) {
                                    float lowestPos = nextafterf(-2971.0f, INFINITY);
                                    float highestPos = nextafterf(-2921.0f - (52.0f * sqrtf(1.0f - floorNormalY * floorNormalY) / floorNormalY), -INFINITY);

                                    if (startPositions[i][0][1] < lowestPos) {
                                        if (startPositions[i][1][1] < lowestPos) {
                                            continue;
                                        }
                                        else {
                                            double t = (lowestPos - startPositions[i][0][1]) / (startPositions[i][1][1] - startPositions[i][0][1]);
                                            startPositions[i][0][0] = (startPositions[i][1][0] - startPositions[i][0][0]) * t + startPositions[i][0][0];
                                            startPositions[i][0][1] = (startPositions[i][1][1] - startPositions[i][0][1]) * t + startPositions[i][0][1];
                                            startPositions[i][0][2] = (startPositions[i][1][2] - startPositions[i][0][2]) * t + startPositions[i][0][2];
                                        }
                                    }
                                    else if (startPositions[i][1][1] < lowestPos) {
                                        double t = (lowestPos - startPositions[i][0][1]) / (startPositions[i][1][1] - startPositions[i][0][1]);
                                        startPositions[i][1][0] = (startPositions[i][1][0] - startPositions[i][0][0]) * t + startPositions[i][0][0];
                                        startPositions[i][1][1] = (startPositions[i][1][1] - startPositions[i][0][1]) * t + startPositions[i][0][1];
                                        startPositions[i][1][2] = (startPositions[i][1][2] - startPositions[i][0][2]) * t + startPositions[i][0][2];
                                    }

                                    if (startPositions[i][0][1] > highestPos) {
                                        if (startPositions[i][1][1] > highestPos) {
                                            continue;
                                        }
                                        else {
                                            double t = (highestPos - startPositions[i][0][1]) / (startPositions[i][1][1] - startPositions[i][0][1]);
                                            startPositions[i][0][0] = (startPositions[i][1][0] - startPositions[i][0][0]) * t + startPositions[i][0][0];
                                            startPositions[i][0][1] = (startPositions[i][1][1] - startPositions[i][0][1]) * t + startPositions[i][0][1];
                                            startPositions[i][0][2] = (startPositions[i][1][2] - startPositions[i][0][2]) * t + startPositions[i][0][2];
                                        }
                                    }
                                    else if (startPositions[i][1][1] > highestPos) {
                                        double t = (highestPos - startPositions[i][0][1]) / (startPositions[i][1][1] - startPositions[i][0][1]);
                                        startPositions[i][1][0] = (startPositions[i][1][0] - startPositions[i][0][0]) * t + startPositions[i][0][0];
                                        startPositions[i][1][1] = (startPositions[i][1][1] - startPositions[i][0][1]) * t + startPositions[i][0][1];
                                        startPositions[i][1][2] = (startPositions[i][1][2] - startPositions[i][0][2]) * t + startPositions[i][0][2];

                                    }

                                    int f1Angle0 = atan2sG(frame1Position[2] - startPositions[i][0][2], frame1Position[0] - startPositions[i][0][0]);
                                    int f1Angle1 = atan2sG(frame1Position[2] - startPositions[i][1][2], frame1Position[0] - startPositions[i][1][0]);

                                    if ((unsigned short)(f1Angle1 - f1Angle0) > 32768) {
                                        int temp = f1Angle0;
                                        f1Angle0 = f1Angle1;
                                        f1Angle1 = temp;
                                    }

                                    if ((unsigned short)(sol5->f1Angle - f1Angle0) <= (unsigned short)(f1Angle1 - f1Angle0)) {
                                        float minBullyX = INFINITY;
                                        float maxBullyX = -INFINITY;
                                        float minBullyZ = INFINITY;
                                        float maxBullyZ = -INFINITY;
                                        int minPushAngle = INT_MAX;
                                        int maxPushAngle = INT_MIN;
                                        int refPushAngle = 65536;

                                        const float accel = 7.0f;
                                        const float pushRadius = 115.0f;
                                        const float bullyHurtbox = 63.0f;
                                        const float baseBullySpeed = powf(2.0f, 24);
                                        const float maxBullySpeed = nextafterf(powf(2.0f, 30), -INFINITY);

                                        int surfAngle = atan2sG(squishCeilingNormals[intersectionIdxs[i]][2], squishCeilingNormals[intersectionIdxs[i]][0]);

                                        float xPushVel = sinsG(surfAngle) * 10.0f;
                                        float zPushVel = cossG(surfAngle) * 10.0f;

                                        int squishFloorIdx = (intersectionIdxs[i] == 0 || intersectionIdxs[i] == 2) ? 0 : 1;

                                        int slopeAngle = atan2sG(startNormals[squishFloorIdx][2], startNormals[squishFloorIdx][0]);

                                        float steepness = sqrtf(startNormals[squishFloorIdx][0] * startNormals[squishFloorIdx][0] + startNormals[squishFloorIdx][2] * startNormals[squishFloorIdx][2]);

                                        float slopeXVel = accel * steepness * sinsG(slopeAngle);
                                        float slopeZVel = accel * steepness * cossG(slopeAngle);

                                        for (int j = 0; j < 2; j++) {
                                            float currentX = startPositions[i][j][0];
                                            float currentZ = startPositions[i][j][2];

                                            for (int k = 0; k < 3; k++) {
                                                float bullyPushX = currentX - xPushVel / 4.0f;
                                                float bullyPushZ = currentZ - zPushVel / 4.0f;

                                                int minAngle = INT_MAX;
                                                int maxAngle = INT_MIN;
                                                int refAngle = 65536;

                                                for (int l = 0; l < min(nSquishSpots[intersectionIdxs[i]], limits.MAX_SQUISH_SPOTS); l++) {
                                                    float signX = sign(squishSpots[(2 * intersectionIdxs[i] * limits.MAX_SQUISH_SPOTS) + (2 * l)]);
                                                    float signZ = sign(squishSpots[(2 * intersectionIdxs[i] * limits.MAX_SQUISH_SPOTS) + (2 * l) + 1]);

                                                    for (int m = 0; m < 4; m++) {
                                                        float xDist = bullyPushX - (squishSpots[(2 * intersectionIdxs[i] * limits.MAX_SQUISH_SPOTS) + (2 * l)] + signX * (m % 2));
                                                        float zDist = bullyPushZ - (squishSpots[(2 * intersectionIdxs[i] * limits.MAX_SQUISH_SPOTS) + (2 * l) + 1] + signZ * (m / 2));

                                                        float dist = sqrtf(xDist * xDist + zDist * zDist);

                                                        if (dist >= pushRadius - bullyHurtbox && dist <= pushRadius - fmaxf(bullyHurtbox - 2.0f * maxSlidingSpeed - 1.85f, 0.0f)) {
                                                            int angle = (unsigned short)atan2sG(zDist, xDist);

                                                            int angleDiff = (short)(angle - uphillAngle);

                                                            if (angleDiff < -0x4000 || angleDiff > 0x4000) {
                                                                if (refAngle == 65536) {
                                                                    refAngle = angle;
                                                                }

                                                                minAngle = min(minAngle, (int)(short)(angle - refAngle));
                                                                maxAngle = max(maxAngle, (int)(short)(angle - refAngle));
                                                            }
                                                        }
                                                    }
                                                }

                                                if (refAngle != 65536) {
                                                    minAngle = (unsigned short)(minAngle + refAngle);
                                                    maxAngle = (unsigned short)(maxAngle + refAngle);

                                                    if (minAngle > maxAngle) {
                                                        minBullyX = fminf(minBullyX, bullyPushX - pushRadius);
                                                    }
                                                    else {
                                                        minBullyX = fminf(minBullyX, bullyPushX - pushRadius * sinsG(minAngle));
                                                        minBullyX = fminf(minBullyX, bullyPushX - pushRadius * sinsG(maxAngle));
                                                    }

                                                    if (minAngle < 16384 && maxAngle > 16384) {
                                                        minBullyZ = fminf(minBullyZ, bullyPushZ - pushRadius);
                                                    }
                                                    else {
                                                        minBullyZ = fminf(minBullyZ, bullyPushZ - pushRadius * cossG(minAngle));
                                                        minBullyZ = fminf(minBullyZ, bullyPushZ - pushRadius * cossG(maxAngle));
                                                    }

                                                    if (minAngle < 32768 && maxAngle > 32768) {
                                                        maxBullyX = fmaxf(maxBullyX, bullyPushX - pushRadius);
                                                    }
                                                    else {
                                                        maxBullyX = fmaxf(maxBullyX, bullyPushX - pushRadius * sinsG(minAngle));
                                                        maxBullyX = fmaxf(maxBullyX, bullyPushX - pushRadius * sinsG(maxAngle));
                                                    }

                                                    if (minAngle < 49152 && maxAngle > 49152) {
                                                        maxBullyZ = fmaxf(maxBullyZ, bullyPushZ - pushRadius);
                                                    }
                                                    else {
                                                        maxBullyZ = fmaxf(maxBullyZ, bullyPushZ - pushRadius * cossG(minAngle));
                                                        maxBullyZ = fmaxf(maxBullyZ, bullyPushZ - pushRadius * cossG(maxAngle));
                                                    }

                                                    if (refPushAngle == 65536) {
                                                        refPushAngle = minAngle;
                                                    }

                                                    minPushAngle = min(minPushAngle, (int)(short)(minAngle - refAngle));
                                                    maxPushAngle = max(maxPushAngle, (int)(short)(maxAngle - refAngle));
                                                }

                                                currentX = currentX - squishNormals[squishFloorIdx][1] * xPushVel / 4.0f;
                                                currentZ = currentZ - squishNormals[squishFloorIdx][1] * zPushVel / 4.0f;
                                            }
                                        }

                                        if (refPushAngle != 65536) {
                                            minPushAngle = minPushAngle + refPushAngle;
                                            maxPushAngle = maxPushAngle + refPushAngle;

                                            float xDiff2;

                                            if (minBullyX == maxBullyX) {
                                                int precision;
                                                frexpf(minBullyX, &precision);
                                                xDiff2 = powf(2.0f, precision - 24);
                                            }
                                            else {
                                                xDiff2 = powf(2.0f, floorf(log2f(maxBullyX - minBullyX)));

                                                while (floorf(maxBullyX / (2.0f * xDiff2)) >= ceilf(minBullyX / (2.0f * xDiff2))) {
                                                    xDiff2 = xDiff2 * 2.0f;
                                                }
                                            }

                                            float zDiff2;

                                            if (minBullyZ == maxBullyZ) {
                                                int precision;
                                                frexpf(minBullyZ, &precision);
                                                zDiff2 = powf(2.0f, precision - 24);
                                            }
                                            else {
                                                zDiff2 = powf(2.0f, floorf(log2f(maxBullyZ - minBullyZ)));

                                                while (floorf(maxBullyZ / (2.0f * zDiff2)) >= ceilf(minBullyZ / (2.0f * zDiff2))) {
                                                    zDiff2 = zDiff2 * 2.0f;
                                                }
                                            }

                                            float maxBullyXSpeed = fminf(nextafterf(xDiff2 * baseBullySpeed, -INFINITY), maxBullySpeed);
                                            float maxBullyZSpeed = fminf(nextafterf(zDiff2 * baseBullySpeed, -INFINITY), maxBullySpeed);

                                            float maxPushSpeed;

                                            int maxSpeedAngle = atan2sG(maxBullyXSpeed, maxBullyZSpeed);

                                            if ((unsigned short)(maxSpeedAngle - minPushAngle) <= (unsigned short)(maxPushAngle - minPushAngle)) {
                                                maxPushSpeed = (fabsf(maxBullyXSpeed * sinsG(maxSpeedAngle)) + fabsf(maxBullyZSpeed * cossG(maxSpeedAngle))) * (73.0f / 53.0f) * 3.0f;
                                            }
                                            else {
                                                float minAngleSpeed = (fabsf(maxBullyXSpeed * sinsG(minPushAngle)) + fabsf(maxBullyZSpeed * cossG(minPushAngle))) * (73.0f / 53.0f) * 3.0f;
                                                float maxAngleSpeed = (fabsf(maxBullyXSpeed * sinsG(maxPushAngle)) + fabsf(maxBullyZSpeed * cossG(maxPushAngle))) * (73.0f / 53.0f) * 3.0f;
                                                maxPushSpeed = fmaxf(minAngleSpeed, maxAngleSpeed);
                                            }

                                            float maxLossFactor = (-1.0 * (0.5f + 0.5f * maxPushSpeed / 100.0f)) * 0.02 + 0.92;

                                            float post10KXVel = (frame1Position[0] - ((startPositions[i][0][0] + startPositions[i][1][0]) / 2.0f)) / startNormals[squishFloorIdx][1];
                                            float post10KZVel = (frame1Position[2] - ((startPositions[i][0][2] + startPositions[i][1][2]) / 2.0f)) / startNormals[squishFloorIdx][1];

                                            float slidingSpeedX = (post10KXVel / maxLossFactor) - slopeXVel;
                                            float slidingSpeedZ = (post10KZVel / maxLossFactor) - slopeZVel;

                                            float slidingSpeedToPlatformOptions[4] = { -slidingSpeedX, slidingSpeedZ, -slidingSpeedZ, slidingSpeedX };

                                            float slidingSpeedToPlatform = slidingSpeedToPlatformOptions[intersectionIdxs[i]];

                                            if (fabsf(slidingSpeedX) <= maxSlidingSpeed && fabsf(slidingSpeedZ) <= maxSlidingSpeed && slidingSpeedToPlatform <= maxSlidingSpeedToPlatform) {
                                                int solIdx = atomicAdd(&(counts.n10KSolutions), 1);

                                                if (solIdx < limits.MAX_10K_SOLUTIONS) {

                                                    struct TenKSolution* solution = &(solutions.tenKSolutions[solIdx]);
                                                    solution->speedSolutionIdx = idx;
                                                    solution->departureSpeed = startSpeed;
                                                    solution->pre10KVel[0] = pre10KVelX;
                                                    solution->pre10KVel[1] = pre10KVelZ;
                                                    solution->returnVel[0] = returnVelX;
                                                    solution->returnVel[1] = returnVelZ;
                                                    solution->frame2Position[0] = frame2Position[0];
                                                    solution->frame2Position[1] = frame2Position[1];
                                                    solution->frame2Position[2] = frame2Position[2];
                                                    solution->frame1Position[0] = frame1Position[0];
                                                    solution->frame1Position[1] = frame1Position[1];
                                                    solution->frame1Position[2] = frame1Position[2];
                                                    solution->startPosition[0][0] = startPositions[i][0][0];
                                                    solution->startPosition[0][1] = startPositions[i][0][1];
                                                    solution->startPosition[0][2] = startPositions[i][0][2];
                                                    solution->startPosition[1][0] = startPositions[i][1][0];
                                                    solution->startPosition[1][1] = startPositions[i][1][1];
                                                    solution->startPosition[1][2] = startPositions[i][1][2];
                                                    solution->squishCeiling = intersectionIdxs[i];
                                                    solution->bdSetups = 0;
                                                    solution->bpSetups = 0;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

__global__ void find_speed_solutions() {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    int strainIdx = idx % min(nStrainSetups, limits.MAX_STRAIN_SETUPS);
    idx = idx / min(nStrainSetups, limits.MAX_STRAIN_SETUPS);

    if (idx < min(counts.nSKUWSolutions, limits.MAX_SK_UPWARP_SOLUTIONS)) {
        struct StrainSetup* strain = &(strainSetups[strainIdx]);

        struct SKUpwarpSolution* sol = &(solutions.skuwSolutions[idx]);
        struct UpwarpSolution* uwSol = &(solutions.upwarpSolutions[sol->uwIdx]);
        struct PlatformSolution* platSol = &(solutions.platSolutions[uwSol->platformSolutionIdx]);

        struct SKPhase6* sol6 = &(solutions.sk6Solutions[sol->skIdx]);
        struct SKPhase5* sol5 = &(solutions.sk5Solutions[sol6->p5Idx]);
        struct SKPhase4* sol4 = &(solutions.sk4Solutions[sol5->p4Idx]);
        struct SKPhase3* sol3 = &(solutions.sk3Solutions[sol4->p3Idx]);
        struct SKPhase2* sol2 = (sol3->p2Type / 2 == 0) ? ((sol3->p2Type % 2 == 0) ? &(solutions.sk2ASolutions[sol3->p2Idx]) : &(solutions.sk2BSolutions[sol3->p2Idx])) : ((sol3->p2Type % 2 == 0) ? &(solutions.sk2CSolutions[sol3->p2Idx]) : &(solutions.sk2DSolutions[sol3->p2Idx]));
        struct SKPhase1* sol1 = &(solutions.sk1Solutions[sol2->p1Idx]);

        float signF = sign(strain->forwardStrain);
        float fStrain = strain->forwardStrain;
        float prevFStrain = strain->forwardStrain - signF*1.5f/(float)maxFSpeedLevels;

        fStrain = roundf(fStrain / sol->speedRange) * sol->speedRange;
        prevFStrain = roundf(prevFStrain / sol->speedRange) * sol->speedRange;

        float signS = sign(strain->sidewardStrain);
        float prevSStrain = strain->sidewardStrain - signS * 10.0f / (float)maxSSpeedLevels;

        float xStrain = strain->sidewardStrain * cossG(sol2->f2Angle);
        float zStrain = strain->sidewardStrain * -sinsG(sol2->f2Angle);

        float prevXStrain = prevSStrain - signS * 1.5f / (float)maxSSpeedLevels;
        float prevZStrain = prevSStrain - signS * 1.5f / (float)maxSSpeedLevels;

        xStrain = roundf(xStrain / sol->xVelRange) * sol->xVelRange;
        zStrain = roundf(zStrain / sol->zVelRange) * sol->zVelRange;

        prevXStrain = roundf(prevXStrain / sol->xVelRange) * sol->xVelRange;
        prevZStrain = roundf(prevZStrain / sol->zVelRange) * sol->zVelRange;

        if ((strain->forwardStrain == 0.0f && strain->sidewardStrain == 0.0f) || fStrain != prevFStrain || xStrain != prevXStrain || zStrain != prevZStrain) {
            float minX = 65536.0f * sol3->x2 + tenKFloors[sol2->tenKFloorIdx][0];
            float maxX = 65536.0f * sol3->x2 + tenKFloors[sol2->tenKFloorIdx][1];
            float minZ = 65536.0f * sol3->z2 + tenKFloors[sol2->tenKFloorIdx][2];
            float maxZ = 65536.0f * sol3->z2 + tenKFloors[sol2->tenKFloorIdx][3];

            minX = nextafter(minX + sign(minX), 0.0f);
            maxX = nextafter(maxX + sign(maxX), 0.0f);
            minZ = nextafter(minZ + sign(minZ), 0.0f);
            maxZ = nextafter(maxZ + sign(maxZ), 0.0f);

            float minSpeed = sol->minSpeed;
            float maxSpeed = sol->maxSpeed;

            float minReturnVelX;
            float minReturnVelZ;
            float minPre10KSpeed = NAN;

            while (isnan(minPre10KSpeed) && minSpeed >= maxSpeed) {
                minPre10KSpeed = find_pre10K_speed(minSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);

                if (isnan(minPre10KSpeed)) {
                    minSpeed = nextafterf(minSpeed, -INFINITY);
                }
            }

            float maxReturnVelX;
            float maxReturnVelZ;
            float maxPre10KSpeed = NAN;

            while (isnan(maxPre10KSpeed) && maxSpeed <= minSpeed) {
                maxPre10KSpeed = find_pre10K_speed(maxSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);

                if (isnan(maxPre10KSpeed)) {
                    maxSpeed = nextafterf(maxSpeed, INFINITY);
                }
            }

            if (minSpeed >= maxSpeed) {
                float minSpeedF2X = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelX / 4.0f);
                float minSpeedF2Z = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelZ / 4.0f);

                float maxSpeedF2X = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelX / 4.0f);
                float maxSpeedF2Z = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelZ / 4.0f);

                bool speedTest = true;

                if (minSpeedF2X < minX) {
                    if (maxSpeedF2X < minX) {
                        speedTest = false;
                    }
                    else {
                        float lowerSpeed = minSpeed;
                        float upperSpeed = maxSpeed;

                        while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                            float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                            float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);

                            while (isnan(testPre10KSpeed) && midSpeed < lowerSpeed) {
                                midSpeed = nextafter(midSpeed, INFINITY);
                                testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);
                            }

                            if (!isnan(testPre10KSpeed)) {
                                float newSpeedF2X = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelX / 4.0f);

                                if (newSpeedF2X < minX) {
                                    minPre10KSpeed = testPre10KSpeed;
                                    minSpeedF2X = newSpeedF2X;
                                    minSpeedF2Z = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelZ / 4.0f);
                                    lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                }
                                else {
                                    upperSpeed = midSpeed;
                                }
                            }
                            else {
                                lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                            }
                        }

                        minSpeed = upperSpeed;
                    }
                }
                else if (maxSpeedF2X < minX) {
                    float lowerSpeed = minSpeed;
                    float upperSpeed = maxSpeed;

                    while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                        float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                        float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);

                        while (isnan(testPre10KSpeed) && midSpeed > upperSpeed) {
                            midSpeed = nextafter(midSpeed, -INFINITY);
                            testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);
                        }

                        if (!isnan(testPre10KSpeed)) {
                            float newSpeedF2X = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelX / 4.0f);

                            if (newSpeedF2X < minX) {
                                maxPre10KSpeed = testPre10KSpeed;
                                maxSpeedF2X = newSpeedF2X;
                                maxSpeedF2Z = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelZ / 4.0f);
                                upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                            }
                            else {
                                lowerSpeed = midSpeed;
                            }
                        }
                        else {
                            upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                        }
                    }

                    maxSpeed = lowerSpeed;
                }

                if (speedTest) {
                    if (minSpeedF2X > maxX) {
                        if (maxSpeedF2X > maxX) {
                            speedTest = false;
                        }
                        else {
                            float lowerSpeed = minSpeed;
                            float upperSpeed = maxSpeed;

                            while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                                float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                                float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);

                                while (isnan(testPre10KSpeed) && midSpeed < lowerSpeed) {
                                    midSpeed = nextafter(midSpeed, INFINITY);
                                    testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);
                                }

                                if (!isnan(testPre10KSpeed)) {
                                    float newSpeedF2X = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelX / 4.0f);

                                    if (newSpeedF2X > maxX) {
                                        minPre10KSpeed = testPre10KSpeed;
                                        minSpeedF2X = newSpeedF2X;
                                        minSpeedF2Z = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelZ / 4.0f);
                                        lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                    }
                                    else {
                                        upperSpeed = midSpeed;
                                    }
                                }
                                else {
                                    lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                }
                            }

                            minSpeed = upperSpeed;
                        }
                    }
                    else if (maxSpeedF2X > maxX) {
                        float lowerSpeed = minSpeed;
                        float upperSpeed = maxSpeed;

                        while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                            float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                            float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);

                            while (isnan(testPre10KSpeed) && midSpeed > upperSpeed) {
                                midSpeed = nextafter(midSpeed, -INFINITY);
                                testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);
                            }

                            if (!isnan(testPre10KSpeed)) {
                                float newSpeedF2X = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelX / 4.0f);

                                if (newSpeedF2X > maxX) {
                                    upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                }
                                else {
                                    maxPre10KSpeed = testPre10KSpeed;
                                    maxSpeedF2X = newSpeedF2X;
                                    maxSpeedF2Z = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelZ / 4.0f);
                                    lowerSpeed = midSpeed;
                                }
                            }
                            else {
                                upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                            }
                        }

                        minSpeed = lowerSpeed;
                    }
                }

                if (speedTest) {
                    if (minSpeedF2Z < minZ) {
                        if (maxSpeedF2Z < minZ) {
                            speedTest = false;
                        }
                        else {
                            float lowerSpeed = minSpeed;
                            float upperSpeed = maxSpeed;

                            while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                                float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                                float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);

                                while (isnan(testPre10KSpeed) && midSpeed < lowerSpeed) {
                                    midSpeed = nextafter(midSpeed, INFINITY);
                                    testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);
                                }

                                if (!isnan(testPre10KSpeed)) {
                                    float newSpeedF2Z = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelZ / 4.0f);

                                    if (newSpeedF2Z < minZ) {
                                        lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                    }
                                    else {
                                        minPre10KSpeed = testPre10KSpeed;
                                        minSpeedF2Z = newSpeedF2Z;
                                        minSpeedF2X = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelX / 4.0f);
                                        upperSpeed = midSpeed;
                                    }
                                }
                                else {
                                    lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                }
                            }

                            minSpeed = upperSpeed;
                        }
                    }
                    else if (maxSpeedF2Z < minZ) {
                        float lowerSpeed = minSpeed;
                        float upperSpeed = maxSpeed;

                        while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                            float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                            float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);

                            while (isnan(testPre10KSpeed) && midSpeed > upperSpeed) {
                                midSpeed = nextafter(midSpeed, -INFINITY);
                                testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);
                            }

                            if (!isnan(testPre10KSpeed)) {
                                float newSpeedF2Z = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelZ / 4.0f);

                                if (newSpeedF2Z < minZ) {
                                    upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                }
                                else {
                                    maxPre10KSpeed = testPre10KSpeed;
                                    maxSpeedF2Z = newSpeedF2Z;
                                    maxSpeedF2X = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelX / 4.0f);
                                    lowerSpeed = midSpeed;
                                }
                            }
                            else {
                                upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                            }
                        }

                        maxSpeed = lowerSpeed;
                    }
                }

                if (speedTest) {
                    if (minSpeedF2Z > maxZ) {
                        if (maxSpeedF2Z > maxZ) {
                            speedTest = false;
                        }
                        else {
                            float lowerSpeed = minSpeed;
                            float upperSpeed = maxSpeed;

                            while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                                float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                                float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);

                                while (isnan(testPre10KSpeed) && midSpeed < lowerSpeed) {
                                    midSpeed = nextafter(midSpeed, INFINITY);
                                    testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);
                                }

                                if (!isnan(testPre10KSpeed)) {
                                    float newSpeedF2Z = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelZ / 4.0f);

                                    if (newSpeedF2Z > maxZ) {
                                        lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                    }
                                    else {
                                        minPre10KSpeed = testPre10KSpeed;
                                        minSpeedF2Z = newSpeedF2Z;
                                        minSpeedF2X = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelX / 4.0f);
                                        upperSpeed = midSpeed;
                                    }
                                }
                                else {
                                    lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                }
                            }

                            minSpeed = upperSpeed;
                        }
                    }
                    else if (maxSpeedF2Z > maxZ) {
                        float lowerSpeed = minSpeed;
                        float upperSpeed = maxSpeed;

                        while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                            float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                            float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);

                            while (isnan(testPre10KSpeed) && midSpeed > upperSpeed) {
                                midSpeed = nextafter(midSpeed, -INFINITY);
                                testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);
                            }

                            if (!isnan(testPre10KSpeed)) {
                                float newSpeedF2Z = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelZ / 4.0f);

                                if (newSpeedF2Z > maxZ) {
                                    upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                }
                                else {
                                    maxPre10KSpeed = testPre10KSpeed;
                                    maxSpeedF2Z = newSpeedF2Z;
                                    maxSpeedF2X = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelX / 4.0f);
                                    lowerSpeed = midSpeed;
                                }
                            }
                            else {
                                upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                            }
                        }

                        maxSpeed = lowerSpeed;
                    }
                }

                float minPos[3] = { minSpeedF2X, 0.0f, minSpeedF2Z };
                float minFloorHeight;
                float maxPos[3] = { maxSpeedF2X, 0.0f, maxSpeedF2Z };
                float maxFloorHeight;
                SurfaceG* floor;

                if (speedTest) {
                    int minFloorIdx = find_floor(minPos, &floor, minFloorHeight, floorsG, total_floorsG);

                    if (minFloorIdx == -1 || floor->normal[1] != tenKFloors[sol2->tenKFloorIdx][7]) {
                        float lowerSpeed = minSpeed;
                        float upperSpeed = maxSpeed;

                        while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                            float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                            float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);

                            while (isnan(testPre10KSpeed) && midSpeed < lowerSpeed) {
                                midSpeed = nextafter(midSpeed, INFINITY);
                                testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);
                            }

                            if (!isnan(testPre10KSpeed)) {
                                minPos[0] = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelX / 4.0f);
                                minPos[2] = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelZ / 4.0f);

                                SurfaceG* testFloor;
                                float testFloorHeight;
                                int testFloorIdx = find_floor(minPos, &testFloor, testFloorHeight, floorsG, total_floorsG);

                                if (testFloorIdx == -1 || testFloor->normal[1] != tenKFloors[sol2->tenKFloorIdx][7]) {
                                    lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                }
                                else {
                                    minFloorIdx = testFloorIdx;
                                    floor = testFloor;
                                    minFloorHeight = testFloorHeight;
                                    minPre10KSpeed = testPre10KSpeed;
                                    minSpeedF2X = minPos[0];
                                    minSpeedF2Z = minPos[2];
                                    upperSpeed = midSpeed;
                                }
                            }
                            else {
                                lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                            }
                        }

                        minSpeed = upperSpeed;
                        speedTest = !(minFloorIdx == -1 && floor->normal[1] != tenKFloors[sol2->tenKFloorIdx][7]);
                    }
                }

                if (speedTest) {
                    int maxFloorIdx = find_floor(maxPos, &floor, maxFloorHeight, floorsG, total_floorsG);

                    if (maxFloorIdx == -1 || floor->normal[1] != tenKFloors[sol2->tenKFloorIdx][7]) {
                        float lowerSpeed = minSpeed;
                        float upperSpeed = maxSpeed;

                        while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                            float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                            float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);

                            while (isnan(testPre10KSpeed) && midSpeed > upperSpeed) {
                                midSpeed = nextafter(midSpeed, -INFINITY);
                                testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);
                           }

                            if (!isnan(testPre10KSpeed)) {
                                maxPos[0] = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelX / 4.0f);
                                maxPos[2] = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelZ / 4.0f);

                                SurfaceG* testFloor;
                                float testFloorHeight;
                                int testFloorIdx = find_floor(maxPos, &testFloor, testFloorHeight, floorsG, total_floorsG);

                                if (testFloorIdx == -1 || testFloor->normal[1] != tenKFloors[sol2->tenKFloorIdx][7]) {
                                    upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                }
                                else {
                                    maxFloorIdx = testFloorIdx;
                                    floor = testFloor;
                                    maxFloorHeight = testFloorHeight;
                                    maxPre10KSpeed = testPre10KSpeed;
                                    maxSpeedF2X = maxPos[0];
                                    maxSpeedF2Z = maxPos[2];
                                    lowerSpeed = midSpeed;
                                }
                            }
                            else {
                                upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                            }
                        }

                        maxSpeed = lowerSpeed;
                        speedTest = !(maxFloorIdx == -1 && floor->normal[1] != tenKFloors[sol2->tenKFloorIdx][7]);
                    }
                }

                
                if (speedTest) {
                    if (minFloorHeight > platSol->returnPosition[1]) {
                        if (maxFloorHeight > platSol->returnPosition[1]) {
                            speedTest = false;
                        }
                        else {
                            float lowerSpeed = minSpeed;
                            float upperSpeed = maxSpeed;

                            while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                                float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                                float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);

                                while (isnan(testPre10KSpeed) && midSpeed < lowerSpeed) {
                                    midSpeed = nextafter(midSpeed, INFINITY);
                                    testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);
                                }

                                if (!isnan(testPre10KSpeed)) {
                                    minPos[0] = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelX / 4.0f);
                                    minPos[2] = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelZ / 4.0f);

                                    SurfaceG* testFloor;
                                    float testFloorHeight;
                                    int testFloorIdx = find_floor(minPos, &testFloor, testFloorHeight, floorsG, total_floorsG);

                                    if (testFloorIdx == -1 || testFloor->normal[1] != tenKFloors[sol2->tenKFloorIdx][7]) {
                                        break;
                                    } 
                                    else if (testFloorHeight > platSol->returnPosition[1]) {
                                        lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                    }
                                    else {
                                        minFloorHeight = testFloorHeight;
                                        minPre10KSpeed = testPre10KSpeed;
                                        minSpeedF2X = minPos[0];
                                        minSpeedF2Z = minPos[2];
                                        upperSpeed = midSpeed;
                                    }
                                }
                                else {
                                    lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                }
                            }

                            minSpeed = upperSpeed;
                            speedTest = !(minFloorHeight > platSol->returnPosition[1]);
                        }
                    }
                }

                if (speedTest) {
                    if (minFloorHeight <= -2971.0f || minFloorHeight <= (platSol->returnPosition[1] - 78.0f)) {
                        if (maxFloorHeight <= -2971.0f || maxFloorHeight <= (platSol->returnPosition[1] - 78.0f)) {
                            speedTest = false;
                        }
                        else {
                            float lowerSpeed = minSpeed;
                            float upperSpeed = maxSpeed;

                            while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                                float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                                float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);

                                while (isnan(testPre10KSpeed) && midSpeed < lowerSpeed) {
                                    midSpeed = nextafter(midSpeed, INFINITY);
                                    testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, minReturnVelX, minReturnVelZ, sol->skIdx);
                                }

                                if (!isnan(testPre10KSpeed)) {
                                    minPos[0] = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelX / 4.0f);
                                    minPos[2] = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (minReturnVelZ / 4.0f);

                                    SurfaceG* testFloor;
                                    float testFloorHeight;
                                    int testFloorIdx = find_floor(minPos, &testFloor, testFloorHeight, floorsG, total_floorsG);

                                    if (testFloorIdx == -1 || testFloor->normal[1] != tenKFloors[sol2->tenKFloorIdx][7]) {
                                        break;
                                    }
                                    else if (testFloorHeight <= -2971.0f || testFloorHeight <= (platSol->returnPosition[1] - 78.0f)) {
                                        lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                    }
                                    else {
                                        minFloorHeight = testFloorHeight;
                                        minPre10KSpeed = testPre10KSpeed;
                                        minSpeedF2X = minPos[0];
                                        minSpeedF2Z = minPos[2];
                                        upperSpeed = midSpeed;
                                    }
                                }
                                else {
                                    lowerSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                }
                            }

                            minSpeed = upperSpeed;
                            speedTest = !(minFloorHeight <= -2971.0f || minFloorHeight <= (platSol->returnPosition[1] - 78.0f));
                        }
                    }
                }
                
                if (speedTest) {
                    if (maxFloorHeight > platSol->returnPosition[1]) {
                        float lowerSpeed = minSpeed;
                        float upperSpeed = maxSpeed;

                        while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                            float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                            float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);

                            while (isnan(testPre10KSpeed) && midSpeed > upperSpeed) {
                                midSpeed = nextafter(midSpeed, -INFINITY);
                                testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);
                            }

                            if (!isnan(testPre10KSpeed)) {
                                maxPos[0] = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelX / 4.0f);
                                maxPos[2] = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelZ / 4.0f);

                                SurfaceG* testFloor;
                                float testFloorHeight;
                                int testFloorIdx = find_floor(maxPos, &testFloor, testFloorHeight, floorsG, total_floorsG);

                                if (testFloorIdx == -1 || testFloor->normal[1] != tenKFloors[sol2->tenKFloorIdx][7]) {
                                    break;
                                } 
                                else if (testFloorHeight > platSol->returnPosition[1]) {
                                    upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                }
                                else {
                                    maxFloorHeight = testFloorHeight;
                                    maxPre10KSpeed = testPre10KSpeed;
                                    maxSpeedF2X = maxPos[0];
                                    maxSpeedF2Z = maxPos[2];
                                    lowerSpeed = midSpeed;
                                }
                            }
                            else {
                                upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                            }
                        }

                        maxSpeed = lowerSpeed;
                        speedTest = !(maxFloorHeight > platSol->returnPosition[1]);
                    }
                }

                if (speedTest) {
                    if (maxFloorHeight <= -2971.0f || maxFloorHeight <= (platSol->returnPosition[1] - 78.0f)) {
                        float lowerSpeed = minSpeed;
                        float upperSpeed = maxSpeed;

                        while (nextafter(lowerSpeed, -INFINITY) > upperSpeed) {
                            float midSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));

                            float testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);

                            while (isnan(testPre10KSpeed) && midSpeed > upperSpeed) {
                                midSpeed = nextafter(midSpeed, -INFINITY);
                                testPre10KSpeed = find_pre10K_speed(midSpeed, xStrain, zStrain, maxReturnVelX, maxReturnVelZ, sol->skIdx);
                            }

                            if (!isnan(testPre10KSpeed)) {
                                maxPos[0] = platSol->returnPosition[0] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelX / 4.0f);
                                maxPos[2] = platSol->returnPosition[2] - tenKFloors[sol2->tenKFloorIdx][7] * (maxReturnVelZ / 4.0f);

                                SurfaceG* testFloor;
                                float testFloorHeight;
                                int testFloorIdx = find_floor(maxPos, &testFloor, testFloorHeight, floorsG, total_floorsG);

                                if (testFloorIdx == -1 || testFloor->normal[1] != tenKFloors[sol2->tenKFloorIdx][7]) {
                                    break;
                                }
                                else if (testFloorHeight <= -2971.0f || testFloorHeight <= (platSol->returnPosition[1] - 78.0f)) {
                                    upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                                }
                                else {
                                    maxFloorHeight = testFloorHeight;
                                    maxPre10KSpeed = testPre10KSpeed;
                                    maxSpeedF2X = maxPos[0];
                                    maxSpeedF2Z = maxPos[2];
                                    lowerSpeed = midSpeed;
                                }
                            }
                            else {
                                upperSpeed = fminf((lowerSpeed + upperSpeed) / 2.0, nextafter(lowerSpeed, -INFINITY));
                            }
                        }

                        maxSpeed = lowerSpeed;

                        speedTest = !(maxFloorHeight <= -2971.0f || maxFloorHeight <= (platSol->returnPosition[1] - 78.0f));
                    }
                }

                if (speedTest) {
                    for (float speed = minSpeed; speed >= maxSpeed; speed = nextafterf(speed, -INFINITY)) {
                        float returnVelX;
                        float returnVelZ;

                        float pre10KSpeed = find_pre10K_speed(speed, xStrain, zStrain, returnVelX, returnVelZ, sol->skIdx);

                        if (!isnan(pre10KSpeed)) {
                            int solIdx = atomicAdd(&(counts.nSpeedSolutions), 1);

                            if (solIdx < limits.MAX_SPEED_SOLUTIONS) {
                                struct SpeedSolution* solution = &(solutions.speedSolutions[solIdx]);
                                solution->skuwSolutionIdx = idx;
                                solution->returnSpeed = speed;
                                solution->forwardStrain = fStrain;
                                solution->xStrain = xStrain;
                                solution->zStrain = zStrain;
                            }
                        }
                    }
                }
            }
        }
    }
}

__device__ float next_out_of_bounds_speed(float currentSpeed, float floorNormalY, float* position, int angle, int searchDir) {
    angle = (unsigned short)angle;
    searchDir = sign(searchDir);

    float sinAngle = sinsG(angle);
    float cosAngle = cossG(angle);

    float xVel = sinAngle * currentSpeed;
    float zVel = cosAngle * currentSpeed;

    float nextPosition[3] = { position[0] + floorNormalY * (xVel / 4.0f), position[1], position[2] + floorNormalY * (zVel / 4.0f) };

    bool inBounds = check_inbounds(nextPosition);

    if (!inBounds) {
        return currentSpeed;
    }
    else {
        float nextSpeedX;
        float nextSpeedZ;

        if (sinAngle == 0) {
            nextSpeedX = searchDir * INFINITY;
        }
        else {
            int xDir = sign(sinAngle) * searchDir;
            float nextOOBX = 65536.0f * floorf((nextPosition[0] - -8192.0f) / 65536.0f) + (xDir * 8192.5f + 0.5f);

            while ((short)(int)nextOOBX >= -8191 && (short)(int)nextOOBX <= 8192) {
                nextOOBX = nextafterf(nextOOBX, xDir * INFINITY);
            }

            nextSpeedX = 4.0f * ((nextOOBX - position[0]) / floorNormalY) / sinAngle;

            short nextPositionX = (short)(int)(position[0] + floorNormalY * ((sinAngle * nextSpeedX) / 4.0f));

            while (nextPositionX >= -8191 && nextPositionX <= 8192) {
                nextSpeedX = nextafterf(nextSpeedX, searchDir * INFINITY);
                nextPositionX = (short)(int)(position[0] + floorNormalY * ((sinAngle * nextSpeedX) / 4.0f));
            }
        }

        if (cosAngle == 0) {
            nextSpeedZ = searchDir * INFINITY;
        }
        else {
            int zDir = sign(cosAngle) * searchDir;
            float nextOOBZ = 65536.0f * floorf((nextPosition[2] - -8192.0f) / 65536.0f) + (zDir * 8192.5f + 0.5f);

            while ((short)(int)nextOOBZ >= -8191 && (short)(int)nextOOBZ <= 8192) {
                nextOOBZ = nextafterf(nextOOBZ, zDir * INFINITY);
            }

            nextSpeedZ = 4.0f * ((nextOOBZ - position[2]) / floorNormalY) / cosAngle;

            short nextPositionZ = (short)(int)(position[2] + floorNormalY * ((cosAngle * nextSpeedZ) / 4.0f));

            while (nextPositionZ >= -8191 && nextPositionZ <= 8192) {
                nextSpeedZ = nextafterf(nextSpeedZ, searchDir * INFINITY);
                nextPositionZ = (short)(int)(position[2] + floorNormalY * ((cosAngle * nextSpeedZ) / 4.0f));
            }
        }

        return searchDir * fminf(searchDir * nextSpeedX, searchDir * nextSpeedZ);
    }
}

__device__ float next_in_bounds_speed(float currentSpeed, float floorNormalY, float* position, int angle, int searchDir) {
    angle = (unsigned short)angle;
    searchDir = sign(searchDir);

    float oobSpeed = next_out_of_bounds_speed(currentSpeed, floorNormalY, position, angle, searchDir);

    float sinAngle = sinsG(angle);
    float cosAngle = cossG(angle);

    if (sinAngle == 0) {
        short xInt = (short)(int)position[0];

        if (xInt < -8191 || xInt > 8192) {
            return searchDir * INFINITY;
        }
    }

    if (cosAngle == 0) {
        short zInt = (short)(int)position[2];

        if (zInt < -8191 || zInt > 8192) {
            return searchDir * INFINITY;
        }
    }

    int xDir = sign(sinAngle) * searchDir;
    int zDir = sign(cosAngle) * searchDir;

    float xOffset = xDir * 32767.5f + 24575.5f;
    float zOffset = zDir * 32767.5f + 24575.5f;

    bool searchLoop = true;

    while (searchLoop) {
        float xVel = sinAngle * currentSpeed;
        float zVel = cosAngle * currentSpeed;

        float nextPosition[3] = { position[0] + floorNormalY * (xVel / 4.0f), position[1], position[2] + floorNormalY * (zVel / 4.0f) };

        float nextIBSpeedX;
        float nextOOBSpeedX;
        float nextIBSpeedZ;
        float nextOOBSpeedZ;

        if (sinAngle == 0) {
            nextIBSpeedX = currentSpeed;
            nextOOBSpeedX = searchDir * INFINITY;
        }
        else {
            float nextIBX = 65536.0f * floorf((nextPosition[0] + xOffset) / 65536.0f) + (-xDir * 8192.5f + 0.5f);
            float nextOOBX = nextIBX + (xDir * 16385.0f);

            while ((short)(int)nextIBX < -8191 || (short)(int)nextIBX > 8192) {
                nextIBX = nextafterf(nextIBX, xDir * INFINITY);
            }

            while ((short)(int)nextOOBX >= -8191 && (short)(int)nextOOBX <= 8192) {
                nextOOBX = nextafterf(nextOOBX, xDir * INFINITY);
            }

            nextIBSpeedX = 4.0f * ((nextIBX - position[0]) / floorNormalY) / sinAngle;
            nextOOBSpeedX = 4.0f * ((nextOOBX - position[0]) / floorNormalY) / sinAngle;

            short nextPositionX = (short)(int)(position[0] + floorNormalY * ((sinAngle * nextIBSpeedX) / 4.0f));

            while (nextPositionX < -8191 || nextPositionX > 8192) {
                nextIBSpeedX = nextafterf(nextIBSpeedX, searchDir * INFINITY);
                nextPositionX = (short)(int)(position[0] + floorNormalY * ((sinAngle * nextIBSpeedX) / 4.0f));
            }

            nextPositionX = (short)(int)(position[0] + floorNormalY * ((sinAngle * nextOOBSpeedX) / 4.0f));

            while (nextPositionX >= -8191 && nextPositionX <= 8192) {
                nextOOBSpeedX = nextafterf(nextOOBSpeedX, searchDir * INFINITY);
                nextPositionX = (short)(int)(position[0] + floorNormalY * ((sinAngle * nextOOBSpeedX) / 4.0f));
            }

            nextIBSpeedX = searchDir * fmaxf(searchDir * nextIBSpeedX, searchDir * currentSpeed);
        }

        if (cosAngle == 0) {
            nextIBSpeedZ = currentSpeed;
            nextOOBSpeedZ = searchDir * INFINITY;
        }
        else {
            float nextIBZ = 65536.0f * floorf((nextPosition[2] + zOffset) / 65536.0f) + (-zDir * 8192.5f + 0.5f);
            float nextOOBZ = nextIBZ + (zDir * 16385.0f);

            while ((short)(int)nextIBZ < -8191 || (short)(int)nextIBZ > 8192) {
                nextIBZ = nextafterf(nextIBZ, zDir * INFINITY);
            }

            while ((short)(int)nextOOBZ >= -8191 && (short)(int)nextOOBZ <= 8192) {
                nextOOBZ = nextafterf(nextOOBZ, zDir * INFINITY);
            }

            nextIBSpeedZ = 4.0f * ((nextIBZ - position[2]) / floorNormalY) / cosAngle;
            nextOOBSpeedZ = 4.0f * ((nextOOBZ - position[2]) / floorNormalY) / cosAngle;

            short nextPositionZ = (short)(int)(position[2] + floorNormalY * ((cosAngle * nextIBSpeedZ) / 4.0f));

            while (nextPositionZ < -8191 || nextPositionZ > 8192) {
                nextIBSpeedZ = nextafterf(nextIBSpeedZ, searchDir * INFINITY);
                nextPositionZ = (short)(int)(position[2] + floorNormalY * ((cosAngle * nextIBSpeedZ) / 4.0f));
            }

            nextPositionZ = (short)(int)(position[2] + floorNormalY * ((cosAngle * nextOOBSpeedZ) / 4.0f));

            while (nextPositionZ >= -8191 && nextPositionZ <= 8192) {
                nextOOBSpeedZ = nextafterf(nextOOBSpeedZ, searchDir * INFINITY);
                nextPositionZ = (short)(int)(position[2] + floorNormalY * ((cosAngle * nextOOBSpeedZ) / 4.0f));
            }

            nextIBSpeedZ = searchDir * fmaxf(searchDir * nextIBSpeedZ, searchDir * currentSpeed);
        }

        currentSpeed = searchDir * fmaxf(searchDir * nextIBSpeedX, searchDir * nextIBSpeedZ);

        if (searchDir * nextIBSpeedX > searchDir * nextIBSpeedZ) {
            if (searchDir * nextIBSpeedX < searchDir * nextOOBSpeedZ) {
                searchLoop = false;
            }
        }
        else {
            if (searchDir * nextIBSpeedZ < searchDir * nextOOBSpeedX) {
                searchLoop = false;
            }
        }
    }

    return currentSpeed;
}

__global__ void find_sk_upwarp_solutions() {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(counts.nUpwarpSolutions, limits.MAX_UPWARP_SOLUTIONS)) {
        struct UpwarpSolution* uwSol = &(solutions.upwarpSolutions[idx]);
        struct PlatformSolution* platSol = &(solutions.platSolutions[uwSol->platformSolutionIdx]);

        float speedBuffer = 1000.0;

        double maxDist = -INFINITY;
        double minDist = INFINITY;

        for (int i = 0; i < 3; i++) {
            double xDist = 65536.0f * uwSol->pux + platSol->endTriangles[platSol->endFloorIdx][i][0] - platSol->endPosition[0];
            double zDist = 65536.0f * uwSol->puz + platSol->endTriangles[platSol->endFloorIdx][i][2] - platSol->endPosition[2];

            double dist = sqrt(xDist * xDist + zDist * zDist);

            minDist = fmin(dist, minDist);
            maxDist = fmax(dist, maxDist);
        }

        float upperSpeed = -(maxDist / platSol->endTriangleNormals[platSol->endFloorIdx][1]) / 0.9 - speedBuffer;
        float lowerSpeed = -(minDist / platSol->endTriangleNormals[platSol->endFloorIdx][1]) / 0.94 + speedBuffer;

        for (int i = 0; i < min(counts.nSK6Solutions, limits.MAX_SK_PHASE_SIX); i++) {
            SKPhase6* sk6Sol = &(solutions.sk6Solutions[i]);
            struct SKPhase5* sol5 = &(solutions.sk5Solutions[sk6Sol->p5Idx]);
            struct SKPhase4* sol4 = &(solutions.sk4Solutions[sol5->p4Idx]);
            struct SKPhase3* sol3 = &(solutions.sk3Solutions[sol4->p3Idx]);
            struct SKPhase2* sol2 = (sol3->p2Type / 2 == 0) ? ((sol3->p2Type % 2 == 0) ? &(solutions.sk2ASolutions[sol3->p2Idx]) : &(solutions.sk2BSolutions[sol3->p2Idx])) : ((sol3->p2Type % 2 == 0) ? &(solutions.sk2CSolutions[sol3->p2Idx]) : &(solutions.sk2DSolutions[sol3->p2Idx]));
            struct SKPhase1* sol1 = &(solutions.sk1Solutions[sol2->p1Idx]);

            float minSpeed = fminf(lowerSpeed, sk6Sol->minPost10KSpeed);
            float maxSpeed = fmaxf(upperSpeed, sk6Sol->maxPost10KSpeed);

            if (minSpeed >= maxSpeed) {
                float minReturnVelX;
                float minReturnVelZ;

                float minPre10KSpeed = NAN;
                float testMinSpeed = minSpeed;

                while (isnan(minPre10KSpeed) && testMinSpeed >= maxSpeed) {
                    minPre10KSpeed = find_pre10K_speed(testMinSpeed, 0.0f, 0.0f, minReturnVelX, minReturnVelZ, i);

                    if (isnan(minPre10KSpeed)) {
                        testMinSpeed = nextafterf(testMinSpeed, -INFINITY);
                    }
                }

                if (testMinSpeed >= maxSpeed) {
                    int precision;

                    frexpf(minPre10KSpeed, &precision);

                    float speedRange = powf(2.0f, precision - 24);
                    int nFSpeedLevels = (int)ceilf(1.5f / speedRange);
                    atomicMax(&maxFSpeedLevels, nFSpeedLevels);

                    float xVel = minPre10KSpeed * sinsG(sol2->f2Angle);
                    float zVel = minPre10KSpeed * cossG(sol2->f2Angle);

                    const int minStrainPrecision = -6;

                    frexpf(xVel, &precision);
                    float xVelRange = powf(2.0f, max(minStrainPrecision, precision - 24));
                    int nXSpeedLevels = (int)ceilf(fabs(10.0f * cossG(sol2->f2Angle)) / xVelRange);

                    frexpf(zVel, &precision);
                    float zVelRange = powf(2.0f, max(minStrainPrecision, precision - 24));
                    int nZSpeedLevels = (int)ceilf(fabs(10.0f * -sinsG(sol2->f2Angle)) / zVelRange);

                    atomicMax(&maxSSpeedLevels, max(nXSpeedLevels, nZSpeedLevels));
                    /*
                    float currentSpeed = minSpeed;

                    int newFacingDYaw = (short)(sol2->f2Angle - sk6Sol->f3Angle);

                    if (newFacingDYaw > 0 && newFacingDYaw <= 0x4000) {
                        if ((newFacingDYaw -= 0x200) < 0) {
                            newFacingDYaw = 0;
                        }
                    }
                    else if (newFacingDYaw > -0x4000 && newFacingDYaw < 0) {
                        if ((newFacingDYaw += 0x200) > 0) {
                            newFacingDYaw = 0;
                        }
                    }
                    else if (newFacingDYaw > 0x4000 && newFacingDYaw < 0x8000) {
                        if ((newFacingDYaw += 0x200) > 0x8000) {
                            newFacingDYaw = 0x8000;
                        }
                    }
                    else if (newFacingDYaw > -0x8000 && newFacingDYaw < -0x4000) {
                        if ((newFacingDYaw -= 0x200) < -0x8000) {
                            newFacingDYaw = -0x8000;
                        }
                    }

                    int returnFaceAngle = sk6Sol->f3Angle + newFacingDYaw;
                    
                    while (currentSpeed >= maxSpeed) {
                        float oobSpeed0 = NAN;
                        float oobSpeed1 = NAN;
                        float oobSpeed2 = NAN;
                        float oobSpeed3 = NAN;

                        while (fmaxf(fmaxf(oobSpeed0, oobSpeed1), fmaxf(oobSpeed2, oobSpeed3)) != currentSpeed) {
                            oobSpeed0 = next_out_of_bounds_speed(currentSpeed, 1.0f, platSol->returnPosition, returnFaceAngle, -1);
                            oobSpeed1 = next_out_of_bounds_speed(currentSpeed, platSol->landingFloorNormalsY[0], platSol->landingPositions[0], returnFaceAngle, -1);
                            oobSpeed2 = next_out_of_bounds_speed(currentSpeed, platSol->landingFloorNormalsY[1], platSol->landingPositions[1], returnFaceAngle, -1);
                            oobSpeed3 = next_out_of_bounds_speed(currentSpeed, platSol->landingFloorNormalsY[2], platSol->landingPositions[2], returnFaceAngle, -1);

                            currentSpeed = fminf(fminf(oobSpeed0, oobSpeed1), fminf(oobSpeed2, oobSpeed3));
                        }

                        float ibSpeed0 = next_in_bounds_speed(currentSpeed, 1.0f, platSol->returnPosition, returnFaceAngle, -1);
                        float ibSpeed1 = next_in_bounds_speed(currentSpeed, platSol->landingFloorNormalsY[0], platSol->landingPositions[0], returnFaceAngle, -1);
                        float ibSpeed2 = next_in_bounds_speed(currentSpeed, platSol->landingFloorNormalsY[1], platSol->landingPositions[1], returnFaceAngle, -1);
                        float ibSpeed3 = next_in_bounds_speed(currentSpeed, platSol->landingFloorNormalsY[2], platSol->landingPositions[2], returnFaceAngle, -1);

                        float nextIBSpeed = fmaxf(fmaxf(ibSpeed0, ibSpeed1), fmaxf(ibSpeed2, ibSpeed3));

                        int solIdx = atomicAdd(&(counts.nSKUWSolutions), 1);

                        if (solIdx < limits.MAX_SK_UPWARP_SOLUTIONS) {
                            struct SKUpwarpSolution* solution = &(solutions.skuwSolutions[solIdx]);
                            solution->skIdx = i;
                            solution->uwIdx = idx;
                            solution->minSpeed = currentSpeed;
                            solution->maxSpeed = fmaxf(nextafterf(nextIBSpeed, INFINITY), maxSpeed);
                            solution->speedRange = speedRange;
                            solution->xVelRange = xVelRange;
                            solution->zVelRange = zVelRange;
                        }

                        currentSpeed = nextIBSpeed;

                    }
                    */
                    
                    int solIdx = atomicAdd(&(counts.nSKUWSolutions), 1);

                    if (solIdx < limits.MAX_SK_UPWARP_SOLUTIONS) {
                        struct SKUpwarpSolution* solution = &(solutions.skuwSolutions[solIdx]);
                        solution->skIdx = i;
                        solution->uwIdx = idx;
                        solution->minSpeed = minSpeed;
                        solution->maxSpeed = maxSpeed;
                        solution->speedRange = speedRange;
                        solution->xVelRange = xVelRange;
                        solution->zVelRange = zVelRange;
                    }
                }
            }
        }
    }
}

__device__ int calculate_camera_yaw(float* currentPosition, float* lakituPosition, int faceAngle) {
    short baseCameraYaw = -16384;
    float baseCameraDist = 1400.0;
    short baseCameraPitch = 0x05B0;

    SurfaceG* floor;
    float floorY;

    float xOff = currentPosition[0] + sinsG(baseCameraYaw) * 40.f;
    float zOff = currentPosition[2] + cossG(baseCameraYaw) * 40.f;
    float offPos[3] = { xOff, currentPosition[1], zOff };

    int floorIdx = find_floor(offPos, &floor, floorY, floorsG, total_floorsG);
    floorY = floorY - currentPosition[1];

    if (floorIdx != -1) {
        if (floorY > 0) {
            if (!(floor->normal[2] == 0.f && floorY < 100.f)) {
                baseCameraPitch += atan2sG(40.f, floorY);
            }
        }
    }

    baseCameraPitch = baseCameraPitch + 2304;

    float cameraPos[3] = { currentPosition[0] + baseCameraDist * cossG(baseCameraPitch) * sinsG(baseCameraYaw),
                       currentPosition[1] + 125.0f + baseCameraDist * sinsG(baseCameraPitch),
                       currentPosition[2] + baseCameraDist * cossG(baseCameraPitch) * cossG(baseCameraYaw)
    };

    float pan[3] = { 0, 0, 0 };
    float temp[3] = { 0, 0, 0 };

    // Get distance and angle from camera to Mario.
    float dx = currentPosition[0] - cameraPos[0];
    float dy = currentPosition[1] + 125.0f;
    float dz = currentPosition[2] - cameraPos[2];

    float cameraDist = sqrtf(dx * dx + dy * dy + dz * dz);
    int cameraPitch = atan2sG(sqrtf(dx * dx + dz * dz), dy);
    int cameraYaw = atan2sG(dz, dx);

    // The camera will pan ahead up to about 30% of the camera's distance to Mario.
    pan[2] = sinsG(0xC00) * cameraDist;

    temp[0] = pan[0];
    temp[1] = pan[1];
    temp[2] = pan[2];

    pan[0] = temp[2] * sinsG(faceAngle) + temp[0] * cossG(faceAngle);
    pan[2] = temp[2] * cossG(faceAngle) + temp[0] * sinsG(faceAngle);

    // rotate in the opposite direction
    cameraYaw = -cameraYaw;

    temp[0] = pan[0];
    temp[1] = pan[1];
    temp[2] = pan[2];

    pan[0] = temp[2] * sinsG(cameraYaw) + temp[0] * cossG(cameraYaw);
    pan[2] = temp[2] * cossG(cameraYaw) + temp[0] * sinsG(cameraYaw);

    // Only pan left or right
    pan[2] = 0.f;

    cameraYaw = -cameraYaw;

    temp[0] = pan[0];
    temp[1] = pan[1];
    temp[2] = pan[2];

    pan[0] = temp[2] * sinsG(cameraYaw) + temp[0] * cossG(cameraYaw);
    pan[2] = temp[2] * cossG(cameraYaw) + temp[0] * sinsG(cameraYaw);

    float cameraFocus[3] = { currentPosition[0] + pan[0], currentPosition[1] + 125.0f + pan[1], currentPosition[2] + pan[2] };

    dx = cameraFocus[0] - lakituPosition[0];
    dy = cameraFocus[1] - lakituPosition[1];
    dz = cameraFocus[2] - lakituPosition[2];

    cameraDist = sqrtf(dx * dx + dy * dy + dz * dz);
    cameraPitch = atan2sG(sqrtf(dx * dx + dz * dz), dy);
    cameraYaw = atan2sG(dz, dx);

    if (cameraPitch > 15872) {
        cameraPitch = 15872;
    }
    if (cameraPitch < -15872) {
        cameraPitch = -15872;
    }

    cameraFocus[0] = lakituPosition[0] + cameraDist * cossG(cameraPitch) * sinsG(cameraYaw);
    cameraFocus[1] = lakituPosition[1] + cameraDist * sinsG(cameraPitch);
    cameraFocus[2] = lakituPosition[2] + cameraDist * cossG(cameraPitch) * cossG(cameraYaw);

    return atan2sG(lakituPosition[2] - cameraFocus[2], lakituPosition[0] - cameraFocus[0]);
}

__device__ void platform_logic(float* platform_normal, float* mario_pos, short(&triangles)[2][3][3], float(&normals)[2][3], float(&mat)[4][4]) {
    float dx;
    float dy;
    float dz;
    float d;

    float dist[3];
    float posBeforeRotation[3];
    float posAfterRotation[3];

    // Mario's position
    float mx = mario_pos[0];
    float my = mario_pos[1];
    float mz = mario_pos[2];

    dist[0] = mx - (float)platform_pos[0];
    dist[1] = my - (float)platform_pos[1];
    dist[2] = mz - (float)platform_pos[2];

    mat[1][0] = platform_normal[0];
    mat[1][1] = platform_normal[1];
    mat[1][2] = platform_normal[2];

    float invsqrt = 1.0f / sqrtf(mat[1][0] * mat[1][0] + mat[1][1] * mat[1][1] + mat[1][2] * mat[1][2]);

    mat[1][0] *= invsqrt;
    mat[1][1] *= invsqrt;
    mat[1][2] *= invsqrt;

    mat[0][0] = mat[1][1] * 1.0f - 0.0f * mat[1][2];
    mat[0][1] = mat[1][2] * 0.0f - 1.0f * mat[1][0];
    mat[0][2] = mat[1][0] * 0.0f - 0.0f * mat[1][1];

    invsqrt = 1.0f / sqrtf(mat[0][0] * mat[0][0] + mat[0][1] * mat[0][1] + mat[0][2] * mat[0][2]);

    mat[0][0] *= invsqrt;
    mat[0][1] *= invsqrt;
    mat[0][2] *= invsqrt;

    mat[2][0] = mat[0][1] * mat[1][2] - mat[1][1] * mat[0][2];
    mat[2][1] = mat[0][2] * mat[1][0] - mat[1][2] * mat[0][0];
    mat[2][2] = mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];

    invsqrt = 1.0f / sqrtf(mat[2][0] * mat[2][0] + mat[2][1] * mat[2][1] + mat[2][2] * mat[2][2]);

    mat[2][0] *= invsqrt;
    mat[2][1] *= invsqrt;
    mat[2][2] *= invsqrt;

    mat[3][0] = platform_pos[0];
    mat[3][1] = platform_pos[1];
    mat[3][2] = platform_pos[2];
    mat[0][3] = 0.0f;
    mat[1][3] = 0.0f;
    mat[2][3] = 0.0f;
    mat[3][3] = 1.0f;

    for (int i = 0; i < 3; i++) {
        posBeforeRotation[i] = mat[0][i] * dist[0] + mat[1][i] * dist[1] + mat[2][i] * dist[2];
    }

    dx = mx - (float)platform_pos[0];
    dy = 500.0f;
    dz = mz - (float)platform_pos[2];
    d = sqrtf(dx * dx + dy * dy + dz * dz);

    // Normalizing
    d = 1.0 / d;
    dx *= d;
    dy *= d;
    dz *= d;

    // Approach the normals by 0.01f towards the new goal, then create a transform matrix and orient the object. 
    // Outside of the other conditionals since it needs to tilt regardless of whether Mario is on.
    platform_normal[0] = (platform_normal[0] <= dx) ? ((dx - platform_normal[0] < 0.01f) ? dx : (platform_normal[0] + 0.01f)) : ((dx - platform_normal[0] > -0.01f) ? dx : (platform_normal[0] - 0.01f));
    platform_normal[1] = (platform_normal[1] <= dy) ? ((dy - platform_normal[1] < 0.01f) ? dy : (platform_normal[1] + 0.01f)) : ((dy - platform_normal[1] > -0.01f) ? dy : (platform_normal[1] - 0.01f));
    platform_normal[2] = (platform_normal[2] <= dz) ? ((dz - platform_normal[2] < 0.01f) ? dz : (platform_normal[2] + 0.01f)) : ((dz - platform_normal[2] > -0.01f) ? dz : (platform_normal[2] - 0.01f));

    mat[1][0] = platform_normal[0];
    mat[1][1] = platform_normal[1];
    mat[1][2] = platform_normal[2];

    invsqrt = 1.0f / sqrtf(mat[1][0] * mat[1][0] + mat[1][1] * mat[1][1] + mat[1][2] * mat[1][2]);

    mat[1][0] *= invsqrt;
    mat[1][1] *= invsqrt;
    mat[1][2] *= invsqrt;

    mat[0][0] = mat[1][1] * 1.0f - 0.0f * mat[1][2];
    mat[0][1] = mat[1][2] * 0.0f - 1.0f * mat[1][0];
    mat[0][2] = mat[1][0] * 0.0f - 0.0f * mat[1][1];

    invsqrt = 1.0f / sqrtf(mat[0][0] * mat[0][0] + mat[0][1] * mat[0][1] + mat[0][2] * mat[0][2]);

    mat[0][0] *= invsqrt;
    mat[0][1] *= invsqrt;
    mat[0][2] *= invsqrt;

    mat[2][0] = mat[0][1] * mat[1][2] - mat[1][1] * mat[0][2];
    mat[2][1] = mat[0][2] * mat[1][0] - mat[1][2] * mat[0][0];
    mat[2][2] = mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];

    invsqrt = 1.0f / sqrtf(mat[2][0] * mat[2][0] + mat[2][1] * mat[2][1] + mat[2][2] * mat[2][2]);

    mat[2][0] *= invsqrt;
    mat[2][1] *= invsqrt;
    mat[2][2] *= invsqrt;

    mat[3][0] = platform_pos[0];
    mat[3][1] = platform_pos[1];
    mat[3][2] = platform_pos[2];
    mat[0][3] = 0.0f;
    mat[1][3] = 0.0f;
    mat[2][3] = 0.0f;
    mat[3][3] = 1.0f;

    for (int i = 0; i < 3; i++) {
        posAfterRotation[i] = mat[0][i] * dist[0] + mat[1][i] * dist[1] + mat[2][i] * dist[2];
    }

    mx += posAfterRotation[0] - posBeforeRotation[0];
    my += posAfterRotation[1] - posBeforeRotation[1];
    mz += posAfterRotation[2] - posBeforeRotation[2];
    mario_pos[0] = mx;
    mario_pos[1] = my;
    mario_pos[2] = mz;
}

__global__ void find_breakdance_solutions() {
    long long int idx = ((long long int)blockIdx.x * (long long int)blockDim.x) + threadIdx.x;
    int stickIdx = idx % nUniqueSticks;
    int x = uniqueSticks[stickIdx][0];
    int y = uniqueSticks[stickIdx][1];
    int slideIdx = idx / nUniqueSticks;

    if (slideIdx < min(counts.nSlideSolutions, limits.MAX_SLIDE_SOLUTIONS)) {
        struct SlideSolution* slideSol = &(solutions.slideSolutions[slideIdx]);
        struct TenKSolution* tenKSol = &(solutions.tenKSolutions[slideSol->tenKSolutionIdx]);
        
        SurfaceG* floor;
        float floorHeight;

        int floorIdx = find_floor(slideSol->upwarpPosition, &floor, floorHeight, floorsG, total_floorsG);

        int slopeAngle = atan2sG(floor->normal[2], floor->normal[0]);

        float steepness = sqrtf(floor->normal[0] * floor->normal[0] + floor->normal[2] * floor->normal[2]);

        float cameraPositions[4][3] = { {-8192, -2918, -8192}, {-8192, -2918, 8191}, {8191, -2918, -8192}, {8191, -2918, 8191} };

        int minCameraYaw = 0;
        int maxCameraYaw = 0;

        int refCameraYaw = calculate_camera_yaw(slideSol->upwarpPosition, cameraPositions[0], slideSol->postSlideAngle);

        for (int i = 1; i < 4; i++) {
            int cameraYaw = calculate_camera_yaw(slideSol->upwarpPosition, cameraPositions[i], slideSol->postSlideAngle);
            cameraYaw = (short)(cameraYaw - refCameraYaw);
            minCameraYaw = min(minCameraYaw, cameraYaw);
            maxCameraYaw = max(maxCameraYaw, cameraYaw);
        }

        int minCameraIdx = revAtansG(minCameraYaw + refCameraYaw);
        int maxCameraIdx = revAtansG(maxCameraYaw + refCameraYaw);

        if (minCameraIdx > maxCameraIdx) {
            maxCameraIdx += 8192;
        }

        for (int i = minCameraIdx; i <= maxCameraIdx; i++) {
            int cameraYaw = (unsigned short)gArctanTableG[i % 8192];

            if (validCameraAngle[cameraYaw]) {
                float stickX = x - (x < 0) + (x > 0);
                float stickY = y - (y < 0) + (y > 0);

                int rawX = x - 7 * (x < 0) + 7 * (x > 0);
                int rawY = y - 7 * (y < 0) + 7 * (y > 0);

                float stickMag = sqrtf(stickX * stickX + stickY * stickY);

                if (stickMag > 64) {
                    stickX *= 64 / stickMag;
                    stickY *= 64 / stickMag;
                    stickMag = 64;
                }

                float intendedMag = ((stickMag / 64.0f) * (stickMag / 64.0f)) * 32.0f;

                int intendedYaw;

                if (intendedMag > 0.0f) {
                    intendedYaw = atan2sG(-stickY, stickX) + cameraYaw;
                }
                else {
                    intendedYaw = slideSol->postSlideAngle;
                }

                int intendedDYaw = intendedYaw - slideSol->postSlideAngle;

                float lossFactor = intendedMag / 32.0f * cossG(intendedDYaw) * 0.02f + 0.92f;

                float xVel = slideSol->postSlideSpeed * sinsG(slideSol->postSlideAngle);
                float zVel = slideSol->postSlideSpeed * cossG(slideSol->postSlideAngle);

                float oldSpeed = sqrtf(xVel * xVel + zVel * zVel);

                xVel += zVel * (intendedMag / 32.0f) * sinsG(intendedDYaw) * 0.05f;
                zVel -= xVel * (intendedMag / 32.0f) * sinsG(intendedDYaw) * 0.05f;

                float newSpeed = sqrtf(xVel * xVel + zVel * zVel);

                xVel = xVel * oldSpeed / newSpeed;
                zVel = zVel * oldSpeed / newSpeed;

                xVel += 7.0f * steepness * sinsG(slopeAngle);
                zVel += 7.0f * steepness * cossG(slopeAngle);

                xVel *= lossFactor;
                zVel *= lossFactor;

                float intendedPos[3] = { slideSol->upwarpPosition[0], slideSol->upwarpPosition[1], slideSol->upwarpPosition[2] };
                SurfaceG* newFloor = floor;
                bool fallTest = false;

                for (int j = 0; j < 4; j++) {
                    intendedPos[0] = intendedPos[0] + newFloor->normal[1] * (xVel / 4.0f);
                    intendedPos[2] = intendedPos[2] + newFloor->normal[1] * (zVel / 4.0f);

                    int floorIdx = find_floor(intendedPos, &newFloor, floorHeight, floorsG, total_floorsG);

                    if (floorIdx == -1) {
                        break;
                    }
                    else if (intendedPos[1] > floorHeight + 100.0f) {
                        fallTest = true;
                        break;
                    }
                }

                if (fallTest) {
                    int slideYaw = atan2sG(zVel, xVel);

                    int facingDYaw = slideSol->postSlideAngle - slideYaw;

                    int newFacingDYaw = (short)facingDYaw;

                    if (newFacingDYaw > 0 && newFacingDYaw <= 0x4000) {
                        if ((newFacingDYaw -= 0x200) < 0) {
                            newFacingDYaw = 0;
                        }
                    }
                    else if (newFacingDYaw > -0x4000 && newFacingDYaw < 0) {
                        if ((newFacingDYaw += 0x200) > 0) {
                            newFacingDYaw = 0;
                        }
                    }
                    else if (newFacingDYaw > 0x4000 && newFacingDYaw < 0x8000) {
                        if ((newFacingDYaw += 0x200) > 0x8000) {
                            newFacingDYaw = 0x8000;
                        }
                    }
                    else if (newFacingDYaw > -0x8000 && newFacingDYaw < -0x4000) {
                        if ((newFacingDYaw -= 0x200) < -0x8000) {
                            newFacingDYaw = -0x8000;
                        }
                    }

                    int postSlideAngle = (unsigned short)(slideYaw + newFacingDYaw);

                    float postSlideSpeed = -sqrtf(xVel * xVel + zVel * zVel);

                    xVel = postSlideSpeed * sinsG(postSlideAngle);
                    float yVel = 0.0f;
                    zVel = postSlideSpeed * cossG(postSlideAngle);

                    bool falling = true;
                    bool landed = false;

                    while (falling) {
                        for (int j = 0; j < 4; j++) {
                            intendedPos[0] = intendedPos[0] + (xVel / 4.0f);
                            intendedPos[1] = intendedPos[1] + (yVel / 4.0f);
                            intendedPos[2] = intendedPos[2] + (zVel / 4.0f);

                            float oldFloorHeight = floorHeight;
                            int floorIdx = find_floor(intendedPos, &newFloor, floorHeight, floorsG, total_floorsG);

                            if (floorIdx == -1) {
                                if (intendedPos[1] <= oldFloorHeight) {
                                    intendedPos[1] = oldFloorHeight;
                                    landed = true;
                                }
                                falling = false;
                                break;
                            }
                            else if (newFloor->normal[1] < 0.7880108) {
                                falling = false;
                                break;
                            }
                            else if (intendedPos[1] <= floorHeight) {
                                yVel = 0.0f;
                                intendedPos[1] = floorHeight;
                                falling = false;

                                if (!newFloor->is_lava) {
                                    float nextPos[3] = { intendedPos[0], intendedPos[1], intendedPos[2] };

                                    for (int k = 0; k < 12; k++) {
                                        nextPos[0] = nextPos[0] + newFloor->normal[1] * (xVel / 4.0f);
                                        nextPos[2] = nextPos[2] + newFloor->normal[1] * (zVel / 4.0f);

                                        floorIdx = find_floor(nextPos, &newFloor, floorHeight, floorsG, total_floorsG);

                                        if (floorIdx == -1) {
                                            landed = true;
                                            break;
                                        }
                                        else {
                                            intendedPos[0] = nextPos[0];
                                            intendedPos[2] = nextPos[2];
                                            
                                            if (intendedPos[1] > floorHeight + 100.0f) {
                                                falling = true;
                                                break;
                                            }
                                            else {
                                                intendedPos[1] = floorHeight;
                                            }
                                        }
                                    }

                                    if (falling) {
                                        continue;
                                    }
                                }

                                break;
                            }
                            else if (intendedPos[1] < -1357.0) {
                                falling = false;
                                break;
                            }
                            else if (intendedPos[0] < INT_MIN || intendedPos[0] > INT_MAX || intendedPos[2] < INT_MIN || intendedPos[2] > INT_MAX) {
                                falling = false;
                                break;
                            }
                        }

                        yVel = fminf(yVel - 4.0f, 75.0f);
                    }

                    if (landed && intendedPos[1] >= -1357.0) {
                        int solIdx = atomicAdd(&(counts.nBDSolutions), 1);

                        if (solIdx < limits.MAX_BD_SOLUTIONS) {
                            BDSolution* solution = &(solutions.bdSolutions[solIdx]);
                            solution->slideSolutionIdx = slideIdx;
                            solution->cameraYaw = cameraYaw;
                            solution->stickX = rawX;
                            solution->stickY = rawY;
                            solution->landingPosition[0] = intendedPos[0];
                            solution->landingPosition[1] = intendedPos[1];
                            solution->landingPosition[2] = intendedPos[2];
                            solution->postSlideSpeed = postSlideSpeed;
                            atomicAdd(&(tenKSol->bdSetups), 1);
                        }
                    }
                }
            }
        }
    }
}

__device__ void try_upwarp_slide(int solIdx, int angle, int intendedDYaw, float intendedMag) {
    struct TenKSolution* tenKSol = &(solutions.tenKSolutions[solIdx]);
    struct SpeedSolution* speedSol = &(solutions.speedSolutions[tenKSol->speedSolutionIdx]);
    struct SKUpwarpSolution* skuwSol = &(solutions.skuwSolutions[speedSol->skuwSolutionIdx]);
    struct UpwarpSolution* uwSol = &(solutions.upwarpSolutions[skuwSol->uwIdx]);
    struct PlatformSolution* platSol = &(solutions.platSolutions[uwSol->platformSolutionIdx]);

    float lossFactor = intendedMag / 32.0f * cossG(intendedDYaw) * 0.02f + 0.92f;
    
    int slopeAngle = atan2sG(platSol->endTriangleNormals[platSol->endFloorIdx][2], platSol->endTriangleNormals[platSol->endFloorIdx][0]);

    float steepness = sqrtf(platSol->endTriangleNormals[platSol->endFloorIdx][0] * platSol->endTriangleNormals[platSol->endFloorIdx][0] + platSol->endTriangleNormals[platSol->endFloorIdx][2] * platSol->endTriangleNormals[platSol->endFloorIdx][2]);

    float xVel0 = speedSol->returnSpeed * sinsG(angle);
    float zVel0 = speedSol->returnSpeed * cossG(angle);

    float xVel1 = xVel0;
    float zVel1 = zVel0;

    float oldSpeed = sqrtf(xVel1 * xVel1 + zVel1 * zVel1);

    xVel1 += zVel1 * (intendedMag / 32.0f) * sinsG(intendedDYaw) * 0.05f;
    zVel1 -= xVel1 * (intendedMag / 32.0f) * sinsG(intendedDYaw) * 0.05f;

    float newSpeed = sqrtf(xVel1 * xVel1 + zVel1 * zVel1);

    xVel1 = xVel1 * oldSpeed / newSpeed;
    zVel1 = zVel1 * oldSpeed / newSpeed;

    xVel1 += 7.0f * steepness * sinsG(slopeAngle);
    zVel1 += 7.0f * steepness * cossG(slopeAngle);

    xVel1 *= lossFactor;
    zVel1 *= lossFactor;

    float intendedPos[3] = { platSol->endPosition[0], platSol->endPosition[1], platSol->endPosition[2] };

    int floorIdx = platSol->endFloorIdx;
    bool slideCheck = true;

    for (int s = 0; s < 4; s++) {
        intendedPos[0] = intendedPos[0] + platSol->endTriangleNormals[floorIdx][1] * (xVel1 / 4.0f);
        intendedPos[2] = intendedPos[2] + platSol->endTriangleNormals[floorIdx][1] * (zVel1 / 4.0f);

        float floorHeight;
        floorIdx = find_floor(intendedPos, platSol->endTriangles, platSol->endTriangleNormals, &floorHeight);

        if (floorIdx == -1 || floorHeight <= -3071.0f) {
            slideCheck = false;
            break;
        }
        else {
            intendedPos[1] = floorHeight;
        }
    }

    if (slideCheck) {
        float prePositionTest[3] = { platSol->penultimatePosition[0] + platSol->penultimateFloorNormalY * xVel0 / 4.0f, platSol->penultimatePosition[1], platSol->penultimatePosition[2] + platSol->penultimateFloorNormalY * zVel0 / 4.0f };

        if (!check_inbounds(prePositionTest)) {
            float test_normal[3] = { platSol->endNormal[0], platSol->endNormal[1], platSol->endNormal[2] };
            float mario_pos[3] = { intendedPos[0], intendedPos[1], intendedPos[2]};

            short triangles[2][3][3];
            float normals[2][3];
            float mat[4][4];

            platform_logic(test_normal, mario_pos, triangles, normals, mat);

            bool upwarpPositionTest = false;

            for (int i = 0; i < n_y_ranges && !upwarpPositionTest; i++) {
                if (mario_pos[1] >= lower_y[i] && mario_pos[1] <= upper_y[i]) {
                    upwarpPositionTest = true;
                }
            }

            upwarpPositionTest = upwarpPositionTest && check_inbounds(mario_pos);

            if (upwarpPositionTest) {
                int slideYaw = atan2sG(zVel1, xVel1);

                int facingDYaw = angle - slideYaw;

                int newFacingDYaw = (short)facingDYaw;

                if (newFacingDYaw > 0 && newFacingDYaw <= 0x4000) {
                    if ((newFacingDYaw -= 0x200) < 0) {
                        newFacingDYaw = 0;
                    }
                }
                else if (newFacingDYaw > -0x4000 && newFacingDYaw < 0) {
                    if ((newFacingDYaw += 0x200) > 0) {
                        newFacingDYaw = 0;
                    }
                }
                else if (newFacingDYaw > 0x4000 && newFacingDYaw < 0x8000) {
                    if ((newFacingDYaw += 0x200) > 0x8000) {
                        newFacingDYaw = 0x8000;
                    }
                }
                else if (newFacingDYaw > -0x8000 && newFacingDYaw < -0x4000) {
                    if ((newFacingDYaw -= 0x200) < -0x8000) {
                        newFacingDYaw = -0x8000;
                    }
                }

                int postSlideAngle = (unsigned short)(slideYaw + newFacingDYaw);

                float postSlideSpeed = -sqrtf(xVel1 * xVel1 + zVel1 * zVel1);

                float postSlideVelX = postSlideSpeed * sinsG(postSlideAngle);
                float postSlideVelZ = postSlideSpeed * cossG(postSlideAngle);

                float nextPosition[3] = { mario_pos[0] + (postSlideVelX / 4.0f), mario_pos[1], mario_pos[2] + (postSlideVelZ / 4.0f) };

                if (!check_inbounds(nextPosition)) {
                    int idx = atomicAdd(&(counts.nSlideSolutions), 1);

                    if (idx < limits.MAX_SLIDE_SOLUTIONS) {
                        SlideSolution* solution = &(solutions.slideSolutions[idx]);
                        solution->tenKSolutionIdx = solIdx;
                        solution->preUpwarpPosition[0] = intendedPos[0];
                        solution->preUpwarpPosition[1] = intendedPos[1];
                        solution->preUpwarpPosition[2] = intendedPos[2];
                        solution->upwarpPosition[0] = mario_pos[0];
                        solution->upwarpPosition[1] = mario_pos[1];
                        solution->upwarpPosition[2] = mario_pos[2];
                        solution->angle = angle;
                        solution->intendedDYaw = intendedDYaw;
                        solution->stickMag = intendedMag;
                        solution->postSlideAngle = postSlideAngle;
                        solution->postSlideSpeed = postSlideSpeed;
                    }
                }
            }
        }
    }
}

__device__ void try_pu_slide_angle(int solIdx, int angle, double minEndAngle, double maxEndAngle, double minM1, double maxM1) {
    double minAngleDiff = fmax(minEndAngle - angle, -(double)522);
    double maxAngleDiff = fmin(maxEndAngle - angle, (double)522);

    if (minAngleDiff <= maxAngleDiff) {
        double minEndAngleA = minAngleDiff + angle;
        double maxEndAngleA = maxAngleDiff + angle;

        double minN;
        double maxN;

        if (angle == 0 || angle == 32768) {
            double sinStartAngle = sin(2.0 * M_PI * (double)angle / 65536.0);

            minN = -cos(2.0 * M_PI * minEndAngleA / 65536.0) / sinStartAngle;
            maxN = -cos(2.0 * M_PI * maxEndAngleA / 65536.0) / sinStartAngle;
        }
        else {
            double sinStartAngle = sinsG(angle);
            double cosStartAngle = cossG(angle);

            double sinMinEndAngle = sin(2.0 * M_PI * minEndAngleA / 65536.0);
            double cosMinEndAngle = cos(2.0 * M_PI * minEndAngleA / 65536.0);

            double sinMaxEndAngle = sin(2.0 * M_PI * maxEndAngleA / 65536.0);
            double cosMaxEndAngle = cos(2.0 * M_PI * maxEndAngleA / 65536.0);

            double t = sinStartAngle / cosStartAngle;
            double s = sinMinEndAngle / cosMinEndAngle;

            bool signTest = (cosStartAngle > 0 && cosMinEndAngle > 0) || (cosStartAngle < 0 && cosMinEndAngle < 0);

            if (signTest) {
                minN = (-((double)s * (double)t) - 1.0 + sqrt(((double)s * (double)t - 1.0) * ((double)s * (double)t - 1.0) + 4.0 * (double)s * (double)s)) / (2.0 * (double)s);
            }
            else {
                minN = (-((double)s * (double)t) - 1.0 - sqrt(((double)s * (double)t - 1.0) * ((double)s * (double)t - 1.0) + 4.0 * (double)s * (double)s)) / (2.0 * (double)s);
            }

            s = sinMaxEndAngle / cosMaxEndAngle;

            signTest = (cosStartAngle > 0 && cosMaxEndAngle > 0) || (cosStartAngle < 0 && cosMaxEndAngle < 0);

            if (signTest) {
                maxN = (-((double)s * (double)t) - 1.0 + sqrt(((double)s * (double)t - 1.0) * ((double)s * (double)t - 1.0) + 4.0 * (double)s * (double)s)) / (2.0 * (double)s);
            }
            else {
                maxN = (-((double)s * (double)t) - 1.0 - sqrt(((double)s * (double)t - 1.0) * ((double)s * (double)t - 1.0) + 4.0 * (double)s * (double)s)) / (2.0 * (double)s);
            }
        }

        double minN1 = 32.0 * minN / 0.05;
        double maxN1 = 32.0 * maxN / 0.05;

        if (minN1 > maxN1) {
            double temp = minN1;
            minN1 = maxN1;
            maxN1 = temp;
        }

        minN1 = fmax(minN1, -32.0);
        maxN1 = fmin(maxN1, 32.0);

        if (minN1 <= maxN1) {
            double minMag = INFINITY;
            double maxMag = -INFINITY;

            double minYaw = INFINITY;
            double maxYaw = -INFINITY;

            double refYaw = 65536.0 * (atan2(minN1, minM1) / (2.0 * M_PI));
            refYaw = fmod(65536.0 + refYaw, 65536.0);

            for (int i = 0; i < 4; i++) {
                double m1;
                double n1;

                if (i % 2 == 0) {
                    m1 = minM1;
                }
                else {
                    m1 = maxM1;
                }

                if (i / 2 == 0) {
                    n1 = minN1;
                }
                else {
                    n1 = maxN1;
                }

                double mag = sqrt(m1 * m1 + n1 * n1);
                double yaw = 65536.0 * (atan2(n1, m1) / (2.0 * M_PI));
                yaw = fmod(65536.0 + yaw, 65536.0);

                double yawDiff = yaw - refYaw;
                yawDiff = fmod(fmod(yawDiff, 65536.0) + 98304.0, 65536.0) - 32768.0f;

                minMag = fmin(minMag, mag);
                maxMag = fmax(maxMag, mag);
                minYaw = fmin(minYaw, yawDiff);
                maxYaw = fmax(maxYaw, yawDiff);
            }

            maxMag = fmin(maxMag, 32.0);

            if (minMag <= maxMag) {
                int minIntendedDYaw = 16 * (int)ceil((minYaw + refYaw) / 16);
                int maxIntendedDYaw = 16 * (int)floor((maxYaw + refYaw) / 16);

                int minIdx = -1;
                int maxIdx = magCount;

                while (maxIdx > minIdx + 1) {
                    int midIdx = (maxIdx + minIdx) / 2;

                    if (minMag - 0.001 < magSet[midIdx]) {
                        maxIdx = midIdx;
                    }
                    else {
                        minIdx = midIdx;
                    }
                }

                int startMagIdx = maxIdx;

                minIdx = -1;
                maxIdx = magCount;

                while (maxIdx > minIdx + 1) {
                    int midIdx = (maxIdx + minIdx) / 2;

                    if (maxMag + 0.001 < magSet[midIdx]) {
                        maxIdx = midIdx;
                    }
                    else {
                        minIdx = midIdx;
                    }
                }

                int endMagIdx = minIdx;
                
                for (int intendedDYaw = minIntendedDYaw; intendedDYaw <= maxIntendedDYaw; intendedDYaw+=slideAngleSampleRate) {
                    for (int magIdx = startMagIdx; magIdx <= endMagIdx; magIdx++) {
                        float intendedMag = magSet[magIdx];
                        try_upwarp_slide(solIdx, angle, intendedDYaw, intendedMag);
                    }
                }
                
            }
        }
    }
}

__global__ void test_slide_angle() {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    int angleIdx = idx % maxAngleRange;
    idx = idx / maxAngleRange;

    if (idx < min(counts.n10KSolutions, limits.MAX_10K_SOLUTIONS)) {
        struct TenKSolution* tenKSol = &(solutions.tenKSolutions[idx]);
        int angle = tenKSol->minStartAngle + angleIdx * slideAngleSampleRate;

        if (angle <= tenKSol->maxStartAngle) {
            try_pu_slide_angle(idx, (unsigned short)angle, tenKSol->minEndAngle, tenKSol->maxEndAngle, tenKSol->minM1, tenKSol->maxM1);
        }
    }
}

__global__ void find_slide_solutions() {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(counts.n10KSolutions, limits.MAX_10K_SOLUTIONS)) {
        struct TenKSolution* tenKSol = &(solutions.tenKSolutions[idx]);
        struct SpeedSolution* speedSol = &(solutions.speedSolutions[tenKSol->speedSolutionIdx]);
        struct SKUpwarpSolution* skuwSol = &(solutions.skuwSolutions[speedSol->skuwSolutionIdx]);
        struct UpwarpSolution* uwSol = &(solutions.upwarpSolutions[skuwSol->uwIdx]);
        struct PlatformSolution* platSol = &(solutions.platSolutions[uwSol->platformSolutionIdx]);

        int maxTurnAngle = 522;

        double minDist = INFINITY;
        double maxDist = -INFINITY;

        double baseAngle = 0.0;

        double minEndAngle = 0.0;
        double maxEndAngle = 0.0;

        for (int i = 0; i < 3; i++) {
            double xDist = 65536.0 * uwSol->pux + platSol->endTriangles[platSol->endFloorIdx][i][0] - platSol->endPosition[0];
            double zDist = 65536.0 * uwSol->puz + platSol->endTriangles[platSol->endFloorIdx][i][2] - platSol->endPosition[2];

            double dist = sqrt(xDist * xDist + zDist * zDist);

            double angle = atan2(-xDist, -zDist);
            angle = fmod(2.0 * M_PI + angle, 2.0 * M_PI);

            if (i == 0) {
                baseAngle = angle;
            }
            else {
                minEndAngle = fmin(minEndAngle, angle - baseAngle);
                maxEndAngle = fmax(maxEndAngle, angle - baseAngle);
            }

            minDist = fmin(minDist, dist);
            maxDist = fmax(maxDist, dist);
        }

        double minSpeed = -minDist / (double)platSol->endTriangleNormals[platSol->endFloorIdx][1];
        double maxSpeed = -maxDist / (double)platSol->endTriangleNormals[platSol->endFloorIdx][1];

        double minM = minSpeed / (double)speedSol->returnSpeed;
        double maxM = maxSpeed / (double)speedSol->returnSpeed;

        double minM1 = 32.0 * ((minM - 0.92) / 0.02);
        double maxM1 = 32.0 * ((maxM - 0.92) / 0.02);

        if (minM1 > maxM1) {
            double temp = minM1;
            minM1 = maxM1;
            maxM1 = temp;
        }

        minM1 = fmax(minM1, -32.0);
        maxM1 = fmin(maxM1, 32.0);

        if (minM1 <= maxM1) {
            minEndAngle = minEndAngle + baseAngle;
            maxEndAngle = maxEndAngle + baseAngle;

            minEndAngle = 65536.0 * minEndAngle / (2.0 * M_PI);
            maxEndAngle = 65536.0 * maxEndAngle / (2.0 * M_PI);

            int minStartAngle = (int)ceil(minEndAngle) - maxTurnAngle;
            int maxStartAngle = (int)floor(maxEndAngle) + maxTurnAngle;

            minStartAngle = minStartAngle + 15;
            minStartAngle = minStartAngle - (minStartAngle % 16);

            tenKSol->minStartAngle = minStartAngle;
            tenKSol->maxStartAngle = maxStartAngle;
            tenKSol->minEndAngle = minEndAngle;
            tenKSol->maxEndAngle = maxEndAngle;
            tenKSol->maxM1 = maxM1;
            tenKSol->minM1 = minM1;

            int angleRange = ((maxStartAngle - minStartAngle)/slideAngleSampleRate) + 1;
            atomicMax(&maxAngleRange, angleRange);
        }
    }
}

__device__ bool try_pu_xz(float* normal, float* position, short(&current_triangles)[2][3][3], float(&triangle_normals)[2][3], double x, double z, int platSolIdx) {
    // For current (x, z) PU position, find range of yaws that
    // allow you to reach the PU platform from the original universe.

    float test_normal[3] = { normal[0], normal[1], normal[2] };
    float mario_pos[3] = { (float)x + position[0], position[1], (float)z + position[2] };

    short triangles[2][3][3];
    float normals[2][3];
    float mat[4][4];

    platform_logic(test_normal, mario_pos, triangles, normals, mat);

    if (check_inbounds(mario_pos)) {
        for (int i = 0; i < n_y_ranges; i++) {
            if (mario_pos[1] >= *(lower_y + i) && mario_pos[1] < *(upper_y + i)) {
                bool good_solution = false;

                for (int f = 0; f < n_floor_ranges; f++) {
                    if (mario_pos[1] >= lower_floor[f] && mario_pos[1] <= upper_floor[f]) {
                        good_solution = true;
                        break;
                    }
                }

                if (!good_solution) {
                    float floor_dist = 65536.0;
                    float speed = 65536.0 * sqrtf(x * x + z * z);

                    for (int f = 0; f < n_floor_ranges; f++) {
                        float f_dist = mario_pos[1] - lower_floor[f];

                        if (f_dist > 0) {
                            floor_dist = f_dist;
                        }
                        else {
                            break;
                        }
                    }

                    int falling_frames = (int)ceil((sqrt(2.0 * floor_dist + 1.0) + 1.0) / 2.0);

                    int closest_pu_dist = fmin(fmin(mario_pos[0] + pow(2, 31), pow(2, 31) - 1.0 - mario_pos[0]), fmin(mario_pos[2] + pow(2, 31), pow(2, 31) - 1.0 - mario_pos[2]));

                    if (closest_pu_dist >= speed / 4.0f) {
                        int total_falling_frames = (int)floor((pow(2, 32) - closest_pu_dist - 3.0 * speed / 2.0) / speed);

                        if (falling_frames <= total_falling_frames) {
                            good_solution = true;
                        }
                    }
                }

                if (good_solution) {
                    int solIdx = atomicAdd(&(counts.nUpwarpSolutions), 1);

                    if (solIdx < limits.MAX_UPWARP_SOLUTIONS) {
                        UpwarpSolution solution;
                        solution.platformSolutionIdx = platSolIdx;
                        solution.pux = (int)roundf(x / 65536.0f);
                        solution.puz = (int)roundf(z / 65536.0f);
                        solutions.upwarpSolutions[solIdx] = solution;
                    }

                    break;
                }
            }
        }
    }

    return true;
}

__device__ bool try_pu_x(float* normal, float* position, short(&current_triangles)[2][3][3], float(&triangle_normals)[2][3], float(&T_start)[4][4], float(&T_tilt)[4][4], double x, double x1_min, double x1_max, double x2_min, double x2_max, double platform_min_x, double platform_max_x, double platform_min_z, double platform_max_z, double m, double c_min, double c_max, int q_steps, double max_speed, int platSolIdx) {
    double pu_platform_min_x = x + platform_min_x;
    double pu_platform_max_x = x + platform_max_x;

    double pu_gap = 65536.0 * q_steps;

    // Find maximal range of PUs along z axis from current x PU position
    double min_z_pu_idx = (m * pu_platform_min_x + c_min) / pu_gap;
    double max_z_pu_idx = (m * pu_platform_max_x + c_max) / pu_gap;

    if (min_z_pu_idx > max_z_pu_idx) {
        double temp = min_z_pu_idx;
        min_z_pu_idx = max_z_pu_idx;
        max_z_pu_idx = temp;
    }

    // Check max_x_pu_idx and min_x_pu_idx are in range for valid platform tilt.
    // Correct them if they're not.
    //
    // Possible for only part of the platform to be in range.
    // In this case just skip whole PU to avoid headaches later on.

    if (pu_platform_max_x > fmin(x1_min, x1_max) && pu_platform_min_x < fmax(x1_min, x1_max)) {
        double z1_min = m * x1_min + c_min;
        double z1_max = m * x1_max + c_max;
        double tilt_cutoff_z = (z1_max - z1_min) * (x - x1_min) / (x1_max - x1_min) + z1_min;

        if (x1_min > 0) {
            // Find new lower bound for z_pu
            double tilt_cutoff_pu_idx = (tilt_cutoff_z - platform_max_z) / pu_gap;
            min_z_pu_idx = fmax(min_z_pu_idx, tilt_cutoff_pu_idx);
        }
        else {
            // Find new upper bound for z_pu
            double tilt_cutoff_pu_idx = (tilt_cutoff_z - platform_min_z) / pu_gap;
            max_z_pu_idx = fmin(max_z_pu_idx, tilt_cutoff_pu_idx);
        }
    }

    if (pu_platform_max_x > fmin(x2_min, x2_max) && pu_platform_min_x < fmax(x2_min, x2_max)) {
        double z2_min = m * x2_min + c_min;
        double z2_max = m * x2_max + c_max;
        double tilt_cutoff_z = (z2_max - z2_min) * (x - x2_min) / (x2_max - x2_min) + z2_min;

        if (x2_min > 0) {
            // Find new upper bound for z_pu
            double tilt_cutoff_pu_idx = (tilt_cutoff_z - platform_min_z) / pu_gap;
            max_z_pu_idx = fmin(max_z_pu_idx, tilt_cutoff_pu_idx);
        }
        else {
            // Find new lower bound for z_pu
            double tilt_cutoff_pu_idx = (tilt_cutoff_z - platform_max_z) / pu_gap;
            min_z_pu_idx = fmax(min_z_pu_idx, tilt_cutoff_pu_idx);
        }
    }

    min_z_pu_idx = q_steps * ceil(min_z_pu_idx);
    max_z_pu_idx = q_steps * floor(max_z_pu_idx);

    double min_z_pu = 65536.0 * min_z_pu_idx;
    double max_z_pu = 65536.0 * max_z_pu_idx;

    double closest_z_pu_platform;

    if (min_z_pu < 0) {
        if (max_z_pu < 0) {
            closest_z_pu_platform = max_z_pu + platform_max_z - platform_min_z;
        }
        else {
            if (abs(min_z_pu) < abs(max_z_pu)) {
                closest_z_pu_platform = min_z_pu + platform_max_z - platform_min_z;
            }
            else {
                closest_z_pu_platform = max_z_pu + platform_min_z - platform_max_z;
            }
        }
    }
    else {
        closest_z_pu_platform = min_z_pu + platform_min_z - platform_max_z;
    }

    // Find the minimum speed to reach a valid PU from current x position.
    // If this exceeds our maximum allowed speed, then we can stop searching polygon
    // in this direction.
    double min_needed_speed = (4.0 / (double)q_steps) * sqrt((x + platform_max_z - platform_min_z) * (x + platform_max_z - platform_min_z) + (closest_z_pu_platform * closest_z_pu_platform)) / fmax(triangle_normals[0][1], triangle_normals[1][1]);

    if (min_needed_speed > max_speed) {
        return false;
    }
    else {
        double min_pu_oob_z;

        if (q_steps < 4) {
            // If we're terminating Mario's movement early, then we need to be sure that 
            // there's enough of a difference between the y normals of the platform's two 
            // triangles to force Mario into out of bounds

            double closest_oob = 9743.23; // An estimate, based on the platforms pivot

            double min_dist_oob = closest_oob / (fmax(triangle_normals[0][1], triangle_normals[1][1]) / fmin(triangle_normals[0][1], triangle_normals[1][1]) - 1.0);
            double min_dist_oob_z = sqrt(min_dist_oob * min_dist_oob - x * x);

            min_pu_oob_z = ceil(min_dist_oob_z / 262144.0) * pu_gap;
        }
        else {
            min_pu_oob_z = 0.0;
        }

        double T_diff00 = T_tilt[0][0] - T_start[0][0];
        double T_diff20 = T_tilt[2][0] - T_start[2][0];
        double T_diff02 = T_tilt[0][2] - T_start[0][2];
        double T_diff22 = T_tilt[2][2] - T_start[2][2];

        // Tolerance for picking PUs that may result 
        // in out of bounds displacements.
        //
        // If we're more than the dimensions of the platform 
        // away from being in-bounds then we probably can't
        // get an in-bounds displacement anyway.
        double disp_leeway = abs(platform_min_x - platform_max_x) + abs(platform_min_z - platform_max_z);

        // Search backwards from z=0
        for (double z = fmin(fmin(0.0, max_z_pu), -min_pu_oob_z); z + 8192 > min_z_pu; z -= pu_gap) {
            double base_platform_displacement_x = x * T_diff00 + z * T_diff20;
            double base_platform_displacement_z = x * T_diff02 + z * T_diff22;

            double bpd_x_mod = static_cast<int16_t>(static_cast<int>(x + platform_pos[0] + base_platform_displacement_x));
            double bpd_z_mod = static_cast<int16_t>(static_cast<int>(z + platform_pos[2] + base_platform_displacement_z));

            // Check if our likely horizontal platform displacement puts us out of bounds.
            // If so, skip checking this PU.
            if (abs(bpd_x_mod) < 8192 + disp_leeway && abs(bpd_z_mod) < 8192 + disp_leeway) {
                if (!try_pu_xz(normal, position, current_triangles, triangle_normals, x, z, platSolIdx)) {
                    break;
                }
            }
        }

        // Search forwards from z>0
        for (double z = fmax(fmax(q_steps * pu_gap, min_z_pu), min_pu_oob_z); z - 8192 < max_z_pu; z += pu_gap) {
            double base_platform_displacement_x = x * T_diff00 + z * T_diff20;
            double base_platform_displacement_z = x * T_diff02 + z * T_diff22;

            double bpd_x_mod = static_cast<int16_t>(static_cast<int>(x + platform_pos[0] + base_platform_displacement_x));
            double bpd_z_mod = static_cast<int16_t>(static_cast<int>(z + platform_pos[2] + base_platform_displacement_z));

            // Check if our likely horizontal platform displacement puts us out of bounds.
            // If so, skip checking this PU.
            if (abs(bpd_x_mod) < 8192 + disp_leeway && abs(bpd_z_mod) < 8192 + disp_leeway) {
                if (!try_pu_xz(normal, position, current_triangles, triangle_normals, x, z, platSolIdx)) {
                    break;
                }
            }
        }

        return true;
    }
}

__device__ bool try_pu_z(float* normal, float* position, short(&current_triangles)[2][3][3], float(&triangle_normals)[2][3], float(&T_start)[4][4], float(&T_tilt)[4][4], double z, double z1_min, double z1_max, double z2_min, double z2_max, double platform_min_x, double platform_max_x, double platform_min_z, double platform_max_z, double m, double c_min, double c_max, int q_steps, double max_speed, int platSolIdx) {
    double pu_platform_min_z = z + platform_min_z;
    double pu_platform_max_z = z + platform_max_z;

    double pu_gap = 65535.0 * q_steps;

    // Find maximal range of PUs along x axis from current z PU position
    double min_x_pu_idx = ((pu_platform_min_z - c_min) / m) / pu_gap;
    double max_x_pu_idx = ((pu_platform_max_z - c_max) / m) / pu_gap;

    if (min_x_pu_idx > max_x_pu_idx) {
        double temp = min_x_pu_idx;
        min_x_pu_idx = max_x_pu_idx;
        max_x_pu_idx = temp;
    }

    // Check max_x_pu and min_x_pu are in range for valid platform tilt.
    // Correct them if they're not.
    //
    // Possible for only part of the platform to be in range.
    // In this case just skip it to avoid headaches later on.

    if (pu_platform_max_z > fmin(z1_min, z1_max) && pu_platform_min_z < fmax(z1_min, z1_max)) {
        double x1_min = (z1_min - c_min) / m;
        double x1_max = (z1_max - c_max) / m;
        double tilt_cutoff_x = (x1_max - x1_min) * (z - z1_min) / (z1_max - z1_min) + x1_min;

        if (z1_min > 0) {
            // Find new upper bound for z_pu
            double tilt_cutoff_pu_idx = (tilt_cutoff_x - platform_min_x) / pu_gap;
            max_x_pu_idx = fmin(max_x_pu_idx, tilt_cutoff_pu_idx);
        }
        else {
            // Find new lower bound for z_pu
            double tilt_cutoff_pu_idx = (tilt_cutoff_x - platform_max_x) / pu_gap;
            min_x_pu_idx = fmax(min_x_pu_idx, tilt_cutoff_pu_idx);
        }
    }

    if (pu_platform_max_z > fmin(z2_min, z2_max) && pu_platform_min_z < fmax(z2_min, z2_max)) {
        double x2_min = (z2_min - c_min) / m;
        double x2_max = (z2_max - c_max) / m;
        double tilt_cutoff_x = (x2_max - x2_min) * (z - z2_min) / (z2_max - z2_min) + x2_min;

        if (z2_min > 0) {
            // Find new lower bound for z_pu
            double tilt_cutoff_pu_idx = (tilt_cutoff_x - platform_max_x) / pu_gap;
            min_x_pu_idx = fmax(min_x_pu_idx, tilt_cutoff_pu_idx);
        }
        else {
            // Find new upper bound for z_pu
            double tilt_cutoff_pu_idx = (tilt_cutoff_x - platform_min_x) / pu_gap;
            max_x_pu_idx = fmin(max_x_pu_idx, tilt_cutoff_pu_idx);
        }
    }

    min_x_pu_idx = q_steps * ceil(min_x_pu_idx);
    max_x_pu_idx = q_steps * floor(max_x_pu_idx);

    double min_x_pu = 65536.0 * min_x_pu_idx;
    double max_x_pu = 65536.0 * max_x_pu_idx;

    double closest_x_pu_platform;

    if (min_x_pu < 0) {
        if (max_x_pu < 0) {
            closest_x_pu_platform = max_x_pu + platform_max_x - platform_min_x;
        }
        else {
            if (abs(min_x_pu) < abs(max_x_pu)) {
                closest_x_pu_platform = min_x_pu + platform_max_x - platform_min_x;
            }
            else {
                closest_x_pu_platform = max_x_pu + platform_min_x - platform_max_x;
            }
        }
    }
    else {
        closest_x_pu_platform = min_x_pu + platform_min_x - platform_max_x;
    }

    // Find the minimum speed to reach a valid PU from current z position.
    // If this exceeds our maximum allowed speed, then we can stop searching
    // the polygon in this direction.
    double min_needed_speed = (4.0 / (double)q_steps) * sqrt((z + platform_max_x - platform_min_x) * (z + platform_max_x - platform_min_x) + (closest_x_pu_platform * closest_x_pu_platform)) / fmax(triangle_normals[0][1], triangle_normals[1][1]);

    if (min_needed_speed > max_speed) {
        return false;
    }
    else {
        double min_pu_oob_x;

        if (q_steps < 4) {
            // If we're terminating Mario's movement early, then we need to be sure that 
            // there's enough of a difference between the y normals of the platform's two 
            // triangles to force Mario into out of bounds

            double closest_oob = 9743.23; // An estimate, based on the platform's pivot

            double min_dist_oob = closest_oob / (fmax(triangle_normals[0][1], triangle_normals[1][1]) / fmin(triangle_normals[0][1], triangle_normals[1][1]) - 1.0);
            double min_dist_oob_x = sqrt(min_dist_oob * min_dist_oob - z * z);

            min_pu_oob_x = ceil(min_dist_oob_x / 262144.0) * pu_gap;
        }
        else {
            min_pu_oob_x = 0.0;
        }

        double T_diff00 = T_tilt[0][0] - T_start[0][0];
        double T_diff20 = T_tilt[2][0] - T_start[2][0];
        double T_diff02 = T_tilt[0][2] - T_start[0][2];
        double T_diff22 = T_tilt[2][2] - T_start[2][2];

        // Tolerance for picking PUs that may result 
        // in out of bounds displacements.
        //
        // If we're more than the dimensions of the platform 
        // away from being in-bounds then we probably can't
        // get an in-bounds displacement anyway.
        double disp_leeway = abs(platform_min_x - platform_max_x) + abs(platform_min_z - platform_max_z);

        // Search backwards from x=0
        for (double x = fmin(fmin(0.0, max_x_pu), -min_pu_oob_x); x + 8192 > min_x_pu; x -= pu_gap) {
            double base_platform_displacement_x = x * T_diff00 + z * T_diff20;
            double base_platform_displacement_z = x * T_diff02 + z * T_diff22;

            double bpd_x_mod = static_cast<int16_t>(static_cast<int>(x + platform_pos[0] + base_platform_displacement_x));
            double bpd_z_mod = static_cast<int16_t>(static_cast<int>(z + platform_pos[2] + base_platform_displacement_z));

            // Check if our likely horizontal platform displacement puts us out of bounds.
            // If so, skip checking this PU.
            if (abs(bpd_x_mod) < 8192 + disp_leeway && abs(bpd_z_mod) < 8192 + disp_leeway) {
                if (!try_pu_xz(normal, position, current_triangles, triangle_normals, x, z, platSolIdx)) {
                    break;
                }
            }
        }

        // Search forwards from x>0
        for (double x = fmax(fmax(pu_gap, min_x_pu), min_pu_oob_x); x - 8192 < max_x_pu; x += pu_gap) {
            double base_platform_displacement_x = x * T_diff00 + z * T_diff20;
            double base_platform_displacement_z = x * T_diff02 + z * T_diff22;

            double bpd_x_mod = static_cast<int16_t>(static_cast<int>(x + platform_pos[0] + base_platform_displacement_x));
            double bpd_z_mod = static_cast<int16_t>(static_cast<int>(z + platform_pos[2] + base_platform_displacement_z));

            // Check if our likely horizontal platform displacement puts us out of bounds.
            // If so, skip checking this PU.
            if (abs(bpd_x_mod) < 8192 + disp_leeway && abs(bpd_z_mod) < 8192 + disp_leeway) {
                if (!try_pu_xz(normal, position, current_triangles, triangle_normals, x, z, platSolIdx)) {
                    break;
                }
            }
        }

        return true;
    }
}

__device__ void try_normal(float* normal, float* position, int platSolIdx, double max_speed) {
    // Tilt angle cut-offs
    // These are the yaw boundaries where the platform tilt 
    // switches direction. Directions match normal_offsets:
    // Between a[0] and a[1]: +x +z
    // Between a[1] and a[2]: -x +z
    // Between a[2] and a[3]: -x -z
    // Between a[3] and a[0]: +x -z

    short current_triangles[2][3][3];
    float triangle_normals[2][3];

    float T_start[4][4];
    T_start[1][0] = normal[0];
    T_start[1][1] = normal[1];
    T_start[1][2] = normal[2];

    float invsqrt = 1.0f / sqrtf(T_start[1][0] * T_start[1][0] + T_start[1][1] * T_start[1][1] + T_start[1][2] * T_start[1][2]);

    T_start[1][0] *= invsqrt;
    T_start[1][1] *= invsqrt;
    T_start[1][2] *= invsqrt;

    T_start[0][0] = T_start[1][1] * 1.0f - 0.0f * T_start[1][2];
    T_start[0][1] = T_start[1][2] * 0.0f - 1.0f * T_start[1][0];
    T_start[0][2] = T_start[1][0] * 0.0f - 0.0f * T_start[1][1];

    invsqrt = 1.0f / sqrtf(T_start[0][0] * T_start[0][0] + T_start[0][1] * T_start[0][1] + T_start[0][2] * T_start[0][2]);

    T_start[0][0] *= invsqrt;
    T_start[0][1] *= invsqrt;
    T_start[0][2] *= invsqrt;

    T_start[2][0] = T_start[0][1] * T_start[1][2] - T_start[1][1] * T_start[0][2];
    T_start[2][1] = T_start[0][2] * T_start[1][0] - T_start[1][2] * T_start[0][0];
    T_start[2][2] = T_start[0][0] * T_start[1][1] - T_start[1][0] * T_start[0][1];

    invsqrt = 1.0f / sqrtf(T_start[2][0] * T_start[2][0] + T_start[2][1] * T_start[2][1] + T_start[2][2] * T_start[2][2]);

    T_start[2][0] *= invsqrt;
    T_start[2][1] *= invsqrt;
    T_start[2][2] *= invsqrt;

    T_start[3][0] = platform_pos[0];
    T_start[3][1] = platform_pos[1];
    T_start[3][2] = platform_pos[2];
    T_start[0][3] = 0.0f;
    T_start[1][3] = 0.0f;
    T_start[2][3] = 0.0f;
    T_start[3][3] = 1.0f;

    for (int h = 0; h < 2; h++) {
        for (int i = 0; i < 3; i++) {
            float vx = default_triangles[h][i][0];
            float vy = default_triangles[h][i][1];
            float vz = default_triangles[h][i][2];

            current_triangles[h][i][0] = (short)(int)(vx * T_start[0][0] + vy * T_start[1][0] + vz * T_start[2][0] + T_start[3][0]);
            current_triangles[h][i][1] = (short)(int)(vx * T_start[0][1] + vy * T_start[1][1] + vz * T_start[2][1] + T_start[3][1]);
            current_triangles[h][i][2] = (short)(int)(vx * T_start[0][2] + vy * T_start[1][2] + vz * T_start[2][2] + T_start[3][2]);
        }

        triangle_normals[h][0] = ((current_triangles[h][1][1] - current_triangles[h][0][1]) * (current_triangles[h][2][2] - current_triangles[h][1][2])) - ((current_triangles[h][1][2] - current_triangles[h][0][2]) * (current_triangles[h][2][1] - current_triangles[h][1][1]));
        triangle_normals[h][1] = ((current_triangles[h][1][2] - current_triangles[h][0][2]) * (current_triangles[h][2][0] - current_triangles[h][1][0])) - ((current_triangles[h][1][0] - current_triangles[h][0][0]) * (current_triangles[h][2][2] - current_triangles[h][1][2]));
        triangle_normals[h][2] = ((current_triangles[h][1][0] - current_triangles[h][0][0]) * (current_triangles[h][2][1] - current_triangles[h][1][1])) - ((current_triangles[h][1][1] - current_triangles[h][0][1]) * (current_triangles[h][2][0] - current_triangles[h][1][0]));

        invsqrt = 1.0f / sqrtf(triangle_normals[h][0] * triangle_normals[h][0] + triangle_normals[h][1] * triangle_normals[h][1] + triangle_normals[h][2] * triangle_normals[h][2]);

        triangle_normals[h][0] *= invsqrt;
        triangle_normals[h][1] *= invsqrt;
        triangle_normals[h][2] *= invsqrt;
    }

    float nx = normal[0];
    float ny = normal[1];
    float nz = normal[2];

    double a[4];
    a[0] = atan2(nz, sqrt(1 - nz * nz));
    a[1] = atan2(sqrt(1 - nx * nx), nx);
    a[2] = M_PI - a[0];
    a[3] = 2 * M_PI - a[1];

    double platform_min_x = fmin(fmin((double)current_triangles[0][0][0], (double)current_triangles[0][1][0]), fmin((double)current_triangles[0][2][0], (double)current_triangles[1][2][0]));
    double platform_max_x = fmax(fmax((double)current_triangles[0][0][0], (double)current_triangles[0][1][0]), fmax((double)current_triangles[0][2][0], (double)current_triangles[1][2][0]));
    double platform_min_z = fmin(fmin((double)current_triangles[0][0][2], (double)current_triangles[0][1][2]), fmin((double)current_triangles[0][2][2], (double)current_triangles[1][2][2]));
    double platform_max_z = fmax(fmax((double)current_triangles[0][0][2], (double)current_triangles[0][1][2]), fmax((double)current_triangles[0][2][2], (double)current_triangles[1][2][2]));

    double min_y = fmin(-3071.0, fmin(fmin((double)current_triangles[0][0][1], (double)current_triangles[0][1][1]), fmin((double)current_triangles[0][2][1], (double)current_triangles[1][2][1])));
    double max_y = fmax(fmax((double)current_triangles[0][0][1], (double)current_triangles[0][1][1]), fmax((double)current_triangles[0][2][1], (double)current_triangles[1][2][1]));

    // Try to find solutions for each possible platform tilt direction
    for (int i = 0; i < 4; i++) {
        float T_tilt[4][4];
        T_tilt[1][0] = normal[0] + normal_offsets[i][0];
        T_tilt[1][1] = normal[1] + normal_offsets[i][1];
        T_tilt[1][2] = normal[2] + normal_offsets[i][2];

        float invsqrt = 1.0f / sqrtf(T_tilt[1][0] * T_tilt[1][0] + T_tilt[1][1] * T_tilt[1][1] + T_tilt[1][2] * T_tilt[1][2]);

        T_tilt[1][0] *= invsqrt;
        T_tilt[1][1] *= invsqrt;
        T_tilt[1][2] *= invsqrt;

        T_tilt[0][0] = T_tilt[1][1] * 1.0f - 0.0f * T_tilt[1][2];
        T_tilt[0][1] = T_tilt[1][2] * 0.0f - 1.0f * T_tilt[1][0];
        T_tilt[0][2] = T_tilt[1][0] * 0.0f - 0.0f * T_tilt[1][1];

        invsqrt = 1.0f / sqrtf(T_tilt[0][0] * T_tilt[0][0] + T_tilt[0][1] * T_tilt[0][1] + T_tilt[0][2] * T_tilt[0][2]);

        T_tilt[0][0] *= invsqrt;
        T_tilt[0][1] *= invsqrt;
        T_tilt[0][2] *= invsqrt;

        T_tilt[2][0] = T_tilt[0][1] * T_tilt[1][2] - T_tilt[1][1] * T_tilt[0][2];
        T_tilt[2][1] = T_tilt[0][2] * T_tilt[1][0] - T_tilt[1][2] * T_tilt[0][0];
        T_tilt[2][2] = T_tilt[0][0] * T_tilt[1][1] - T_tilt[1][0] * T_tilt[0][1];

        invsqrt = 1.0f / sqrtf(T_tilt[2][0] * T_tilt[2][0] + T_tilt[2][1] * T_tilt[2][1] + T_tilt[2][2] * T_tilt[2][2]);

        T_tilt[2][0] *= invsqrt;
        T_tilt[2][1] *= invsqrt;
        T_tilt[2][2] *= invsqrt;

        T_tilt[3][0] = platform_pos[0];
        T_tilt[3][1] = platform_pos[1];
        T_tilt[3][2] = platform_pos[2];
        T_tilt[0][3] = 0.0f;
        T_tilt[1][3] = 0.0f;
        T_tilt[2][3] = 0.0f;
        T_tilt[3][3] = 1.0f;

        double T_diff01 = T_tilt[0][1] - T_start[0][1];
        double T_diff11 = T_tilt[1][1] - T_start[1][1];
        double T_diff21 = T_tilt[2][1] - T_start[2][1];

        for (int j = 0; j < n_y_ranges; j++) {
            double r_min = lower_y[j] - (1 + T_diff11) * max_y + T_diff01 * platform_pos[0] + T_diff11 * platform_pos[1] + T_diff21 * platform_pos[2];
            double r_max = upper_y[j] - (1 + T_diff11) * min_y + T_diff01 * platform_pos[0] + T_diff11 * platform_pos[1] + T_diff21 * platform_pos[2];

            // z = mx + c_min
            // z = mx + c_max
            //
            // PU platforms occurring between these lines will (usually) 
            // give a y displacement within our desired range.
            double m = -T_diff01 / T_diff21;
            double c_min; double c_max;

            if (T_diff21 < 0) {
                c_min = r_max / T_diff21;
                c_max = r_min / T_diff21;
            }
            else {
                c_min = r_min / T_diff21;
                c_max = r_max / T_diff21;
            }

            // Find intersection between y displacement lines and 
            // good platform tilt angle ranges.
            //
            // Intersection forms a polygon that may (or may not)
            // stretch to infinity in one direction.
            // 
            // Find the x coordinates where displacement lines and 
            // platform tilt lines intersect.
            //
            // Non-intersecting lines have x coordinate set to NaN. 
            double a1_cos = cos(a[i]);
            double a2_cos = cos(a[(i + 1) % 4]);

            double x1_min; double x1_max; double x2_min; double x2_max;

            if (nx == 0) {
                if (i % 2 == 0) {
                    x1_min = (c_min + tan(a[i]) * platform_pos[0] - platform_pos[2]) / (tan(a[i]) - m);
                    x1_max = (c_max + tan(a[i]) * platform_pos[0] - platform_pos[2]) / (tan(a[i]) - m);
                    x2_min = 0;
                    x2_max = 0;

                    if (a1_cos > 0 && x1_min < platform_pos[0] || a1_cos < 0 && x1_min > platform_pos[0]) {
                        x1_min = NAN;
                    }

                    if (a1_cos > 0 && x1_max < platform_pos[0] || a1_cos < 0 && x1_max > platform_pos[0]) {
                        x1_max = NAN;
                    }

                    if (nz > 0 && c_min < platform_pos[0] || nz < 0 && c_min > platform_pos[0]) {
                        x2_min = NAN;
                    }

                    if (nz > 0 && c_max < platform_pos[0] || nz < 0 && c_max > platform_pos[0]) {
                        x2_max = NAN;
                    }
                }
                else {
                    x1_min = 0;
                    x1_max = 0;
                    x2_min = (c_min + tan(a[(i + 1) % 4]) * platform_pos[0] - platform_pos[2]) / (tan(a[(i + 1) % 4]) - m);
                    x2_max = (c_max + tan(a[(i + 1) % 4]) * platform_pos[0] - platform_pos[2]) / (tan(a[(i + 1) % 4]) - m);

                    if (nz > 0 && c_min < platform_pos[0] || nz < 0 && c_min > platform_pos[0]) {
                        x1_min = NAN;
                    }

                    if (nz > 0 && c_max < platform_pos[0] || nz < 0 && c_max > platform_pos[0]) {
                        x1_max = NAN;
                    }

                    if (a2_cos > 0 && x2_min < platform_pos[0] || a2_cos < 0 && x2_min > platform_pos[0]) {
                        x2_min = NAN;
                    }

                    if (a2_cos > 0 && x2_max < platform_pos[0] || a2_cos < 0 && x2_max >platform_pos[0]) {
                        x2_max = NAN;
                    }
                }
            }
            else {
                x1_min = (c_min + tan(a[i]) * platform_pos[0] - platform_pos[2]) / (tan(a[i]) - m);
                x1_max = (c_max + tan(a[i]) * platform_pos[0] - platform_pos[2]) / (tan(a[i]) - m);
                x2_min = (c_min + tan(a[(i + 1) % 4]) * platform_pos[0] - platform_pos[2]) / (tan(a[(i + 1) % 4]) - m);
                x2_max = (c_max + tan(a[(i + 1) % 4]) * platform_pos[0] - platform_pos[2]) / (tan(a[(i + 1) % 4]) - m);

                if (a1_cos > 0 && x1_min < platform_pos[0] || a1_cos < 0 && x1_min > platform_pos[0]) {
                    x1_min = NAN;
                }

                if (a1_cos > 0 && x1_max < platform_pos[0] || a1_cos < 0 && x1_max > platform_pos[0]) {
                    x1_max = NAN;
                }

                if (a2_cos > 0 && x2_min < platform_pos[0] || a2_cos < 0 && x2_min > platform_pos[0]) {
                    x2_min = NAN;
                }

                if (a2_cos > 0 && x2_max < platform_pos[0] || a2_cos < 0 && x2_max > platform_pos[0]) {
                    x2_max = NAN;
                }
            }


            // Mario's movement can end on any of his quarter steps, as long as the next move puts him 
            // out of bounds (or is the last step). So we need to consider PU movement for each possible
            // final quarter step

            // If the normals match then you can't force Mario out of bounds after his final q step.
            // Therefore, only 4 q_steps are possible.
            int q = 4;
            double pu_gap = 65536.0 * q;

            // Start searching for PUs in the polygon.
            //
            // We want to minimise speed, so we search outwards
            // from the point closest to the real platform.
            //
            // This will be at the x = 0 (if abs(m) < 1)
            // or z = 0 (if abs(m) > 1)
            if (abs(m) < 1) {
                // Find x limits of polygon
                double poly_x_start; double poly_x_end;

                if (!isnan(x1_min) && !isnan(x1_max)) {
                    if (!isnan(x2_min) && !isnan(x2_max)) {
                        poly_x_start = fmin(fmin(x1_min, x1_max), fmin(x2_min, x2_max));
                        poly_x_end = fmax(fmax(x1_min, x1_max), fmax(x2_min, x2_max));
                    }
                    else {
                        if (c_min > 0) {
                            poly_x_start = -INFINITY;
                            poly_x_end = fmax(x1_min, x1_max);
                        }
                        else {
                            poly_x_start = fmin(x1_min, x1_max);
                            poly_x_end = INFINITY;
                        }
                    }
                }
                else if (!isnan(x2_min) && !isnan(x2_max)) {
                    if (c_min > 0) {
                        poly_x_start = fmin(x2_min, x2_max);
                        poly_x_end = INFINITY;
                    }
                    else {
                        poly_x_start = -INFINITY;
                        poly_x_end = fmax(x2_min, x2_max);
                    }
                }
                else {
                    continue;
                }

                double first_x_pu = ceil((poly_x_start - platform_max_x) / pu_gap) * pu_gap;
                double last_x_pu = floor((poly_x_end - platform_min_x) / pu_gap) * pu_gap;

                // Search backwards from x=0
                for (double x = fmin(0.0, last_x_pu); x + platform_min_x > poly_x_start; x -= pu_gap) {
                    if (!try_pu_x(normal, position, current_triangles, triangle_normals, T_start, T_tilt, x, x1_min, x1_max, x2_min, x2_max, platform_min_x, platform_max_x, platform_min_z, platform_max_z, m, c_min, c_max, q, max_speed, platSolIdx)) {
                        break;
                    }
                }

                // Search forwards from x>0
                for (double x = fmax(pu_gap, first_x_pu); x - platform_max_x < poly_x_end; x += pu_gap) {
                    if (!try_pu_x(normal, position, current_triangles, triangle_normals, T_start, T_tilt, x, x1_min, x1_max, x2_min, x2_max, platform_min_x, platform_max_x, platform_min_z, platform_max_z, m, c_min, c_max, q, max_speed, platSolIdx)) {
                        break;
                    }
                }
            }
            else {
                // Calculate z coordinates of intersection points
                double z1_min = tan(a[i]) * x1_min + platform_pos[2] - tan(a[i]) * platform_pos[0];
                double z1_max = tan(a[i]) * x1_max + platform_pos[2] - tan(a[i]) * platform_pos[0];
                double z2_min = tan(a[(i + 1) % 4]) * x2_min + platform_pos[2] - tan(a[(i + 1) % 4]) * platform_pos[0];
                double z2_max = tan(a[(i + 1) % 4]) * x2_max + platform_pos[2] - tan(a[(i + 1) % 4]) * platform_pos[0];

                // Find z limits of polygon
                double poly_z_start; double poly_z_end;

                if (!isnan(z1_min) && !isnan(z1_max)) {
                    if (!isnan(z2_min) && !isnan(z2_max)) {
                        poly_z_start = fmin(fmin(z1_min, z1_max), fmin(z2_min, z2_max));
                        poly_z_end = fmax(fmax(z1_min, z1_max), fmax(z2_min, z2_max));
                    }
                    else {
                        if (c_min / m > 0) {
                            poly_z_start = -INFINITY;
                            poly_z_end = fmax(z1_min, z1_max);
                        }
                        else {
                            poly_z_start = fmin(z1_min, z1_max);
                            poly_z_end = INFINITY;
                        }
                    }
                }
                else if (!isnan(z2_min) && !isnan(z2_max)) {
                    if (c_min / m > 0) {
                        poly_z_start = fmin(z2_min, z2_max);
                        poly_z_end = INFINITY;
                    }
                    else {
                        poly_z_start = -INFINITY;
                        poly_z_end = fmax(z2_min, z2_max);
                    }
                }
                else {
                    continue;
                }

                double first_z_pu = ceil((poly_z_start - platform_max_z) / pu_gap) * pu_gap;
                double last_z_pu = floor((poly_z_end - platform_min_z) / pu_gap) * pu_gap;

                // Search backwards from z=0
                for (double z = fmin(0.0, last_z_pu); z + platform_min_z > poly_z_start; z -= pu_gap) {
                    if (!try_pu_z(normal, position, current_triangles, triangle_normals, T_start, T_tilt, z, z1_min, z1_max, z2_min, z2_max, platform_min_x, platform_max_x, platform_min_z, platform_max_z, m, c_min, c_max, q, max_speed, platSolIdx)) {
                        break;
                    }
                }

                // Search forwards from z>0
                for (double z = fmax(pu_gap, first_z_pu); z - platform_max_z < poly_z_end; z += pu_gap) {
                    if (!try_pu_z(normal, position, current_triangles, triangle_normals, T_start, T_tilt, z, z1_min, z1_max, z2_min, z2_max, platform_min_x, platform_max_x, platform_min_z, platform_max_z, m, c_min, c_max, q, max_speed, platSolIdx)) {
                        break;
                    }
                }
            }
        }
    }
}

__global__ void find_upwarp_solutions(float maxSpeed) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(counts.nPlatSolutions, limits.MAX_PLAT_SOLUTIONS)) {
        struct PlatformSolution* platSol = &(solutions.platSolutions[idx]);
        try_normal(platSol->endNormal, platSol->endPosition, idx, maxSpeed);
    }
}

__device__ void try_position(float* marioPos, float* normal, int maxFrames) {
    const float platformPos[3] = { platform_pos[0], platform_pos[1], platform_pos[2] };
    const short defaultTriangles[2][3][3] = { {{307, 307, -306}, {-306, 307, -306}, {-306, 307, 307}}, {{307, 307, -306}, {-306, 307, 307}, {307, 307, 307}} };

    float mat[4][4];
    mat[1][0] = (normal[0] <= 0.0f) ? ((0.0f - normal[0] < 0.01f) ? 0.0f : (normal[0] + 0.01f)) : ((0.0f - normal[0] > -0.01f) ? 0.0f : (normal[0] - 0.01f));
    mat[1][1] = (normal[1] <= 1.0f) ? ((1.0f - normal[1] < 0.01f) ? 1.0f : (normal[1] + 0.01f)) : ((1.0f - normal[1] > -0.01f) ? 1.0f : (normal[1] - 0.01f));
    mat[1][2] = (normal[2] <= 0.0f) ? ((0.0f - normal[2] < 0.01f) ? 0.0f : (normal[2] + 0.01f)) : ((0.0f - normal[2] > -0.01f) ? 0.0f : (normal[2] - 0.01f));

    float invsqrt = 1.0f / sqrtf(mat[1][0] * mat[1][0] + mat[1][1] * mat[1][1] + mat[1][2] * mat[1][2]);

    mat[1][0] *= invsqrt;
    mat[1][1] *= invsqrt;
    mat[1][2] *= invsqrt;

    mat[0][0] = mat[1][1] * 1.0f - 0.0f * mat[1][2];
    mat[0][1] = mat[1][2] * 0.0f - 1.0f * mat[1][0];
    mat[0][2] = mat[1][0] * 0.0f - 0.0f * mat[1][1];

    invsqrt = 1.0f / sqrtf(mat[0][0] * mat[0][0] + mat[0][1] * mat[0][1] + mat[0][2] * mat[0][2]);

    mat[0][0] *= invsqrt;
    mat[0][1] *= invsqrt;
    mat[0][2] *= invsqrt;

    mat[2][0] = mat[0][1] * mat[1][2] - mat[1][1] * mat[0][2];
    mat[2][1] = mat[0][2] * mat[1][0] - mat[1][2] * mat[0][0];
    mat[2][2] = mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];

    invsqrt = 1.0f / sqrtf(mat[2][0] * mat[2][0] + mat[2][1] * mat[2][1] + mat[2][2] * mat[2][2]);

    mat[2][0] *= invsqrt;
    mat[2][1] *= invsqrt;
    mat[2][2] *= invsqrt;

    mat[3][0] = platformPos[0];
    mat[3][1] = platformPos[1];
    mat[3][2] = platformPos[2];
    mat[0][3] = 0.0f;
    mat[1][3] = 0.0f;
    mat[2][3] = 0.0f;
    mat[3][3] = 1.0f;

    short currentTriangles[2][3][3];
    float triangleNormals[2][3];

    for (int h = 0; h < 2; h++) {
        for (int i = 0; i < 3; i++) {
            float vx = defaultTriangles[h][i][0];
            float vy = defaultTriangles[h][i][1];
            float vz = defaultTriangles[h][i][2];

            currentTriangles[h][i][0] = (short)(int)(vx * mat[0][0] + vy * mat[1][0] + vz * mat[2][0] + mat[3][0]);
            currentTriangles[h][i][1] = (short)(int)(vx * mat[0][1] + vy * mat[1][1] + vz * mat[2][1] + mat[3][1]);
            currentTriangles[h][i][2] = (short)(int)(vx * mat[0][2] + vy * mat[1][2] + vz * mat[2][2] + mat[3][2]);
        }

        triangleNormals[h][0] = ((currentTriangles[h][1][1] - currentTriangles[h][0][1]) * (currentTriangles[h][2][2] - currentTriangles[h][1][2])) - ((currentTriangles[h][1][2] - currentTriangles[h][0][2]) * (currentTriangles[h][2][1] - currentTriangles[h][1][1]));
        triangleNormals[h][1] = ((currentTriangles[h][1][2] - currentTriangles[h][0][2]) * (currentTriangles[h][2][0] - currentTriangles[h][1][0])) - ((currentTriangles[h][1][0] - currentTriangles[h][0][0]) * (currentTriangles[h][2][2] - currentTriangles[h][1][2]));
        triangleNormals[h][2] = ((currentTriangles[h][1][0] - currentTriangles[h][0][0]) * (currentTriangles[h][2][1] - currentTriangles[h][1][1])) - ((currentTriangles[h][1][1] - currentTriangles[h][0][1]) * (currentTriangles[h][2][0] - currentTriangles[h][1][0]));

        invsqrt = 1.0f / sqrtf(triangleNormals[h][0] * triangleNormals[h][0] + triangleNormals[h][1] * triangleNormals[h][1] + triangleNormals[h][2] * triangleNormals[h][2]);

        triangleNormals[h][0] *= invsqrt;
        triangleNormals[h][1] *= invsqrt;
        triangleNormals[h][2] *= invsqrt;
    }

    float floor_height = 0.0;
    int floor_idx = -1;

    short x = (short)(int)marioPos[0];
    short y = (short)(int)marioPos[1];
    short z = (short)(int)marioPos[2];

    for (int i = 0; i < 2; i++) {
        short x1 = currentTriangles[i][0][0];
        short z1 = currentTriangles[i][0][2];
        short x2 = currentTriangles[i][1][0];
        short z2 = currentTriangles[i][1][2];

        // Check that the point is within the triangle bounds.
        if ((z1 - z) * (x2 - x1) - (x1 - x) * (z2 - z1) < 0) {
            continue;
        }

        // To slightly save on computation time, set this later.
        int16_t x3 = currentTriangles[i][2][0];
        int16_t z3 = currentTriangles[i][2][2];

        if ((z2 - z) * (x3 - x2) - (x2 - x) * (z3 - z2) < 0) {
            continue;
        }
        if ((z3 - z) * (x1 - x3) - (x3 - x) * (z1 - z3) < 0) {
            continue;
        }

        float nx = triangleNormals[i][0];
        float ny = triangleNormals[i][1];
        float nz = triangleNormals[i][2];
        float oo = -(nx * x1 + ny * currentTriangles[i][0][1] + nz * z1);

        // Find the height of the floor at a given location.
        float height = -(x * nx + nz * z + oo) / ny;
        // Checks for floor interaction with a 78 unit buffer.
        if (y - (height + -78.0f) < 0.0f) {
            continue;
        }

        floor_height = height;
        floor_idx = i;
        break;
    }

    if (floor_idx != -1 && floor_height - 100.0f > -3071.0f && floor_height >= -2967.168)
    {
        marioPos[1] = floor_height;

        mat[1][0] = normal[0];
        mat[1][1] = normal[1];
        mat[1][2] = normal[2];

        invsqrt = 1.0f / sqrtf(mat[1][0] * mat[1][0] + mat[1][1] * mat[1][1] + mat[1][2] * mat[1][2]);

        mat[1][0] *= invsqrt;
        mat[1][1] *= invsqrt;
        mat[1][2] *= invsqrt;

        mat[0][0] = mat[1][1] * 1.0f - 0.0f * mat[1][2];
        mat[0][1] = mat[1][2] * 0.0f - 1.0f * mat[1][0];
        mat[0][2] = mat[1][0] * 0.0f - 0.0f * mat[1][1];

        invsqrt = 1.0f / sqrtf(mat[0][0] * mat[0][0] + mat[0][1] * mat[0][1] + mat[0][2] * mat[0][2]);

        mat[0][0] *= invsqrt;
        mat[0][1] *= invsqrt;
        mat[0][2] *= invsqrt;

        mat[2][0] = mat[0][1] * mat[1][2] - mat[1][1] * mat[0][2];
        mat[2][1] = mat[0][2] * mat[1][0] - mat[1][2] * mat[0][0];
        mat[2][2] = mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];

        invsqrt = 1.0f / sqrtf(mat[2][0] * mat[2][0] + mat[2][1] * mat[2][1] + mat[2][2] * mat[2][2]);

        mat[2][0] *= invsqrt;
        mat[2][1] *= invsqrt;
        mat[2][2] *= invsqrt;

        mat[3][0] = platformPos[0];
        mat[3][1] = platformPos[1];
        mat[3][2] = platformPos[2];
        mat[0][3] = 0.0f;
        mat[1][3] = 0.0f;
        mat[2][3] = 0.0f;
        mat[3][3] = 1.0f;

        for (int h = 0; h < 2; h++) {
            for (int i = 0; i < 3; i++) {
                float vx = defaultTriangles[h][i][0];
                float vy = defaultTriangles[h][i][1];
                float vz = defaultTriangles[h][i][2];

                currentTriangles[h][i][0] = (short)(int)(vx * mat[0][0] + vy * mat[1][0] + vz * mat[2][0] + mat[3][0]);
                currentTriangles[h][i][1] = (short)(int)(vx * mat[0][1] + vy * mat[1][1] + vz * mat[2][1] + mat[3][1]);
                currentTriangles[h][i][2] = (short)(int)(vx * mat[0][2] + vy * mat[1][2] + vz * mat[2][2] + mat[3][2]);
            }

            triangleNormals[h][0] = ((currentTriangles[h][1][1] - currentTriangles[h][0][1]) * (currentTriangles[h][2][2] - currentTriangles[h][1][2])) - ((currentTriangles[h][1][2] - currentTriangles[h][0][2]) * (currentTriangles[h][2][1] - currentTriangles[h][1][1]));
            triangleNormals[h][1] = ((currentTriangles[h][1][2] - currentTriangles[h][0][2]) * (currentTriangles[h][2][0] - currentTriangles[h][1][0])) - ((currentTriangles[h][1][0] - currentTriangles[h][0][0]) * (currentTriangles[h][2][2] - currentTriangles[h][1][2]));
            triangleNormals[h][2] = ((currentTriangles[h][1][0] - currentTriangles[h][0][0]) * (currentTriangles[h][2][1] - currentTriangles[h][1][1])) - ((currentTriangles[h][1][1] - currentTriangles[h][0][1]) * (currentTriangles[h][2][0] - currentTriangles[h][1][0]));

            invsqrt = 1.0f / sqrtf(triangleNormals[h][0] * triangleNormals[h][0] + triangleNormals[h][1] * triangleNormals[h][1] + triangleNormals[h][2] * triangleNormals[h][2]);

            triangleNormals[h][0] *= invsqrt;
            triangleNormals[h][1] *= invsqrt;
            triangleNormals[h][2] *= invsqrt;
        }

        float returnPos[3] = { marioPos[0], marioPos[1], marioPos[2] };

        bool oTiltingPyramidMarioOnPlatform = false;
        bool onPlatform = false;

        float lastYNormal = triangleNormals[floor_idx][1];
        float lastPos[3] = { marioPos[0], marioPos[1], marioPos[2] };

        float landingPositions[3][3];
        float landingNormalsY[3];

        for (int f = 0; f < maxFrames; f++) {
            float dx;
            float dy;
            float dz;
            float d;

            float dist[3];
            float posBeforeRotation[3];
            float posAfterRotation[3];

            // Mario's position
            float mx;
            float my;
            float mz;

            int marioOnPlatform = 0;

            if (onPlatform)
            {
                mx = marioPos[0];
                my = marioPos[1];
                mz = marioPos[2];

                dist[0] = mx - (float)platformPos[0];
                dist[1] = my - (float)platformPos[1];
                dist[2] = mz - (float)platformPos[2];

                for (int i = 0; i < 3; i++) {
                    posBeforeRotation[i] = mat[0][i] * dist[0] + mat[1][i] * dist[1] + mat[2][i] * dist[2];
                }

                dx = mx - (float)platformPos[0];
                dy = 500.0f;
                dz = mz - (float)platformPos[2];
                d = sqrtf(dx * dx + dy * dy + dz * dz);

                //! Always true since dy = 500, making d >= 500.
                if (d != 0.0f) {
                    // Normalizing
                    d = 1.0 / d;
                    dx *= d;
                    dy *= d;
                    dz *= d;
                }
                else {
                    dx = 0.0f;
                    dy = 1.0f;
                    dz = 0.0f;
                }

                if (oTiltingPyramidMarioOnPlatform == true)
                    marioOnPlatform++;
                oTiltingPyramidMarioOnPlatform = true;
            }
            else
            {
                dx = 0.0f;
                dy = 1.0f;
                dz = 0.0f;
                oTiltingPyramidMarioOnPlatform = false;
            }

            // Approach the normals by 0.01f towards the new goal, then create a transform matrix and orient the object. 
            // Outside of the other conditionals since it needs to tilt regardless of whether Mario is on.

            normal[0] = (normal[0] <= dx) ? ((dx - normal[0] < 0.01f) ? dx : (normal[0] + 0.01f)) : ((dx - normal[0] > -0.01f) ? dx : (normal[0] - 0.01f));
            normal[1] = (normal[1] <= dy) ? ((dy - normal[1] < 0.01f) ? dy : (normal[1] + 0.01f)) : ((dy - normal[1] > -0.01f) ? dy : (normal[1] - 0.01f));
            normal[2] = (normal[2] <= dz) ? ((dz - normal[2] < 0.01f) ? dz : (normal[2] + 0.01f)) : ((dz - normal[2] > -0.01f) ? dz : (normal[2] - 0.01f));

            mat[1][0] = normal[0];
            mat[1][1] = normal[1];
            mat[1][2] = normal[2];

            invsqrt = 1.0f / sqrtf(mat[1][0] * mat[1][0] + mat[1][1] * mat[1][1] + mat[1][2] * mat[1][2]);

            mat[1][0] *= invsqrt;
            mat[1][1] *= invsqrt;
            mat[1][2] *= invsqrt;

            mat[0][0] = mat[1][1] * 1.0f - 0.0f * mat[1][2];
            mat[0][1] = mat[1][2] * 0.0f - 1.0f * mat[1][0];
            mat[0][2] = mat[1][0] * 0.0f - 0.0f * mat[1][1];

            invsqrt = 1.0f / sqrtf(mat[0][0] * mat[0][0] + mat[0][1] * mat[0][1] + mat[0][2] * mat[0][2]);

            mat[0][0] *= invsqrt;
            mat[0][1] *= invsqrt;
            mat[0][2] *= invsqrt;

            mat[2][0] = mat[0][1] * mat[1][2] - mat[1][1] * mat[0][2];
            mat[2][1] = mat[0][2] * mat[1][0] - mat[1][2] * mat[0][0];
            mat[2][2] = mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];

            invsqrt = 1.0f / sqrtf(mat[2][0] * mat[2][0] + mat[2][1] * mat[2][1] + mat[2][2] * mat[2][2]);

            mat[2][0] *= invsqrt;
            mat[2][1] *= invsqrt;
            mat[2][2] *= invsqrt;

            mat[3][0] = platformPos[0];
            mat[3][1] = platformPos[1];
            mat[3][2] = platformPos[2];
            mat[0][3] = 0.0f;
            mat[1][3] = 0.0f;
            mat[2][3] = 0.0f;
            mat[3][3] = 1.0f;

            for (int h = 0; h < 2; h++) {
                for (int i = 0; i < 3; i++) {
                    float vx = defaultTriangles[h][i][0];
                    float vy = defaultTriangles[h][i][1];
                    float vz = defaultTriangles[h][i][2];

                    currentTriangles[h][i][0] = (short)(int)(vx * mat[0][0] + vy * mat[1][0] + vz * mat[2][0] + mat[3][0]);
                    currentTriangles[h][i][1] = (short)(int)(vx * mat[0][1] + vy * mat[1][1] + vz * mat[2][1] + mat[3][1]);
                    currentTriangles[h][i][2] = (short)(int)(vx * mat[0][2] + vy * mat[1][2] + vz * mat[2][2] + mat[3][2]);
                }

                triangleNormals[h][0] = ((currentTriangles[h][1][1] - currentTriangles[h][0][1]) * (currentTriangles[h][2][2] - currentTriangles[h][1][2])) - ((currentTriangles[h][1][2] - currentTriangles[h][0][2]) * (currentTriangles[h][2][1] - currentTriangles[h][1][1]));
                triangleNormals[h][1] = ((currentTriangles[h][1][2] - currentTriangles[h][0][2]) * (currentTriangles[h][2][0] - currentTriangles[h][1][0])) - ((currentTriangles[h][1][0] - currentTriangles[h][0][0]) * (currentTriangles[h][2][2] - currentTriangles[h][1][2]));
                triangleNormals[h][2] = ((currentTriangles[h][1][0] - currentTriangles[h][0][0]) * (currentTriangles[h][2][1] - currentTriangles[h][1][1])) - ((currentTriangles[h][1][1] - currentTriangles[h][0][1]) * (currentTriangles[h][2][0] - currentTriangles[h][1][0]));

                invsqrt = 1.0f / sqrtf(triangleNormals[h][0] * triangleNormals[h][0] + triangleNormals[h][1] * triangleNormals[h][1] + triangleNormals[h][2] * triangleNormals[h][2]);

                triangleNormals[h][0] *= invsqrt;
                triangleNormals[h][1] *= invsqrt;
                triangleNormals[h][2] *= invsqrt;
            }

            // If Mario is on the platform, adjust his position for the platform tilt.
            if (marioOnPlatform) {
                for (int i = 0; i < 3; i++) {
                    posAfterRotation[i] = mat[0][i] * dist[0] + mat[1][i] * dist[1] + mat[2][i] * dist[2];
                }

                mx += posAfterRotation[0] - posBeforeRotation[0];
                my += posAfterRotation[1] - posBeforeRotation[1];
                mz += posAfterRotation[2] - posBeforeRotation[2];
                marioPos[0] = mx;
                marioPos[1] = my;
                marioPos[2] = mz;
            }

            floor_height = 0.0;
            floor_idx = -1;

            short x = (short)(int)marioPos[0];
            short y = (short)(int)marioPos[1];
            short z = (short)(int)marioPos[2];

            for (int i = 0; i < 2; i++) {
                short x1 = currentTriangles[i][0][0];
                short z1 = currentTriangles[i][0][2];
                short x2 = currentTriangles[i][1][0];
                short z2 = currentTriangles[i][1][2];

                // Check that the point is within the triangle bounds.
                if ((z1 - z) * (x2 - x1) - (x1 - x) * (z2 - z1) < 0) {
                    continue;
                }

                // To slightly save on computation time, set this later.
                int16_t x3 = currentTriangles[i][2][0];
                int16_t z3 = currentTriangles[i][2][2];

                if ((z2 - z) * (x3 - x2) - (x2 - x) * (z3 - z2) < 0) {
                    continue;
                }
                if ((z3 - z) * (x1 - x3) - (x3 - x) * (z1 - z3) < 0) {
                    continue;
                }

                float nx = triangleNormals[i][0];
                float ny = triangleNormals[i][1];
                float nz = triangleNormals[i][2];
                float oo = -(nx * x1 + ny * currentTriangles[i][0][1] + nz * z1);

                // Find the height of the floor at a given location.
                float height = -(x * nx + nz * z + oo) / ny;
                // Checks for floor interaction with a 78 unit buffer.
                if (y - (height + -78.0f) < 0.0f) {
                    continue;
                }

                floor_height = height;
                floor_idx = i;
                break;
            }

            if (f > 0 && f < 4) {
                if (floor_idx == -1) {
                    landingNormalsY[f - 1] = 1.0;
                }
                else {
                    landingNormalsY[f - 1] = triangleNormals[floor_idx][1];
                }

                landingPositions[f - 1][0] = marioPos[0];
                landingPositions[f - 1][1] = marioPos[1];
                landingPositions[f - 1][2] = marioPos[2];
            }

            bool oldOnPlatform = onPlatform;
            onPlatform = floor_idx != -1 && fabsf(marioPos[1] - floor_height) <= 4.0;

            //Check if Mario is under the lava, or too far below the platform for it to conceivably be in reach later
            if ((floor_idx != -1 && floor_height <= -3071.0f) || (floor_idx != -1 && marioPos[1] - floor_height < -20.0f))
            {
                break;
            }

            if (onPlatform && oldOnPlatform) {
                float testNormal[3] = { fabs(normal[0]), fabs(normal[1]), fabs(normal[2]) };

                bool validSolution = false;

                if (testNormal[0] > testNormal[1] || testNormal[2] > testNormal[1]) {
                    validSolution = true;
                }
                else {
                    float offset = 0.01;

                    float a = testNormal[0] - offset;
                    float b = testNormal[2] - offset;
                    float c = testNormal[2];
                    float d = sqrtf(1 - testNormal[2] * testNormal[2]);
                    float sign = 1;

                    float v = testNormal[1] - offset;

                    float sqrt1 = sqrtf(a * a + v * v);
                    float sqrt2 = sqrtf(a * a + b * b + v * v);
                    float sqrt3 = sqrtf(testNormal[1] * testNormal[1] + testNormal[0] * testNormal[0]);
                    float sqrt4 = sqrtf(testNormal[1] * testNormal[1] + testNormal[0] * testNormal[0] + testNormal[2] * testNormal[2]);

                    float result = sign * d * sqrt1 * sqrt3 * (d * sqrt2 * (sqrt1 * testNormal[0] - a * sqrt3) * sqrt4 + c * (-sqrt1 * sqrt2 * testNormal[1] * testNormal[2] + b * v * sqrt3 * sqrt4));

                    if (result < 0) {
                        validSolution = true;
                    }
                    else {
                        c = sqrtf(1 - testNormal[0] * testNormal[0]);
                        d = testNormal[0];
                        sign = -1;
                        result = sign * d * sqrt1 * sqrt3 * (d * sqrt2 * (sqrt1 * testNormal[0] - a * sqrt3) * sqrt4 + c * (-sqrt1 * sqrt2 * testNormal[1] * testNormal[2] + b * v * sqrt3 * sqrt4));

                        if (result < 0) {
                            validSolution = true;
                        }
                    }
                }

                if (validSolution) {
                    int solIdx = atomicAdd(&(counts.nPlatSolutions), 1);

                    if (solIdx < limits.MAX_PLAT_SOLUTIONS) {
                        struct PlatformSolution solution;
                        solution.endNormal[0] = normal[0];
                        solution.endNormal[1] = normal[1];
                        solution.endNormal[2] = normal[2];
                        solution.endPosition[0] = marioPos[0];
                        solution.endPosition[1] = marioPos[1];
                        solution.endPosition[2] = marioPos[2];
                        solution.endFloorIdx = floor_idx;
                        solution.returnPosition[0] = returnPos[0];
                        solution.returnPosition[1] = returnPos[1];
                        solution.returnPosition[2] = returnPos[2];
                        solution.nFrames = f;
                        solution.penultimateFloorNormalY = lastYNormal;
                        solution.penultimatePosition[0] = lastPos[0];
                        solution.penultimatePosition[1] = lastPos[1];
                        solution.penultimatePosition[2] = lastPos[2];
                        for (int j = 0; j < 2; j++) {
                            solution.endTriangleNormals[j][0] = triangleNormals[j][0];
                            solution.endTriangleNormals[j][1] = triangleNormals[j][1];
                            solution.endTriangleNormals[j][2] = triangleNormals[j][2];

                            for (int k = 0; k < 3; k++) {
                                solution.endTriangles[j][k][0] = currentTriangles[j][k][0];
                                solution.endTriangles[j][k][1] = currentTriangles[j][k][1];
                                solution.endTriangles[j][k][2] = currentTriangles[j][k][2];
                            }
                        }
                        for (int f = 0; f < 3; f++) {
                            solution.landingPositions[f][0] = landingPositions[f][0];
                            solution.landingPositions[f][1] = landingPositions[f][1];
                            solution.landingPositions[f][2] = landingPositions[f][2];
                            solution.landingFloorNormalsY[f] = landingNormalsY[f];
                        }

                        solutions.platSolutions[solIdx] = solution;
                    }
                }
            }

            lastYNormal = triangleNormals[floor_idx][1];
            lastPos[0] = marioPos[0];
            lastPos[1] = marioPos[1];
            lastPos[2] = marioPos[2];
        }
    }
}

__global__ void testEdge(const float x0, const float x1, const float z0, const float z1, float normalX, float normalY, float normalZ, int maxFrames) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    int total = blockDim.x * gridDim.x;

    double t = (double)idx / (double)total;

    float marioPos[3] = { (float)(x0 + t * (x1 - x0)), -2500.0f, (float)(z0 + t * (z1 - z0)) };
    float normal[3] = { normalX, normalY, normalZ };

    try_position(marioPos, normal, maxFrames);
}

__global__ void simulate_tilts(const float minX, const float deltaX, const float minZ, const float deltaZ, const int width, const int height, float normalX, float normalY, float normalZ, int maxFrames) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < width * height) {
        float marioPos[3] = { minX - fmodf(minX, deltaX) + deltaX * (idx % width), -2500.0f, minZ - fmodf(minZ, deltaZ) + deltaZ * (idx / width) };
        float normal[3] = { normalX, normalY, normalZ };

        try_position(marioPos, normal, maxFrames);
    }
}

__global__ void try_stick_positionG() {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(counts.nSK5Solutions, limits.MAX_SK_PHASE_FIVE)) {
        struct SKPhase5* sol5 = &(solutions.sk5Solutions[idx]);
        struct SKPhase4* sol4 = &(solutions.sk4Solutions[sol5->p4Idx]);
        struct SKPhase3* sol3 = &(solutions.sk3Solutions[sol4->p3Idx]);
        struct SKPhase2* sol2 = (sol3->p2Type / 2 == 0) ? ((sol3->p2Type % 2 == 0) ? &(solutions.sk2ASolutions[sol3->p2Idx]) : &(solutions.sk2BSolutions[sol3->p2Idx])) : ((sol3->p2Type % 2 == 0) ? &(solutions.sk2CSolutions[sol3->p2Idx]) : &(solutions.sk2DSolutions[sol3->p2Idx]));
        struct SKPhase1* sol1 = &(solutions.sk1Solutions[sol2->p1Idx]);

        float mag = sqrtf((float)(sol5->stickX * sol5->stickX + sol5->stickY * sol5->stickY));

        float xS = sol5->stickX;
        float yS = sol5->stickY;

        if (mag > 64.0f) {
            xS = xS * (64.0f / mag);
            yS = yS * (64.0f / mag);
            mag = 64.0f;
        }

        float intendedMag = ((mag / 64.0f) * (mag / 64.0f)) * 32.0f;
        int intendedYaw = atan2sG(-yS, xS) + sol4->cameraYaw;
        int intendedDYaw = intendedYaw - sol5->f1Angle;

        float lower10KSpeed = sol4->minPre10KSpeed;
        float upper10KSpeed = sol4->maxPre10KSpeed;

        float forward = cossG(intendedDYaw);
        forward *= 0.5f + 0.5f * lower10KSpeed / 100.0f;
        float lossFactor = intendedMag / 32.0f * forward * 0.02f + 0.92f;

        lower10KSpeed *= lossFactor;
        forward = cossG(intendedDYaw);
        forward *= 0.5f + 0.5f * upper10KSpeed / 100.0f;
        lossFactor = intendedMag / 32.0f * forward * 0.02f + 0.92f;

        upper10KSpeed *= lossFactor;

        lower10KSpeed = fminf(sol4->minPost10KSpeed, lower10KSpeed);
        upper10KSpeed = fmaxf(sol4->maxPost10KSpeed, upper10KSpeed);

        if (lower10KSpeed >= upper10KSpeed) {
            float xVel = sinsG(sol2->f2Angle);
            float zVel = cossG(sol2->f2Angle);

            xVel += zVel * (intendedMag / 32.0f) * sinsG(intendedDYaw) * 0.05f;
            zVel -= xVel * (intendedMag / 32.0f) * sinsG(intendedDYaw) * 0.05f;

            double f3Angle = 65536.0 * atan2(xVel, zVel) / (2.0 * M_PI);

            double angleDiff = fmod(65536.0 + f3Angle - sol2->f2Angle, 65536.0);
            angleDiff = fmod(angleDiff + 32768.0, 65536.0) - 32768.0;

            if (angleDiff >= sol4->minAngleDiff && angleDiff <= sol4->maxAngleDiff) {
                double w = intendedMag * cossG(intendedDYaw);
                double eqB = (50.0 + 147200.0 / w);
                double eqC = -(320000.0 / w) * lower10KSpeed;
                double eqDet = eqB * eqB - eqC;
                float minSpeed = sqrt(eqDet) - eqB;

                eqC = -(320000.0 / w) * upper10KSpeed;
                eqDet = eqB * eqB - eqC;
                float maxSpeed = sqrt(eqDet) - eqB;

                xVel = minSpeed * sinsG(sol2->f2Angle) + 10.0f * cossG(sol2->f2Angle);
                zVel = minSpeed * cossG(sol2->f2Angle) - 10.0f * sinsG(sol2->f2Angle);

                float oldSpeed = sqrtf(xVel * xVel + zVel * zVel);

                xVel += zVel * (intendedMag / 32.0f) * sinsG(intendedDYaw) * 0.05f;
                zVel -= xVel * (intendedMag / 32.0f) * sinsG(intendedDYaw) * 0.05f;

                float newSpeed = sqrtf(xVel * xVel + zVel * zVel);

                xVel = xVel * oldSpeed / newSpeed;
                zVel = zVel * oldSpeed / newSpeed;

                xVel += 7.0f * tenKFloors[sol2->tenKFloorIdx][6];
                zVel += 7.0f * tenKFloors[sol2->tenKFloorIdx][8];

                int f3Angle1 = atan2sG(-zVel, -xVel);
                int f3Angle1Idx = revAtansG(f3Angle1);

                xVel = minSpeed * sinsG(sol2->f2Angle) - 10.0f * cossG(sol2->f2Angle);
                zVel = minSpeed * cossG(sol2->f2Angle) + 10.0f * sinsG(sol2->f2Angle);

                oldSpeed = sqrtf(xVel * xVel + zVel * zVel);

                xVel += zVel * (intendedMag / 32.0f) * sinsG(intendedDYaw) * 0.05f;
                zVel -= xVel * (intendedMag / 32.0f) * sinsG(intendedDYaw) * 0.05f;

                newSpeed = sqrtf(xVel * xVel + zVel * zVel);

                xVel = xVel * oldSpeed / newSpeed;
                zVel = zVel * oldSpeed / newSpeed;

                xVel += 7.0f * tenKFloors[sol2->tenKFloorIdx][6];
                zVel += 7.0f * tenKFloors[sol2->tenKFloorIdx][8];

                int f3Angle2 = atan2sG(-zVel, -xVel);
                int f3Angle2Idx = revAtansG(f3Angle2);

                int minF3AngleIdx;
                int maxF3AngleIdx;

                if (f3Angle1Idx > f3Angle2Idx) {
                    if (f3Angle1Idx - f3Angle2Idx > 4096) {
                        minF3AngleIdx = f3Angle1Idx;
                        maxF3AngleIdx = f3Angle2Idx + 8192;
                    }
                    else {
                        minF3AngleIdx = f3Angle2Idx;
                        maxF3AngleIdx = f3Angle1Idx;
                    }
                }
                else {
                    if (f3Angle2Idx - f3Angle1Idx > 4096) {
                        minF3AngleIdx = f3Angle2Idx;
                        maxF3AngleIdx = f3Angle1Idx + 8192;
                    }
                    else {
                        minF3AngleIdx = f3Angle1Idx;
                        maxF3AngleIdx = f3Angle2Idx;
                    }
                }

                for (int a = minF3AngleIdx; a <= maxF3AngleIdx; a++) {
                    int solIdx = atomicAdd(&(counts.nSK6Solutions), 1);

                    if (solIdx < limits.MAX_SK_PHASE_SIX) {
                        struct SKPhase6* solution = &(solutions.sk6Solutions[solIdx]);
                        solution->p5Idx = idx;
                        solution->minPre10KSpeed = minSpeed;
                        solution->maxPre10KSpeed = maxSpeed;
                        solution->minPost10KSpeed = lower10KSpeed;
                        solution->maxPost10KSpeed = upper10KSpeed;
                        solution->f3Angle = gArctanTableG[a % 8192];
                    }
                }
            }
        }
    }
}

__global__ void try_slide_kick_routeG2() {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(counts.nSK4Solutions, limits.MAX_SK_PHASE_FOUR)) {
        struct SKPhase4* sol4 = &(solutions.sk4Solutions[idx]);
        struct SKPhase3* sol3 = &(solutions.sk3Solutions[sol4->p3Idx]);
        struct SKPhase2* sol2 = (sol3->p2Type / 2 == 0) ? ((sol3->p2Type % 2 == 0) ? &(solutions.sk2ASolutions[sol3->p2Idx]) : &(solutions.sk2BSolutions[sol3->p2Idx])) : ((sol3->p2Type % 2 == 0) ? &(solutions.sk2CSolutions[sol3->p2Idx]) : &(solutions.sk2DSolutions[sol3->p2Idx]));
        struct SKPhase1* sol1 = &(solutions.sk1Solutions[sol2->p1Idx]);

        double minStickX = INFINITY;
        double maxStickX = -INFINITY;
        double minStickY = INFINITY;
        double maxStickY = -INFINITY;

        for (int j = sol1->minF1AngleIdx; j <= sol1->maxF1AngleIdx; j++) {
            int f1Angle = (unsigned short)gArctanTableG[j % 8192];

            for (int i = 0; i < 4; i++) {
                double m1;
                double n1;

                if (i % 2 == 0) {
                    m1 = sol4->minM1;
                }
                else {
                    m1 = sol4->maxM1;
                }

                if (i / 2 == 0) {
                    n1 = sol4->minN1;
                }
                else {
                    n1 = sol4->maxN1;
                }

                double targetDYaw = 65536.0 * (atan2(n1, m1) / (2.0 * M_PI));
                double targetMag = sqrtf(m1 * m1 + n1 * n1);

                double stickAngle = fmod(65536.0 + fmod(targetDYaw + f1Angle - sol4->cameraYaw, 65536.0), 65536.0);
                double stickMagnitude = sqrt(128.0 * targetMag);

                double xS;
                double yS;

                if (stickMagnitude < 64.0) {
                    yS = -stickMagnitude * cos(2.0 * M_PI * (stickAngle / 65536.0));
                    xS = stickMagnitude * sin(2.0 * M_PI * (stickAngle / 65536.0));

                    minStickX = fmin(minStickX, xS);
                    minStickY = fmin(minStickY, yS);
                    maxStickX = fmax(maxStickX, xS);
                    maxStickY = fmax(maxStickY, yS);
                }
                else {
                    if (stickAngle <= 8192.0 || stickAngle > 57344.0) {
                        yS = -122.0;
                        xS = -122.0 * tan(2.0 * M_PI * (stickAngle / 65536.0));

                        minStickX = fmin(minStickX, xS);
                        minStickY = fmin(minStickY, yS);

                        yS = 64.0 * cos(2.0 * M_PI * (stickAngle / 65536.0));
                        xS = 64.0 * sin(2.0 * M_PI * (stickAngle / 65536.0));

                        maxStickX = fmax(maxStickX, xS);
                        maxStickY = fmax(maxStickY, yS);
                    }
                    else if (stickAngle > 8192.0 && stickAngle <= 24576.0) {
                        yS = 64.0 * cos(2.0 * M_PI * (stickAngle / 65536.0));
                        xS = 64.0 * sin(2.0 * M_PI * (stickAngle / 65536.0));

                        minStickX = fmin(minStickX, xS);
                        minStickY = fmin(minStickY, yS);

                        yS = 121.0 / tan(2.0 * M_PI * (stickAngle / 65536.0));
                        xS = 121.0;

                        maxStickX = fmax(maxStickX, xS);
                        maxStickY = fmax(maxStickY, yS);
                    }
                    else if (stickAngle > 24576.0 && stickAngle <= 40960.0) {
                        yS = 64.0 * cos(2.0 * M_PI * (stickAngle / 65536.0));
                        xS = 64.0 * sin(2.0 * M_PI * (stickAngle / 65536.0));

                        minStickX = fmin(minStickX, xS);
                        minStickY = fmin(minStickY, yS);

                        yS = 121.0;
                        xS = 121.0 * tan(2.0 * M_PI * (stickAngle / 65536.0));

                        maxStickX = fmax(maxStickX, xS);
                        maxStickY = fmax(maxStickY, yS);
                    }
                    else {
                        yS = -122.0 / tan(2.0 * M_PI * (stickAngle / 65536.0));
                        xS = -122.0;

                        minStickX = fmin(minStickX, xS);
                        minStickY = fmin(minStickY, yS);

                        yS = 64.0 * cos(2.0 * M_PI * (stickAngle / 65536.0));
                        xS = 64.0 * sin(2.0 * M_PI * (stickAngle / 65536.0));

                        maxStickX = fmax(maxStickX, xS);
                        maxStickY = fmax(maxStickY, yS);
                    }
                }
            }

            if (maxStickX - minStickX < maxStickY - minStickY) {
                for (int x = (int)ceil(minStickX); x <= (int)floor(maxStickX); x++) {
                    if (x != 1) {
                        int y = (int)round(((double)x - minStickX) * (maxStickY - minStickY) / (maxStickX - minStickX) + minStickY);

                        if (y != 1) {
                            int solIdx = atomicAdd(&(counts.nSK5Solutions), 1);

                            if (solIdx < limits.MAX_SK_PHASE_FIVE) {
                                struct SKPhase5* solution = &(solutions.sk5Solutions[solIdx]);
                                solution->p4Idx = idx;
                                solution->stickX = x;
                                solution->stickY = y;
                                solution->f1Angle = f1Angle;
                            }
                        }
                    }
                }
            }
            else {
                for (int y = (int)ceil(minStickY); y <= (int)floor(maxStickY); y++) {
                    if (y != 1) {
                        int x = (int)round(((double)y - minStickY) * (maxStickX - minStickX) / (maxStickY - minStickY) + minStickX);

                        if (x != 1) {
                            int solIdx = atomicAdd(&(counts.nSK5Solutions), 1);

                            if (solIdx < limits.MAX_SK_PHASE_FIVE) {
                                struct SKPhase5* solution = &(solutions.sk5Solutions[solIdx]);
                                solution->p4Idx = idx;
                                solution->stickX = x;
                                solution->stickY = y;
                                solution->f1Angle = f1Angle;
                            }
                        }
                    }
                }
            }
        }
    }
}

__global__ void try_slide_kick_routeG(short* pyramidFloorPoints, const int nPoints) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(counts.nSK3Solutions, limits.MAX_SK_PHASE_THREE)) {
        struct SKPhase3* sol3 = &(solutions.sk3Solutions[idx]);
        struct SKPhase2* sol2 = (sol3->p2Type / 2 == 0) ? ((sol3->p2Type % 2 == 0) ? &(solutions.sk2ASolutions[sol3->p2Idx]) : &(solutions.sk2BSolutions[sol3->p2Idx])) : ((sol3->p2Type % 2 == 0) ? &(solutions.sk2CSolutions[sol3->p2Idx]) : &(solutions.sk2DSolutions[sol3->p2Idx]));
        struct SKPhase1* sol1 = &(solutions.sk1Solutions[sol2->p1Idx]);

        double minF2Dist = INFINITY;
        double maxF2Dist = -INFINITY;

        //const float cameraFocusSpeed = 0.8f;
        const int nDiveFrames = 5;
        const float cameraFocusSpeed = 0.8f - 0.73f * powf(0.95f, nDiveFrames - 1);

        for (int i = 0; i < nPoints; i++) {
            for (int j = 0; j < 4; j++) {
                double PX = 65536.0 * sol1->x1 + pyramidFloorPoints[3 * i];
                double PZ = 65536.0 * sol1->z1 + pyramidFloorPoints[3 * i + 2];
                double QX1 = 65536.0 * sol3->x2 + ((j / 2 == 0) ? tenKFloors[sol2->tenKFloorIdx][0] : tenKFloors[sol2->tenKFloorIdx][1]);
                double QX2 = 65536.0 * sol3->x2 + ((((j + 1) % 4) / 2 == 0) ? tenKFloors[sol2->tenKFloorIdx][0] : tenKFloors[sol2->tenKFloorIdx][1]);
                double QZ1 = 65536.0 * sol3->z2 + ((((j + 1) % 4) / 2 == 0) ? tenKFloors[sol2->tenKFloorIdx][3] : tenKFloors[sol2->tenKFloorIdx][2]);
                double QZ2 = 65536.0 * sol3->z2 + ((j / 2 == 0) ? tenKFloors[sol2->tenKFloorIdx][3] : tenKFloors[sol2->tenKFloorIdx][2]);

                double s = ((QZ1 - PZ) * sinsG(sol2->f2Angle) - (QX1 - PX) * cossG(sol2->f2Angle)) / ((QX2 - QX1) * cossG(sol2->f2Angle) - (QZ2 - QZ1) * sinsG(sol2->f2Angle));

                if (s >= 0.0 && s <= 1.0) {
                    double dist;
                    
                    if (fabs(sinsG(sol2->f2Angle)) > fabs(cossG(sol2->f2Angle))) {
                        dist = (s * (QX2 - QX1) - (PX - QX1)) / sinsG(sol2->f2Angle);
                    }
                    else {
                        dist = (s * (QZ2 - QZ1) - (PZ - QZ1)) / cossG(sol2->f2Angle);
                    }

                    minF2Dist = fmin(minF2Dist, dist);
                    maxF2Dist = fmax(maxF2Dist, dist);
                }
            }
        }

        for (int i = 0; i < nPoints; i++) {
            for (int j = 0; j < 4; j++) {
                double PX = 65536.0 * sol3->x2 + ((j / 2 == 0) ? tenKFloors[sol2->tenKFloorIdx][0] : tenKFloors[sol2->tenKFloorIdx][1]);
                double PZ = 65536.0 * sol3->z2 + ((((j + 1) % 4) / 2 == 0) ? tenKFloors[sol2->tenKFloorIdx][0] : tenKFloors[sol2->tenKFloorIdx][1]);
                double QX1 = 65536.0 * sol1->x1 + pyramidFloorPoints[3 * i];
                double QX2 = 65536.0 * sol1->x1 + pyramidFloorPoints[3 * ((i + 1)%nPoints)];
                double QZ1 = 65536.0 * sol1->z1 + pyramidFloorPoints[3 * i + 2];
                double QZ2 = 65536.0 * sol1->z1 + pyramidFloorPoints[3 * ((i + 1) % nPoints) + 2];

                double s = ((QZ1 - PZ) * sinsG(sol2->f2Angle) - (QX1 - PX) * cossG(sol2->f2Angle)) / ((QX2 - QX1) * cossG(sol2->f2Angle) - (QZ2 - QZ1) * sinsG(sol2->f2Angle));

                if (s >= 0.0 && s <= 1.0) {
                    double dist;

                    if (fabs(sinsG(sol2->f2Angle)) > fabs(cossG(sol2->f2Angle))) {
                        dist = -(s * (QX2 - QX1) - (PX - QX1)) / sinsG(sol2->f2Angle);
                    }
                    else {
                        dist = -(s * (QZ2 - QZ1) - (PZ - QZ1)) / cossG(sol2->f2Angle);
                    }

                    minF2Dist = fmin(minF2Dist, dist);
                    maxF2Dist = fmax(maxF2Dist, dist);
                }
            }
        }

        double minSpeed = fmaxf(sol1->minSpeed - 2.85f, 4.0 * minF2Dist / (float)sol1->q2);
        double maxSpeed = fminf(sol1->maxSpeed + 0.15f, 4.0 * maxF2Dist / (float)sol1->q2);

        if (minSpeed <= maxSpeed) {
            double minF3Dist = INFINITY;
            double maxF3Dist = -INFINITY;

            double minAngleDiff = INFINITY;
            double maxAngleDiff = -INFINITY;

            for (int i = 0; i < nPoints; i++) {
                for (int j = 0; j < 4; j++) {
                    double xDist;
                    double zDist;

                    if (j % 2 == 0) {
                        xDist = (65536.0 * sol3->x2 + tenKFloors[sol2->tenKFloorIdx][0]) - pyramidFloorPoints[3 * i];
                    }
                    else {
                        xDist = (65536.0 * sol3->x2 + tenKFloors[sol2->tenKFloorIdx][1]) - pyramidFloorPoints[3 * i];
                    }

                    if (j / 2 == 0) {
                        zDist = (65536.0 * sol3->z2 + tenKFloors[sol2->tenKFloorIdx][2]) - pyramidFloorPoints[3 * i + 2];
                    }
                    else {
                        zDist = (65536.0 * sol3->z2 + tenKFloors[sol2->tenKFloorIdx][3]) - pyramidFloorPoints[3 * i + 2];
                    }

                    double dist = sqrt(xDist * xDist + zDist * zDist);

                    minF3Dist = fmin(minF3Dist, dist);
                    maxF3Dist = fmax(maxF3Dist, dist);

                    double f3Angle = 65536.0 * atan2(xDist, zDist) / (2.0 * M_PI);

                    double angleDiff = fmod(65536.0 + f3Angle - sol2->f2Angle, 65536.0);
                    angleDiff = fmod(angleDiff + 32768.0, 65536.0) - 32768.0;

                    minAngleDiff = fmin(minAngleDiff, angleDiff);
                    maxAngleDiff = fmax(maxAngleDiff, angleDiff);
                }
            }

            minAngleDiff = fmax(minAngleDiff, -(double)maxF3Turn);
            maxAngleDiff = fmin(maxAngleDiff, (double)maxF3Turn);

            if (minAngleDiff <= maxAngleDiff) {
                double minF3Angle = minAngleDiff + sol2->f2Angle;
                double maxF3Angle = maxAngleDiff + sol2->f2Angle;

                double minN;
                double maxN;

                if (sol2->f2Angle == 0 || sol2->f2Angle == 32768) {
                    double sinF2Angle = sin(2.0 * M_PI * (double)sol2->f2Angle / 65536.0);

                    minN = -cos(2.0 * M_PI * minF3Angle / 65536.0) / sinF2Angle;
                    maxN = -cos(2.0 * M_PI * maxF3Angle / 65536.0) / sinF2Angle;
                }
                else {
                    double sinF2Angle = sinsG(sol2->f2Angle);
                    double cosF2Angle = cossG(sol2->f2Angle);

                    double sinMinF3Angle = sin(2.0 * M_PI * minF3Angle / 65536.0);
                    double cosMinF3Angle = cos(2.0 * M_PI * minF3Angle / 65536.0);

                    double sinMaxF3Angle = sin(2.0 * M_PI * maxF3Angle / 65536.0);
                    double cosMaxF3Angle = cos(2.0 * M_PI * maxF3Angle / 65536.0);

                    double t = sinF2Angle / cosF2Angle;
                    double s = sinMinF3Angle / cosMinF3Angle;

                    bool signTest = (cosF2Angle > 0 && cosMinF3Angle > 0) || (cosF2Angle < 0 && cosMinF3Angle < 0);

                    if (signTest) {
                        minN = (-((double)s * (double)t) - 1.0 + sqrt(((double)s * (double)t - 1.0) * ((double)s * (double)t - 1.0) + 4.0 * (double)s * (double)s)) / (2.0 * (double)s);
                    }
                    else {
                        minN = (-((double)s * (double)t) - 1.0 - sqrt(((double)s * (double)t - 1.0) * ((double)s * (double)t - 1.0) + 4.0 * (double)s * (double)s)) / (2.0 * (double)s);
                    }

                    s = sinMaxF3Angle / cosMaxF3Angle;

                    signTest = (cosF2Angle > 0 && cosMaxF3Angle > 0) || (cosF2Angle < 0 && cosMaxF3Angle < 0);

                    if (signTest) {
                        maxN = (-((double)s * (double)t) - 1.0 + sqrt(((double)s * (double)t - 1.0) * ((double)s * (double)t - 1.0) + 4.0 * (double)s * (double)s)) / (2.0 * (double)s);
                    }
                    else {
                        maxN = (-((double)s * (double)t) - 1.0 - sqrt(((double)s * (double)t - 1.0) * ((double)s * (double)t - 1.0) + 4.0 * (double)s * (double)s)) / (2.0 * (double)s);
                    }
                }

                double minN1 = 32.0 * minN / 0.05;
                double maxN1 = 32.0 * maxN / 0.05;

                if (minN1 > maxN1) {
                    double temp = minN1;
                    minN1 = maxN1;
                    maxN1 = temp;
                }

                minN1 = fmax(minN1, -32.0);
                maxN1 = fmin(maxN1, 32.0);

                if (minN1 <= maxN1) {
                    float minPost10KSpeed = -4.0 * minF3Dist / tenKFloors[sol2->tenKFloorIdx][7];
                    float maxPost10KSpeed = -4.0 * maxF3Dist / tenKFloors[sol2->tenKFloorIdx][7];

                    double minM = (double)minPost10KSpeed / (double)maxSpeed;
                    double maxM = (double)maxPost10KSpeed / (double)minSpeed;

                    double minM1 = 32.0 * ((minM - 0.92) / 0.02) / (double)(0.5f + (0.5f * maxSpeed / 100.0f));
                    double maxM1 = 32.0 * ((maxM - 0.92) / 0.02) / (double)(0.5f + (0.5f * minSpeed / 100.0f));

                    if (minM1 > maxM1) {
                        double temp = minM1;
                        minM1 = maxM1;
                        maxM1 = temp;
                    }

                    minM1 = fmax(minM1, -32.0);
                    maxM1 = fmin(maxM1, 0.0);

                    if (minM1 <= maxM1) {
                        float cameraFocus[3] = { 0.0f, 0.0f, 0.0f };

                        for (int i = 0; i < nPoints; i++) {
                            cameraFocus[0] += pyramidFloorPoints[3 * i];
                            cameraFocus[1] += pyramidFloorPoints[3 * i + 1];
                            cameraFocus[2] += pyramidFloorPoints[3 * i + 2];
                        }

                        cameraFocus[0] /= nPoints;
                        cameraFocus[1] /= nPoints;
                        cameraFocus[2] /= nPoints;

                        cameraFocus[0] += cameraFocusSpeed * 65536.0 * sol1->x1;
                        cameraFocus[2] += cameraFocusSpeed * 65536.0 * sol1->z1;

                        float distToCamera = sqrtf(cameraFocus[0] * cameraFocus[0] + cameraFocus[2] * cameraFocus[2] - 1073741824.0f);
                        float cameraPosition1[3];
                        cameraPosition1[0] = 32768.0f * (32768.0f * cameraFocus[0] + distToCamera * cameraFocus[2]) / (distToCamera * distToCamera + 1073741824.0f);
                        cameraPosition1[1] = -2918.0f;
                        cameraPosition1[2] = 32768.0f * (32768.0f * cameraFocus[2] - distToCamera * cameraFocus[0]) / (distToCamera * distToCamera + 1073741824.0f);

                        float cameraPosition2[3];
                        cameraPosition2[0] = 32768.0f * (32768.0f * cameraFocus[0] - distToCamera * cameraFocus[2]) / (distToCamera * distToCamera + 1073741824.0f);
                        cameraPosition2[1] = -2918.0f;
                        cameraPosition2[2] = 32768.0f * (distToCamera * cameraFocus[0] + 32768.0f * cameraFocus[2]) / (distToCamera * distToCamera + 1073741824.0f);

                        int minCameraYaw = calculate_camera_yaw(cameraFocus, cameraPosition1, sol2->f2Angle);
                        int maxCameraYaw = calculate_camera_yaw(cameraFocus, cameraPosition2, sol2->f2Angle);

                        if ((short)(maxCameraYaw - minCameraYaw) < 0) {
                            int temp = minCameraYaw;
                            minCameraYaw = maxCameraYaw;
                            maxCameraYaw = temp;
                        }

                        int minCameraIdx = revAtansG(minCameraYaw);
                        int maxCameraIdx = revAtansG(maxCameraYaw);

                        if (minCameraIdx > maxCameraIdx) {
                            maxCameraIdx += 8192;
                        }

                        for (int cIdx = minCameraIdx; cIdx <= maxCameraIdx; cIdx++) {
                            int cameraYaw = (unsigned short)gArctanTableG[(8192 + cIdx) % 8192];

                            if (validCameraAngle[cameraYaw]) {
                                int solIdx = atomicAdd(&(counts.nSK4Solutions), 1);

                                if (solIdx < limits.MAX_SK_PHASE_FOUR) {
                                    struct SKPhase4* solution = &(solutions.sk4Solutions[solIdx]);
                                    solution->p3Idx = idx;
                                    solution->cameraYaw = cameraYaw;
                                    solution->minM1 = minM1;
                                    solution->maxM1 = maxM1;
                                    solution->minN1 = minN1;
                                    solution->maxN1 = maxN1;
                                    solution->minPre10KSpeed = minSpeed;
                                    solution->maxPre10KSpeed = maxSpeed;
                                    solution->minPost10KSpeed = minPost10KSpeed;
                                    solution->maxPost10KSpeed = maxPost10KSpeed;
                                    solution->minAngleDiff = minAngleDiff;
                                    solution->maxAngleDiff = maxAngleDiff;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

__global__ void find_slide_kick_setupG3a(float platformMinZ, float platformMaxZ) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(counts.nSK2ASolutions, limits.MAX_SK_PHASE_TWO_A)) {
        struct SKPhase2* sol2 = &(solutions.sk2CSolutions[idx]);
        struct SKPhase1* sol1 = &(solutions.sk1Solutions[sol2->p1Idx]);

        int cosSign = sign(sol2->cosAngle);

        double speed1 = ((cosSign + 1) >> 1) * (sol1->minSpeed - 2.85f) + (((cosSign + 1) >> 1) ^ 1) * (sol1->maxSpeed + 0.15f);
        double speed2 = ((cosSign + 1) >> 1) * (sol1->maxSpeed + 0.15f) + (((cosSign + 1) >> 1) ^ 1) * (sol1->minSpeed - 2.85f);

        int minF2ZPU = (int)ceil((65536.0 * sol1->z1 + platformMinZ + speed1 * (double)sol1->q2 / 4.0 - tenKFloors[sol2->tenKFloorIdx][3]) / 65536.0);
        int maxF2ZPU = (int)floor((65536.0 * sol1->z1 + platformMaxZ + speed2 * (double)sol1->q2 / 4.0 - tenKFloors[sol2->tenKFloorIdx][2]) / 65536.0);

        minF2ZPU += (sol1->q2 + ((sol1->z1 - minF2ZPU) % sol1->q2)) % sol1->q2;
        maxF2ZPU -= (sol1->q2 + ((minF2ZPU - sol1->z1) % sol1->q2)) % sol1->q2;

        for (int z2 = minF2ZPU; z2 <= maxF2ZPU; z2 += sol1->q2) {
            int solIdx = atomicAdd(&(counts.nSK3Solutions), 1);

            if (solIdx < limits.MAX_SK_PHASE_THREE) {
                struct SKPhase3* solution = &(solutions.sk3Solutions[solIdx]);
                solution->p2Idx = idx;
                solution->p2Type = 0;
                solution->x2 = sol1->x1;
                solution->z2 = z2;
            }
        }
    }
}


__global__ void find_slide_kick_setupG3b(float platformMinX, float platformMaxX) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(counts.nSK2BSolutions, limits.MAX_SK_PHASE_TWO_B)) {
        struct SKPhase2* sol2 = &(solutions.sk2CSolutions[idx]);
        struct SKPhase1* sol1 = &(solutions.sk1Solutions[sol2->p1Idx]);

        int sinSign = sign(sol2->sinAngle);

        double speed1 = ((sinSign + 1) >> 1) * (sol1->minSpeed - 2.85f) + (((sinSign + 1) >> 1) ^ 1) * (sol1->maxSpeed + 0.15f);
        double speed2 = ((sinSign + 1) >> 1) * (sol1->maxSpeed + 0.15f) + (((sinSign + 1) >> 1) ^ 1) * (sol1->minSpeed - 2.85f);

        int minF2XPU = (int)ceil((65536.0 * sol1->x1 + platformMinX + speed1 * (double)sol1->q2 / 4.0 - tenKFloors[sol2->tenKFloorIdx][1]) / 65536.0);
        int maxF2XPU = (int)floor((65536.0 * sol1->x1 + platformMaxX + speed2 * (double)sol1->q2 / 4.0 - tenKFloors[sol2->tenKFloorIdx][0]) / 65536.0);

        minF2XPU += (sol1->q2 + ((sol1->x1 - minF2XPU) % sol1->q2)) % sol1->q2;
        maxF2XPU -= (sol1->q2 + ((minF2XPU - sol1->x1) % sol1->q2)) % sol1->q2;

        for (int x2 = minF2XPU; x2 <= maxF2XPU; x2 += sol1->q2) {
            int solIdx = atomicAdd(&(counts.nSK3Solutions), 1);

            if (solIdx < limits.MAX_SK_PHASE_THREE) {
                struct SKPhase3* solution = &(solutions.sk3Solutions[solIdx]);
                solution->p2Idx = idx;
                solution->p2Type = 1;
                solution->x2 = x2;
                solution->z2 = sol1->z1;
            }
        }
    }
}

__global__ void find_slide_kick_setupG3c(float platformMinX, float platformMaxX, float platformMinZ, float platformMaxZ) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(counts.nSK2CSolutions, limits.MAX_SK_PHASE_TWO_C)) {
        struct SKPhase2* sol2 = &(solutions.sk2CSolutions[idx]);
        struct SKPhase1* sol1 = &(solutions.sk1Solutions[sol2->p1Idx]);

        double cotAngle = sol2->cosAngle / sol2->sinAngle;

        int sinSign = sign(sol2->sinAngle);
        int cosSign = sign(sol2->cosAngle);
        int cotSign = sign(cotAngle);

        double speed1 = ((sinSign + 1) >> 1) * (sol1->minSpeed - 2.85f) + (((sinSign + 1) >> 1) ^ 1) * (sol1->maxSpeed + 0.15f);
        double speed2 = ((sinSign + 1) >> 1) * (sol1->maxSpeed + 0.15f) + (((sinSign + 1) >> 1) ^ 1) * (sol1->minSpeed - 2.85f);

        int minF2XPU = (int)ceil((65536.0 * sol1->x1 + platformMinX + speed1 * sol2->sinAngle * (double)sol1->q2 / 4.0 - tenKFloors[sol2->tenKFloorIdx][1]) / 65536.0);
        int maxF2XPU = (int)floor((65536.0 * sol1->x1 + platformMaxX + speed2 * sol2->sinAngle * (double)sol1->q2 / 4.0 - tenKFloors[sol2->tenKFloorIdx][0]) / 65536.0);

        minF2XPU += (sol1->q2 + ((sol1->x1 - minF2XPU) % sol1->q2)) % sol1->q2;
        maxF2XPU -= (sol1->q2 + ((minF2XPU - sol1->x1) % sol1->q2)) % sol1->q2;

        speed1 = ((cosSign + 1) >> 1) * (sol1->minSpeed - 2.85f) + (((cosSign + 1) >> 1) ^ 1) * (sol1->maxSpeed + 0.15f);
        speed2 = ((cosSign + 1) >> 1) * (sol1->maxSpeed + 0.15f) + (((cosSign + 1) >> 1) ^ 1) * (sol1->minSpeed - 2.85f);

        int minF2ZPU = (int)ceil((65536.0 * sol1->z1 + platformMinZ + speed1 * sol2->cosAngle * (double)sol1->q2 / 4.0 - tenKFloors[sol2->tenKFloorIdx][3]) / 65536.0);
        int maxF2ZPU = (int)floor((65536.0 * sol1->z1 + platformMaxZ + speed2 * sol2->cosAngle * (double)sol1->q2 / 4.0 - tenKFloors[sol2->tenKFloorIdx][2]) / 65536.0);

        minF2ZPU += (sol1->q2 + ((sol1->z1 - minF2ZPU) % sol1->q2)) % sol1->q2;
        maxF2ZPU -= (sol1->q2 + ((minF2ZPU - sol1->z1) % sol1->q2)) % sol1->q2;

        int floorPointIdx = 1 - ((cotSign + 1) >> 1);
        float tenKFloorX1 = tenKFloors[sol2->tenKFloorIdx][floorPointIdx];
        float tenKFloorX2 = tenKFloors[sol2->tenKFloorIdx][1 - floorPointIdx];
        float platformX1 = ((cotSign + 1) >> 1) * platformMaxX + (((cotSign + 1) >> 1) ^ 1) * platformMinX;
        float platformX2 = ((cotSign + 1) >> 1) * platformMinX + (((cotSign + 1) >> 1) ^ 1) * platformMaxX;
        float zRange1 = ((cotSign + 1) >> 1) * sol2->lower + (((cotSign + 1) >> 1) ^ 1) * sol2->upper;
        float zRange2 = ((cotSign + 1) >> 1) * sol2->upper + (((cotSign + 1) >> 1) ^ 1) * sol2->lower;

        for (int x2 = minF2XPU; x2 <= maxF2XPU; x2 += sol1->q2) {
            int minF2XZPU = (int)ceil((65536.0 * sol1->z1 + platformMinZ + ((65536.0 * x2 + tenKFloorX1) - (65536.0 * sol1->x1 + platformX1)) * cotAngle + zRange1 - tenKFloors[sol2->tenKFloorIdx][3]) / 65536.0);
            int maxF2XZPU = (int)floor((65536.0 * sol1->z1 + platformMaxZ + ((65536.0 * x2 + tenKFloorX2) - (65536.0 * sol1->x1 + platformX2)) * cotAngle + zRange2 - tenKFloors[sol2->tenKFloorIdx][2]) / 65536.0);

            minF2XZPU += (sol1->q2 + ((sol1->z1 - minF2XZPU) % sol1->q2)) % sol1->q2;
            maxF2XZPU -= (sol1->q2 + ((maxF2XZPU - sol1->z1) % sol1->q2)) % sol1->q2;

            minF2XZPU = max(minF2XZPU, minF2ZPU);
            maxF2XZPU = min(maxF2XZPU, maxF2ZPU);

            for (int z2 = minF2ZPU; z2 <= maxF2ZPU; z2 += sol1->q2) {
                int solIdx = atomicAdd(&(counts.nSK3Solutions), 1);

                if (solIdx < limits.MAX_SK_PHASE_THREE) {
                    struct SKPhase3* solution = &(solutions.sk3Solutions[solIdx]);
                    solution->p2Idx = idx;
                    solution->p2Type = 2;
                    solution->x2 = x2;
                    solution->z2 = z2;
                }
            }
        }
    }
}

__global__ void find_slide_kick_setupG3d(float platformMinX, float platformMaxX, float platformMinZ, float platformMaxZ) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(counts.nSK2DSolutions, limits.MAX_SK_PHASE_TWO_D)) {
        struct SKPhase2* sol2 = &(solutions.sk2DSolutions[idx]);
        struct SKPhase1* sol1 = &(solutions.sk1Solutions[sol2->p1Idx]);

        double tanAngle = sol2->sinAngle / sol2->cosAngle;

        int sinSign = sign(sol2->sinAngle);
        int cosSign = sign(sol2->cosAngle);
        int tanSign = sign(tanAngle);

        double speed1 = ((sinSign + 1) >> 1) * (sol1->minSpeed - 2.85f) + (((sinSign + 1) >> 1) ^ 1) * (sol1->maxSpeed + 0.15f);
        double speed2 = ((sinSign + 1) >> 1) * (sol1->maxSpeed + 0.15f) + (((sinSign + 1) >> 1) ^ 1) * (sol1->minSpeed - 2.85f);

        int minF2XPU = (int)ceil((65536.0 * sol1->x1 + platformMinX + speed1 * sol2->sinAngle * (double)sol1->q2 / 4.0 - tenKFloors[sol2->tenKFloorIdx][1]) / 65536.0);
        int maxF2XPU = (int)floor((65536.0 * sol1->x1 + platformMaxX + speed2 * sol2->sinAngle * (double)sol1->q2 / 4.0 - tenKFloors[sol2->tenKFloorIdx][0]) / 65536.0);

        minF2XPU += (sol1->q2 + ((sol1->x1 - minF2XPU) % sol1->q2)) % sol1->q2;
        maxF2XPU -= (sol1->q2 + ((minF2XPU - sol1->x1) % sol1->q2)) % sol1->q2;

        speed1 = ((cosSign + 1) >> 1) * (sol1->minSpeed - 2.85f) + (((cosSign + 1) >> 1) ^ 1) * (sol1->maxSpeed + 0.15f);
        speed2 = ((cosSign + 1) >> 1) * (sol1->maxSpeed + 0.15f) + (((cosSign + 1) >> 1) ^ 1) * (sol1->minSpeed - 2.85f);

        int minF2ZPU = (int)ceil((65536.0 * sol1->z1 + platformMinZ + speed1 * sol2->cosAngle * (double)sol1->q2 / 4.0 - tenKFloors[sol2->tenKFloorIdx][3]) / 65536.0);
        int maxF2ZPU = (int)floor((65536.0 * sol1->z1 + platformMaxZ + speed2 * sol2->cosAngle * (double)sol1->q2 / 4.0 - tenKFloors[sol2->tenKFloorIdx][2]) / 65536.0);

        minF2ZPU += (sol1->q2 + ((sol1->z1 - minF2ZPU) % sol1->q2)) % sol1->q2;
        maxF2ZPU -= (sol1->q2 + ((minF2ZPU - sol1->z1) % sol1->q2)) % sol1->q2;

        int floorPointIdx = 3 - ((tanSign + 1) >> 1);
        float tenKFloorZ1 = tenKFloors[sol2->tenKFloorIdx][floorPointIdx];
        float tenKFloorZ2 = tenKFloors[sol2->tenKFloorIdx][5 - floorPointIdx];
        float platformZ1 = ((tanSign + 1) >> 1) * platformMaxZ + (((tanSign + 1) >> 1) ^ 1) * platformMinZ;
        float platformZ2 = ((tanSign + 1) >> 1) * platformMinZ + (((tanSign + 1) >> 1) ^ 1) * platformMaxZ;
        float xRange1 = ((tanSign + 1) >> 1) * sol2->lower + (((tanSign + 1) >> 1) ^ 1) * sol2->upper;
        float xRange2 = ((tanSign + 1) >> 1) * sol2->upper + (((tanSign + 1) >> 1) ^ 1) * sol2->lower;

        for (int z2 = minF2ZPU; z2 <= maxF2ZPU; z2 += sol1->q2) {
            int minF2ZXPU = (int)ceil((65536.0 * sol1->x1 + platformMinX + ((65536.0 * z2 + tenKFloorZ1) - (65536.0 * sol1->z1 + platformZ1)) * tanAngle + xRange1 - tenKFloors[sol2->tenKFloorIdx][1]) / 65536.0);
            int maxF2ZXPU = (int)floor((65536.0 * sol1->x1 + platformMaxX + ((65536.0 * z2 + tenKFloorZ2) - (65536.0 * sol1->z1 + platformZ2)) * tanAngle + xRange2 - tenKFloors[sol2->tenKFloorIdx][0]) / 65536.0);

            minF2ZXPU += (sol1->q2 + ((sol1->x1 - minF2ZXPU) % sol1->q2)) % sol1->q2;
            maxF2ZXPU -= (sol1->q2 + ((maxF2ZXPU - sol1->x1) % sol1->q2)) % sol1->q2;

            minF2ZXPU = max(minF2ZXPU, minF2XPU);
            maxF2ZXPU = min(maxF2ZXPU, maxF2XPU);

            for (int x2 = minF2ZXPU; x2 <= maxF2ZXPU; x2 += sol1->q2) {
                int solIdx = atomicAdd(&(counts.nSK3Solutions), 1);

                if (solIdx < limits.MAX_SK_PHASE_THREE) {
                    struct SKPhase3* solution = &(solutions.sk3Solutions[solIdx]);
                    solution->p2Idx = idx;
                    solution->p2Type = 3;
                    solution->x2 = x2;
                    solution->z2 = z2;
                }
            }
        }
    }
}

__global__ void find_slide_kick_setupG2(short* floorPoints, const int nPoints, float floorNormalY, float platformMinX, float platformMaxX, float platformMinZ, float platformMaxZ, float midPointX, float midPointZ) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(counts.nSK1Solutions, limits.MAX_SK_PHASE_ONE)) {
        struct SKPhase1 *sol = &(solutions.sk1Solutions[idx]);
        double puAngle = 65536.0 * atan2((double)sol->x1, (double)sol->z1) / (2.0 * M_PI);
        puAngle = fmod(65536.0 + puAngle, 65536.0);
        
        int puAngleClosest = atan2sG(sol->z1, sol->x1);

        double sinMaxAngle = sin(2.0 * M_PI * (double)maxF3Turn / 65536.0);
        double maxF2AngleChange = fmod(32768.0 - (65536.0 * asin(sol->q2 * sinMaxAngle / (4.0 * floorNormalY)) / (2.0 * M_PI)) - maxF3Turn, 32768.0);
        maxF2AngleChange = fabs(fmod(maxF2AngleChange + 16384.0, 32768.0) - 16384.0);

        int minF2AngleIdx = revAtansG(puAngleClosest);
        int maxF2AngleIdx = revAtansG(puAngleClosest);

        while ((unsigned short)(puAngleClosest - ((gArctanTableG[(minF2AngleIdx + 8191) % 8192] >> 4) << 4)) < maxF2AngleChange) {
            minF2AngleIdx = minF2AngleIdx - 1;
        }

        while ((unsigned short)(((gArctanTableG[(maxF2AngleIdx + 1) % 8192] >> 4) << 4) - puAngleClosest) < maxF2AngleChange) {
            maxF2AngleIdx = maxF2AngleIdx + 1;
        }

        for (int a = minF2AngleIdx; a <= maxF2AngleIdx; a++) {
            int f2Angle = (unsigned short)gArctanTableG[(8192 + a) % 8192];

            if (f2Angle == 0 || f2Angle == 32768) {
                for (int i = 0; i < nTenKFloors; i++) {
                    float minX = fmaxf(platformMinX, tenKFloors[i][0]);
                    float maxX = fminf(platformMaxX, tenKFloors[i][1]);

                    if (minX < maxX) {
                        int solIdx = atomicAdd(&(counts.nSK2ASolutions), 1);

                        if (solIdx < limits.MAX_SK_PHASE_TWO_A) {
                            struct SKPhase2* solution = &(solutions.sk2ASolutions[solIdx]);
                            solution->p1Idx = idx;
                            solution->f2Angle = 0;
                            solution->tenKFloorIdx = i;
                            solution->sinAngle = 0.0;
                            solution->cosAngle = 1.0;
                        }

                        solIdx = atomicAdd(&(counts.nSK2ASolutions), 1);

                        if (solIdx < limits.MAX_SK_PHASE_TWO_A) {
                            struct SKPhase2* solution = &(solutions.sk2ASolutions[solIdx]);
                            solution->p1Idx = idx;
                            solution->f2Angle = 32768;
                            solution->tenKFloorIdx = i;
                            solution->sinAngle = 0.0;
                            solution->cosAngle = -1.0;
                        }
                    }
                }
            }
            else if (f2Angle == 16384 || f2Angle == 49152) {
                for (int i = 0; i < nTenKFloors; i++) {
                    float minZ = fmaxf(platformMinZ, tenKFloors[i][2]);
                    float maxZ = fminf(platformMaxZ, tenKFloors[i][3]);

                    if (minZ < maxZ) {
                        int solIdx = atomicAdd(&(counts.nSK2BSolutions), 1);

                        if (solIdx < limits.MAX_SK_PHASE_TWO_B) {
                            struct SKPhase2* solution = &(solutions.sk2BSolutions[solIdx]);
                            solution->p1Idx = idx;
                            solution->f2Angle = 16384;
                            solution->tenKFloorIdx = i;
                            solution->sinAngle = 1.0;
                            solution->cosAngle = 0.0;
                        }

                        solIdx = atomicAdd(&(counts.nSK2BSolutions), 1);

                        if (solIdx < limits.MAX_SK_PHASE_TWO_B) {
                            struct SKPhase2* solution = &(solutions.sk2BSolutions[solIdx]);
                            solution->p1Idx = idx;
                            solution->f2Angle = 49152;
                            solution->tenKFloorIdx = i;
                            solution->sinAngle = 1.0;
                            solution->cosAngle = 0.0;
                        }
                    }
                }
            }
            else {
                double sinAngle = sinsG(f2Angle);
                double cosAngle = cossG(f2Angle);

                if (fabs(sinAngle) < fabs(cosAngle)) {
                    float lowerZ = INFINITY;
                    float upperZ = -INFINITY;

                    double cotAngle = cosAngle / sinAngle;

                    for (int i = 0; i < nPoints; i++) {
                        float testZ = floorPoints[3 * i + 2] + ((midPointX - floorPoints[3 * i]) * cotAngle) - midPointZ;
                        lowerZ = fminf(lowerZ, testZ);
                        upperZ = fmaxf(upperZ, testZ);
                    }

                    for (int i = 0; i < nTenKFloors; i++) {
                        int solIdx = atomicAdd(&(counts.nSK2CSolutions), 1);

                        if (solIdx < limits.MAX_SK_PHASE_TWO_C) {
                            struct SKPhase2* solution = &(solutions.sk2CSolutions[solIdx]);
                            solution->p1Idx = idx;
                            solution->f2Angle = f2Angle;
                            solution->tenKFloorIdx = i;
                            solution->lower = lowerZ;
                            solution->upper = upperZ;
                            solution->sinAngle = sinAngle;
                            solution->cosAngle = cosAngle;
                        }

                        solIdx = atomicAdd(&(counts.nSK2CSolutions), 1);

                        if (solIdx < limits.MAX_SK_PHASE_TWO_C) {
                            struct SKPhase2* solution = &(solutions.sk2CSolutions[solIdx]);
                            solution->p1Idx = idx;
                            solution->f2Angle = (unsigned short)(f2Angle + 32768);
                            solution->tenKFloorIdx = i;
                            solution->lower = lowerZ;
                            solution->upper = upperZ;
                            solution->sinAngle = -sinAngle;
                            solution->cosAngle = -cosAngle;
                        }
                    }
                }
                else {
                    float lowerX = INFINITY;
                    float upperX = -INFINITY;

                    double tanAngle = sinAngle / cosAngle;

                    for (int i = 0; i < nPoints; i++) {
                        float testX = floorPoints[3 * i] + ((midPointZ - floorPoints[3 * i + 2]) * tanAngle) - midPointX;
                        lowerX = fminf(lowerX, testX);
                        upperX = fmaxf(upperX, testX);
                    }

                    for (int i = 0; i < nTenKFloors; i++) {
                        int solIdx = atomicAdd(&(counts.nSK2DSolutions), 1);

                        if (solIdx < limits.MAX_SK_PHASE_TWO_D) {
                            struct SKPhase2* solution = &(solutions.sk2DSolutions[solIdx]);
                            solution->p1Idx = idx;
                            solution->f2Angle = f2Angle;
                            solution->tenKFloorIdx = i;
                            solution->lower = lowerX;
                            solution->upper = upperX;
                            solution->sinAngle = sinAngle;
                            solution->cosAngle = cosAngle;
                        }

                        solIdx = atomicAdd(&(counts.nSK2DSolutions), 1);

                        if (solIdx < limits.MAX_SK_PHASE_TWO_D) {
                            struct SKPhase2* solution = &(solutions.sk2DSolutions[solIdx]);
                            solution->p1Idx = idx;
                            solution->f2Angle = (unsigned short)(f2Angle + 32768);
                            solution->tenKFloorIdx = i;
                            solution->lower = lowerX;
                            solution->upper = upperX;
                            solution->sinAngle = -sinAngle;
                            solution->cosAngle = -cosAngle;
                        }
                    }
                }
            }
        }
    }
}

__global__ void find_slide_kick_setupG(short* floorPoints, const int nPoints, float floorNormalY, double maxSpeed, int maxF1PU, int t) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    int x1 = 4 * (idx % (2 * (maxF1PU / 4) + 1)) - maxF1PU;
    int z1 = 4 * (idx / (2 * (maxF1PU / 4) + 1)) - maxF1PU;

    if ((x1 != 0 || z1 != 0) && 65536.0 * sqrt((double)(x1 * x1 + z1 * z1)) <= floorNormalY * maxSpeed) {
        float dx = 65536 * x1;
        float dy = 500.0f;
        float dz = 65536 * z1;

        float d = sqrtf(dx * dx + dy * dy + dz * dz);

        d = 1.0 / d;
        dx *= d;
        dy *= d;
        dz *= d;

        float normal_change[3];
        normal_change[0] = (platformNormal[0] <= dx) ? ((dx - platformNormal[0] < 0.01f) ? dx - platformNormal[0] : 0.01f) : ((dx - platformNormal[0] > -0.01f) ? dx - platformNormal[0] : -0.01f);
        normal_change[1] = (platformNormal[1] <= dy) ? ((dy - platformNormal[1] < 0.01f) ? dy - platformNormal[1] : 0.01f) : ((dy - platformNormal[1] > -0.01f) ? dy - platformNormal[1] : -0.01f);
        normal_change[2] = (platformNormal[2] <= dz) ? ((dz - platformNormal[2] < 0.01f) ? dz - platformNormal[2] : 0.01f) : ((dz - platformNormal[2] > -0.01f) ? dz - platformNormal[2] : -0.01f);

        if (normal_change[0] == normal_offsets[t][0] && normal_change[1] == normal_offsets[t][1] && normal_change[2] == normal_offsets[t][2]) {
            double qStepMul = (nPoints == 4) ? 1.0 : (4.0 / 3.0);

            double maxF1Dist = -INFINITY;
            double minF1Dist = INFINITY;

            int refAngle = 0;

            int maxF1Angle = -65536;
            int minF1Angle = 65536;

            for (int i = 0; i < nPoints; i++) {
                for (int j = 0; j < nPoints; j++) {
                    double xDist = (65536.0 * x1 + (floorPoints[3 * i] - floorPoints[3 * j]) * qStepMul);
                    double zDist = (65536.0 * z1 + (floorPoints[3 * i + 2] - floorPoints[3 * j + 2]) * qStepMul);

                    double dist = sqrt(xDist * xDist + zDist * zDist);

                    minF1Dist = fmin(minF1Dist, dist);
                    maxF1Dist = fmax(maxF1Dist, dist);

                    int angle = atan2sG(zDist, xDist);

                    if (i == 0 && j == 0) {
                        refAngle = angle;
                    }

                    angle = (short)(angle - refAngle);

                    minF1Angle = min(minF1Angle, angle);
                    maxF1Angle = max(maxF1Angle, angle);

                }
            }

            double minSpeedF1 = minF1Dist / floorNormalY;
            double maxSpeedF1 = fmin(maxSpeed, maxF1Dist / floorNormalY);

            if (minSpeedF1 < maxSpeedF1) {
                minF1Angle = minF1Angle + refAngle;
                maxF1Angle = maxF1Angle + refAngle;

                int minF1AngleIdx = revAtansG(minF1Angle);
                int maxF1AngleIdx = revAtansG(maxF1Angle);

                if (maxF1AngleIdx < minF1AngleIdx) {
                    maxF1AngleIdx = maxF1AngleIdx + 8192;
                }

                for (int q2 = 1; q2 <= 4; q2++) {
                    int solIdx = atomicAdd(&(counts.nSK1Solutions), 1);

                    if (solIdx < limits.MAX_SK_PHASE_ONE) {
                        struct SKPhase1* solution = &(solutions.sk1Solutions[solIdx]);
                        solution->x1 = x1;
                        solution->z1 = z1;
                        solution->q2 = q2;
                        solution->minSpeed = minSpeedF1;
                        solution->maxSpeed = maxSpeedF1;
                        solution->minF1Dist = minF1Dist;
                        solution->maxF1Dist = maxF1Dist;
                        solution->minF1AngleIdx = minF1AngleIdx;
                        solution->maxF1AngleIdx = maxF1AngleIdx;
                    }
                }
            }
        }
    }
}

void find_slide_kick_setup_triangle(float* startNormal, short* floorPoints, short* devFloorPoints, int nPoints, float yNormal, int t, struct FSTOptions* o, struct SolCounts* countsCPU, std::ofstream& logf, FSTOutput& output) {
    countsCPU->nSK1Solutions = 0;
    countsCPU->nSK2ASolutions = 0;
    countsCPU->nSK2BSolutions = 0;
    countsCPU->nSK2CSolutions = 0;
    countsCPU->nSK2DSolutions = 0;
    countsCPU->nSK3Solutions = 0;
    countsCPU->nSK4Solutions = 0;
    countsCPU->nSK5Solutions = 0;
    countsCPU->nSK6Solutions = 0;

    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU->nSK1Solutions), sizeof(int), offsetof(struct SolCounts, nSK1Solutions), hipMemcpyHostToDevice);
    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU->nSK2ASolutions), sizeof(int), offsetof(struct SolCounts, nSK2ASolutions), hipMemcpyHostToDevice);
    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU->nSK2BSolutions), sizeof(int), offsetof(struct SolCounts, nSK2BSolutions), hipMemcpyHostToDevice);
    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU->nSK2CSolutions), sizeof(int), offsetof(struct SolCounts, nSK2CSolutions), hipMemcpyHostToDevice);
    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU->nSK2DSolutions), sizeof(int), offsetof(struct SolCounts, nSK2DSolutions), hipMemcpyHostToDevice);
    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU->nSK3Solutions), sizeof(int), offsetof(struct SolCounts, nSK3Solutions), hipMemcpyHostToDevice);
    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU->nSK4Solutions), sizeof(int), offsetof(struct SolCounts, nSK4Solutions), hipMemcpyHostToDevice);
    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU->nSK5Solutions), sizeof(int), offsetof(struct SolCounts, nSK5Solutions), hipMemcpyHostToDevice);
    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU->nSK6Solutions), sizeof(int), offsetof(struct SolCounts, nSK6Solutions), hipMemcpyHostToDevice);

    float platformMinX = 32767.0;
    float platformMaxX = -32768.0;
    float platformMinZ = 32767.0;
    float platformMaxZ = -32768.0;

    for (int i = 0; i < nPoints; i++) {
        platformMinX = fminf(platformMinX, (float)floorPoints[3 * i]);
        platformMaxX = fmaxf(platformMaxX, (float)floorPoints[3 * i]);
    }

    for (int i = 0; i < nPoints; i++) {
        platformMinZ = fminf(platformMinZ, (float)floorPoints[3 * i + 2]);
        platformMaxZ = fmaxf(platformMaxZ, (float)floorPoints[3 * i + 2]);
    }

    float midPointX = 0.0f;
    float midPointZ = 0.0f;

    for (int i = 0; i < nPoints; i++) {
        midPointX += floorPoints[3 * i];
        midPointZ += floorPoints[3 * i + 2];
    }

    midPointX /= (float)nPoints;
    midPointZ /= (float)nPoints;

    hipMemcpy(devFloorPoints, floorPoints, 3 * nPoints * sizeof(short), hipMemcpyHostToDevice);

    int maxF1PU = (int)floor(yNormal * o->maxSpeed / (4.0 * 65536.0)) * 4;
    int nBlocks = ((2 * (maxF1PU / 4) + 1) * (2 * (maxF1PU / 4) + 1) + o->nThreads - 1) / o->nThreads;

    find_slide_kick_setupG<<<nBlocks, o->nThreads>>>(devFloorPoints, nPoints, yNormal, o->maxSpeed, maxF1PU, t);
    output.hipError_t = hipGetLastError();
    if (output.hipError_t != 0x0) return;

    hipMemcpyFromSymbol(&(countsCPU->nSK1Solutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nSK1Solutions), hipMemcpyDeviceToHost);

    if (countsCPU->nSK1Solutions > 0) {
        if (countsCPU->nSK1Solutions > o->limits.MAX_SK_PHASE_ONE) {
            output.flags |= SW_FLAG_SLIDE_KICK_1;
            if (!o->silent) fprintf(stderr, "Warning: Number of slide kick phase 1 solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
            countsCPU->nSK1Solutions = o->limits.MAX_SK_PHASE_ONE;
            char logContent[200];
            sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Slide Kick Phase 1 Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
            write_line_to_log_file(LOG_WARNING, logContent, logf);
        }

        nBlocks = (countsCPU->nSK1Solutions + o->nThreads - 1) / o->nThreads;

        find_slide_kick_setupG2<<<nBlocks, o->nThreads>>>(devFloorPoints, nPoints, yNormal, platformMinX, platformMaxX, platformMinZ, platformMaxZ, midPointX, midPointZ);
        output.hipError_t = hipGetLastError();
        if (output.hipError_t != 0x0) return;

        hipMemcpyFromSymbol(&(countsCPU->nSK2ASolutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nSK2ASolutions), hipMemcpyDeviceToHost);
        hipMemcpyFromSymbol(&(countsCPU->nSK2BSolutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nSK2BSolutions), hipMemcpyDeviceToHost);
        hipMemcpyFromSymbol(&(countsCPU->nSK2CSolutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nSK2CSolutions), hipMemcpyDeviceToHost);
        hipMemcpyFromSymbol(&(countsCPU->nSK2DSolutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nSK2DSolutions), hipMemcpyDeviceToHost);
    }

    if (countsCPU->nSK2ASolutions > 0) {
        if (countsCPU->nSK2ASolutions > o->limits.MAX_SK_PHASE_TWO_A) {
            output.flags |= SW_FLAG_SLIDE_KICK_2A;
            if (!o->silent) fprintf(stderr, "Warning: Number of slide kick phase 2a solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
            countsCPU->nSK2ASolutions = o->limits.MAX_SK_PHASE_TWO_A;
            char logContent[200];
            sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Slide Kick Phase 2a Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
            write_line_to_log_file(LOG_WARNING, logContent, logf);
        }

        nBlocks = (countsCPU->nSK2ASolutions + o->nThreads - 1) / o->nThreads;

        find_slide_kick_setupG3a<<<nBlocks, o->nThreads>>>(platformMinZ, platformMaxZ);
        output.hipError_t = hipGetLastError();
        if (output.hipError_t != 0x0) return;
    }

    if (countsCPU->nSK2BSolutions > 0) {
        if (countsCPU->nSK2BSolutions > o->limits.MAX_SK_PHASE_TWO_B) {
            output.flags |= SW_FLAG_SLIDE_KICK_2B;
            if (!o->silent) fprintf(stderr, "Warning: Number of slide kick phase 2b solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
            countsCPU->nSK2BSolutions = o->limits.MAX_SK_PHASE_TWO_B;
            char logContent[200];
            sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Slide Kick Phase 2b Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
            write_line_to_log_file(LOG_WARNING, logContent, logf);
        }

        nBlocks = (countsCPU->nSK2BSolutions + o->nThreads - 1) / o->nThreads;

        find_slide_kick_setupG3b<<<nBlocks, o->nThreads>>>(platformMinX, platformMaxX);
        output.hipError_t = hipGetLastError();
        if (output.hipError_t != 0x0) return;
    }

    if (countsCPU->nSK2CSolutions > 0) {
        if (countsCPU->nSK2CSolutions > o->limits.MAX_SK_PHASE_TWO_C) {
            output.flags |= SW_FLAG_SLIDE_KICK_2C;
            if (!o->silent) fprintf(stderr, "Warning: Number of slide kick phase 2c solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
            countsCPU->nSK2CSolutions = o->limits.MAX_SK_PHASE_TWO_C;
            char logContent[200];
            sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Slide Kick Phase 2c Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
            write_line_to_log_file(LOG_WARNING, logContent, logf);
        }

        nBlocks = (countsCPU->nSK2CSolutions + o->nThreads - 1) / o->nThreads;

        find_slide_kick_setupG3c<<<nBlocks, o->nThreads>>>(platformMinX, platformMaxX, platformMinZ, platformMaxZ);
        output.hipError_t = hipGetLastError();
        if (output.hipError_t != 0x0) return;
    }

    if (countsCPU->nSK2DSolutions > 0) {
        if (countsCPU->nSK2DSolutions > o->limits.MAX_SK_PHASE_TWO_D) {
            output.flags |= SW_FLAG_SLIDE_KICK_2D;
            if (!o->silent) fprintf(stderr, "Warning: Number of slide kick phase 2d solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
            countsCPU->nSK2DSolutions = o->limits.MAX_SK_PHASE_TWO_D;
            char logContent[200];
            sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Slide Kick Phase 2d Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
            write_line_to_log_file(LOG_WARNING, logContent, logf);
        }

        nBlocks = (countsCPU->nSK2DSolutions + o->nThreads - 1) / o->nThreads;

        find_slide_kick_setupG3d<<<nBlocks, o->nThreads>>>(platformMinX, platformMaxX, platformMinZ, platformMaxZ);
        output.hipError_t = hipGetLastError();
        if (output.hipError_t != 0x0) return;
    }

    hipMemcpyFromSymbol(&(countsCPU->nSK3Solutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nSK3Solutions), hipMemcpyDeviceToHost);

    if (countsCPU->nSK3Solutions > 0) {
        if (countsCPU->nSK3Solutions > o->limits.MAX_SK_PHASE_THREE) {
            output.flags |= SW_FLAG_SLIDE_KICK_3;
            if (!o->silent) fprintf(stderr, "Warning: Number of slide kick phase 3 solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
            countsCPU->nSK3Solutions = o->limits.MAX_SK_PHASE_THREE;
            char logContent[200];
            sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Slide Kick Phase 3 Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
            write_line_to_log_file(LOG_WARNING, logContent, logf);
        }

        nBlocks = (countsCPU->nSK3Solutions + o->nThreads - 1) / o->nThreads;

        try_slide_kick_routeG<<<nBlocks, o->nThreads>>>(devFloorPoints, nPoints);
        output.hipError_t = hipGetLastError();
        if (output.hipError_t != 0x0) return;

        hipMemcpyFromSymbol(&(countsCPU->nSK4Solutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nSK4Solutions), hipMemcpyDeviceToHost);

    }

    if (countsCPU->nSK4Solutions > 0) {
        if (countsCPU->nSK4Solutions > o->limits.MAX_SK_PHASE_FOUR) {
            output.flags |= SW_FLAG_SLIDE_KICK_4;
            if (!o->silent) fprintf(stderr, "Warning: Number of slide kick phase 4 solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
            countsCPU->nSK4Solutions = o->limits.MAX_SK_PHASE_FOUR;
            char logContent[200];
            sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Slide Kick Phase 4 Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
            write_line_to_log_file(LOG_WARNING, logContent, logf);
        }

        nBlocks = (countsCPU->nSK4Solutions + o->nThreads - 1) / o->nThreads;

        try_slide_kick_routeG2<<<nBlocks, o->nThreads>>>();
        output.hipError_t = hipGetLastError();
        if (output.hipError_t != 0x0) return;

        hipMemcpyFromSymbol(&(countsCPU->nSK5Solutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nSK5Solutions), hipMemcpyDeviceToHost);
    }

    if (countsCPU->nSK5Solutions > 0) {
        if (countsCPU->nSK5Solutions > o->limits.MAX_SK_PHASE_FIVE) {
            output.flags |= SW_FLAG_SLIDE_KICK_5;
            if (!o->silent) fprintf(stderr, "Warning: Number of slide kick phase 5 solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
            countsCPU->nSK5Solutions = o->limits.MAX_SK_PHASE_FIVE;
            char logContent[200];
            sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Slide Kick Phase 5 Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
            write_line_to_log_file(LOG_WARNING, logContent, logf);
        }

        nBlocks = (countsCPU->nSK5Solutions + o->nThreads - 1) / o->nThreads;

        try_stick_positionG<<<nBlocks, o->nThreads>>>();
        output.hipError_t = hipGetLastError();
        if (output.hipError_t != 0x0) return;
    }
}

__global__ void find_bully_positions(int uphillAngle, float maxSlidingSpeed, float maxSlidingSpeedToPlatform) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    int squishPushFrames = (idx % 3) + 2;
    idx = idx / 3;

    if (idx < min(counts.nDouble10KSolutions, limits.MAX_DOUBLE_10K_SOLUTIONS)) {
        struct DoubleTenKSolution* doubleTenKSol = &(solutions.doubleTenKSolutions[idx]);
        struct TenKSolution* tenKSol = &(solutions.tenKSolutions[doubleTenKSol->tenKSolutionIdx]);

        const float accel = 7.0f;
        const float pushRadius = 115.0f;
        const float bullyHurtbox = 63.0f;
        const float baseBullySpeed = powf(2.0f, 24);
        const float maxBullySpeed = nextafterf(powf(2.0f, 30), -INFINITY);

        int floorIdx = (tenKSol->squishCeiling == 0 || tenKSol->squishCeiling == 2) ? 0 : 1;

        int surfAngle = atan2sG(squishCeilingNormals[tenKSol->squishCeiling][2], squishCeilingNormals[tenKSol->squishCeiling][0]);

        float xPushVel = sinsG(surfAngle) * 10.0f;
        float zPushVel = cossG(surfAngle) * 10.0f;

        int slopeAngle = atan2sG(startNormals[floorIdx][2], startNormals[floorIdx][0]);

        float steepness = sqrtf(startNormals[floorIdx][0] * startNormals[floorIdx][0] + startNormals[floorIdx][2] * startNormals[floorIdx][2]);

        float slopeXVel = accel * steepness * sinsG(slopeAngle);
        float slopeZVel = accel * steepness * cossG(slopeAngle);

        bool onFloor = false;

        float minBullyPushX = doubleTenKSol->minStartX;
        float maxBullyPushX = doubleTenKSol->maxStartX;
        float minBullyPushZ = doubleTenKSol->minStartZ;
        float maxBullyPushZ = doubleTenKSol->maxStartZ;

        for (int i = 0; i < squishPushFrames-1; i++) {
            minBullyPushX = minBullyPushX - squishNormals[floorIdx][1] * xPushVel / 4.0f;
            maxBullyPushX = maxBullyPushX - squishNormals[floorIdx][1] * xPushVel / 4.0f;
            minBullyPushZ = minBullyPushZ - squishNormals[floorIdx][1] * zPushVel / 4.0f;
            maxBullyPushZ = maxBullyPushZ - squishNormals[floorIdx][1] * zPushVel / 4.0f;

            if (i == 0) {
                float bpPos[3] = { 0.0f, 0.0f, 0.0f };

                for (int j = 0; j < 4; j++) {
                    bpPos[0] = (j % 2 == 0) ? minBullyPushX : maxBullyPushX;
                    bpPos[2] = (j / 2 == 0) ? minBullyPushZ : maxBullyPushZ;

                    float fHeight;
                    int fIdx1 = find_floor(bpPos, squishTriangles, squishNormals, &fHeight);

                    if (fIdx1 != -1) {
                        onFloor = true;
                    }
                }
            }
        }

        minBullyPushX = minBullyPushX - xPushVel / 4.0f;
        maxBullyPushX = maxBullyPushX - xPushVel / 4.0f;
        minBullyPushZ = minBullyPushZ - zPushVel / 4.0f;
        maxBullyPushZ = maxBullyPushZ - zPushVel / 4.0f;

        if (onFloor) {
            int minAngle = INT_MAX;
            int maxAngle = INT_MIN;
            int refAngle = 65536;

            for (int j = 0; j < 4; j++) {
                float bullyPushX = (j % 2 == 0) ? minBullyPushX : maxBullyPushX;
                float bullyPushZ = (j / 2 == 0) ? minBullyPushZ : maxBullyPushZ;

                for (int k = 0; k < nSquishSpots[tenKSol->squishCeiling]; k++) {
                    float signX = sign(squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k)]);
                    float signZ = sign(squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k) + 1]);

                    for (int l = 0; l < 4; l++) {
                        float xDist = bullyPushX - (squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k)] + signX * (l % 2));
                        float zDist = bullyPushZ - (squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k) + 1] + signZ * (l / 2));

                        float dist = sqrtf(xDist * xDist + zDist * zDist);

                        if (dist >= pushRadius - bullyHurtbox && dist <= pushRadius - fmaxf(bullyHurtbox - 2.0f * maxSlidingSpeed - 1.85f, 0.0f)) {
                            int angle = atan2sG(zDist, xDist);

                            int angleDiff = (short)(angle - uphillAngle);

                            if (angleDiff < -0x4000 || angleDiff > 0x4000) {
                                if (refAngle == 65536) {
                                    refAngle = angle;
                                }

                                minAngle = min(minAngle, (int)(short)(angle - refAngle));
                                maxAngle = max(maxAngle, (int)(short)(angle - refAngle));
                            }
                        }
                    }
                }
            }

            if (refAngle != 65536) {
                minAngle = (unsigned short)(minAngle + refAngle);
                maxAngle = (unsigned short)(maxAngle + refAngle);

                int minAngleIdx = revAtansG(minAngle);
                int maxAngleIdx = revAtansG(maxAngle);

                while ((short)(((gArctanTableG[minAngleIdx] >> 4) << 4) - minAngle) < 0) {
                    minAngleIdx = (minAngleIdx + 1) % 8192;
                }

                if (maxAngleIdx < minAngleIdx) {
                    maxAngleIdx = maxAngleIdx + 8192;
                }

                for (int j = minAngleIdx; j <= maxAngleIdx; j++) {
                    int angle = (unsigned short)(gArctanTableG[j % 8192]);

                    float minBullyX = minBullyPushX - pushRadius * sinsG(angle);
                    float maxBullyX = maxBullyPushX - pushRadius * sinsG(angle);
                    float minBullyZ = minBullyPushZ - pushRadius * cossG(angle);
                    float maxBullyZ = maxBullyPushZ - pushRadius * cossG(angle);

                    float xDiff2;

                    if (minBullyX == maxBullyX) {
                        int precision;
                        frexpf(minBullyX, &precision);
                        xDiff2 = powf(2.0f, precision - 24);
                    }
                    else {
                        xDiff2 = powf(2.0f, floorf(log2f(maxBullyX - minBullyX)));

                        while (floorf(maxBullyX / (2.0f * xDiff2)) >= ceilf(minBullyX / (2.0f * xDiff2))) {
                            xDiff2 = xDiff2 * 2.0f;
                        }
                    }

                    float zDiff2;

                    if (minBullyZ == maxBullyZ) {
                        int precision;
                        frexpf(minBullyZ, &precision);
                        zDiff2 = powf(2.0f, precision - 24);
                    }
                    else {
                        zDiff2 = powf(2.0f, floorf(log2f(maxBullyZ - minBullyZ)));

                        while (floorf(maxBullyZ / (2.0f * zDiff2)) >= ceilf(minBullyZ / (2.0f * zDiff2))) {
                            zDiff2 = zDiff2 * 2.0f;
                        }
                    }

                    float maxBullyXSpeed = fminf(nextafterf(xDiff2 * baseBullySpeed, -INFINITY), maxBullySpeed);
                    float maxBullyZSpeed = fminf(nextafterf(zDiff2 * baseBullySpeed, -INFINITY), maxBullySpeed);

                    float maxPushSpeed = (fabsf(maxBullyXSpeed * sinsG(angle)) + fabsf(maxBullyZSpeed * cossG(angle))) * (73.0f / 53.0f) * 3.0f;

                    float maxLossFactor = (-1.0 * (0.5f + 0.5f * maxPushSpeed / 100.0f)) * 0.02 + 0.92;
                    float slidingSpeedX = (doubleTenKSol->post10KXVel / maxLossFactor) - slopeXVel;
                    float slidingSpeedZ = (doubleTenKSol->post10KZVel / maxLossFactor) - slopeZVel;

                    float slidingSpeedToPlatformOptions[4] = { -slidingSpeedX, slidingSpeedZ, -slidingSpeedZ, slidingSpeedX };

                    float slidingSpeedToPlatform = slidingSpeedToPlatformOptions[tenKSol->squishCeiling];

                    if (fabsf(slidingSpeedX) <= maxSlidingSpeed && fabsf(slidingSpeedZ) <= maxSlidingSpeed && slidingSpeedToPlatform <= maxSlidingSpeedToPlatform) {
                        float minSquishSpotX = INFINITY;
                        float maxSquishSpotX = -INFINITY;
                        float minSquishSpotZ = INFINITY;
                        float maxSquishSpotZ = -INFINITY;
                        float maxSquishSpotY = -INFINITY;

                        float squishSpotPos[3] = { 0.0f, 0.0f, 0.0f };

                        for (int k = 0; k < nSquishSpots[tenKSol->squishCeiling]; k++) {
                            int minAngleSpot = INT_MAX;
                            int maxAngleSpot = INT_MIN;
                            int refAngleSpot = angle;

                            float signX = sign(squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k)]);
                            float signZ = sign(squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k) + 1]);

                            for (int l = 0; l < 4; l++) {
                                for (int j = 0; j < 4; j++) {
                                    float bullyX = (j % 2 == 0) ? minBullyX : maxBullyX;
                                    float bullyZ = (j / 2 == 0) ? minBullyZ : maxBullyZ;
                                    float xDist = (squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k)] + signX * (l % 2)) - bullyX;
                                    float zDist = (squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k) + 1] + signZ * (l / 2)) - bullyZ;

                                    float dist = sqrtf(xDist * xDist + zDist * zDist);

                                    if (dist <= bullyHurtbox && dist >= bullyHurtbox - 2.0f * maxSlidingSpeed - 1.85f) {
                                        int testAngle = atan2sG(zDist, xDist);

                                        int angleDiff = (short)(testAngle - uphillAngle);

                                        if (angleDiff < -0x4000 || angleDiff > 0x4000) {
                                            minAngleSpot = min(minAngleSpot, (int)(short)(testAngle - refAngleSpot));
                                            maxAngleSpot = max(maxAngleSpot, (int)(short)(testAngle - refAngleSpot));
                                        }
                                    }
                                }
                            }

                            if (minAngleSpot <= 0 && maxAngleSpot >= 0) {
                                for (int l = 0; l < 4; l++) {
                                    for (int j = 0; j < 4; j++) {
                                        float bullyX = (j % 2 == 0) ? minBullyX : maxBullyX;
                                        float bullyZ = (j / 2 == 0) ? minBullyZ : maxBullyZ;
                                        float xDist = (squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k)] + signX * (l % 2)) - bullyX;
                                        float zDist = (squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k) + 1] + signZ * (l / 2)) - bullyZ;

                                        float dist = sqrtf(xDist * xDist + zDist * zDist);

                                        if (dist <= bullyHurtbox && dist >= bullyHurtbox - 2.0f * maxSlidingSpeed - 1.85f) {
                                            minSquishSpotX = fminf(minSquishSpotX, (squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k)] + signX * (l % 2)));
                                            maxSquishSpotX = fmaxf(maxSquishSpotX, (squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k)] + signX * (l % 2)));
                                            minSquishSpotZ = fminf(minSquishSpotZ, (squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k) + 1] + signZ * (l / 2)));
                                            maxSquishSpotZ = fmaxf(maxSquishSpotZ, (squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k) + 1] + signZ * (l / 2)));
                                        }
                                    }
                                }

                                squishSpotPos[0] = squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k)];
                                squishSpotPos[2] = squishSpots[(2 * tenKSol->squishCeiling * limits.MAX_SQUISH_SPOTS) + (2 * k) + 1];

                                float fHeight;
                                int floor_idx = find_floor(squishSpotPos, squishTriangles, squishNormals, &fHeight);

                                if (floor_idx == -1) {
                                    maxSquishSpotY = INFINITY;
                                }
                                else {
                                    maxSquishSpotY = fmaxf(maxSquishSpotY, fHeight-78.0f);
                                }
                            }
                        }

                        if (minSquishSpotZ <= maxSquishSpotZ && minSquishSpotX <= maxSquishSpotX) {
                            int solIdx = atomicAdd(&(counts.nBullyPushSolutions), 1);

                            if (solIdx < limits.MAX_BULLY_PUSH_SOLUTIONS) {
                                struct BullyPushSolution* solution = &(solutions.bullyPushSolutions[solIdx]);
                                solution->doubleTenKSolutionIdx = idx;
                                solution->bullyMinX = minBullyX;
                                solution->bullyMaxX = maxBullyX;
                                solution->bullyMinZ = minBullyZ;
                                solution->bullyMaxZ = maxBullyZ;
                                solution->pushAngle = angle;
                                solution->maxSpeed = maxPushSpeed;
                                solution->squishPushQF = squishPushFrames;
                                solution->squishPushMinX = minBullyPushX;
                                solution->squishPushMaxX = maxBullyPushX;
                                solution->squishPushMinZ = minBullyPushZ;
                                solution->squishPushMaxZ = maxBullyPushZ;
                                solution->minSlidingSpeedX = slidingSpeedX;
                                solution->minSlidingSpeedZ = slidingSpeedZ;
                                solution->marioMinX = minSquishSpotX;
                                solution->marioMaxX = maxSquishSpotX;
                                solution->marioMinZ = minSquishSpotZ;
                                solution->marioMaxZ = maxSquishSpotZ;
                                solution->marioMaxY = maxSquishSpotY;
                                atomicAdd(&(tenKSol->bpSetups), 1);
                            }
                        }
                    }
                }
            }
        }
    }
}

__device__ float find_position_boundary(float minValue, float maxValue, float target, float yNormal, float vel, int dir) {
    while (nextafterf(minValue, INFINITY) < maxValue) {
        float midValue = fmaxf(nextafterf(minValue, INFINITY), (minValue + maxValue) / 2.0f);

        float pos = midValue;

        for (int i = 0; i < 4; i++) {
            pos = pos + yNormal * (vel / 4.0f);
        }

        if (pos < target) {
            minValue = midValue;
        }
        else if (pos > target) {
            maxValue = midValue;
        }
        else if (dir > 0) {
            minValue = midValue;
        }
        else {
            maxValue = midValue;
        }
    }

    if (dir > 0) {
        return minValue;
    }
    else {
        return maxValue;
    }
}

__device__ float find_speed_boundary_a(float startPos, float targetPos, float yNormal, int dir) {
    float minVel = (targetPos > startPos) ? 0.0f : 2.0f * (targetPos - startPos) / yNormal;
    float maxVel = (targetPos > startPos) ? 2.0f * (targetPos - startPos) / yNormal : 0.0f;

    while (nextafterf(minVel, INFINITY) < maxVel) {
        float midVel = fmaxf(nextafterf(minVel, INFINITY), (minVel + maxVel) / 2.0f);

        float pos = startPos;

        for (int i = 0; i < 4; i++) {
            pos = pos + yNormal * (midVel / 4.0f);
        }

        if (pos < targetPos) {
            minVel = midVel;
        }
        else if (pos > targetPos) {
            maxVel = midVel;
        }
        else if (dir > 0) {
            minVel = midVel;
        }
        else {
            maxVel = midVel;
        }
    }

    if (dir > 0) {
        return minVel;
    }
    else {
        return maxVel;
    }
}

__device__ float find_speed_boundary_b(float targetSpeed, float zVel, int dir) {
    float minXVel = 0.0f;
    float maxXVel = 2.0f * targetSpeed;

    while (nextafterf(minXVel, INFINITY) < maxXVel) {
        float midXVel = fmaxf(nextafterf(minXVel, INFINITY), (minXVel + maxXVel) / 2.0f);

        float speed = sqrtf(midXVel * midXVel + zVel * zVel);

        if (speed < targetSpeed) {
            minXVel = midXVel;
        }
        else if (speed > targetSpeed) {
            maxXVel = midXVel;
        }
        else if (dir > 0) {
            minXVel = midXVel;
        }
        else {
            maxXVel = midXVel;
        }
    }

    if (dir > 0) {
        return minXVel;
    }
    else {
        return maxXVel;
    }
}

__device__ void search_xVel(float zVel, float targetSpeed, float* targetPosition, float yNormal, int idx, const float minSpeedDelta) {
    int ceilIdx = solutions.tenKSolutions[idx].squishCeiling;

    float p[2][3];
    float q[2][3];
    int pIdx = 0;

    for (int i = 0; i < 3; i++) {
        if (squishCeilingTriangles[ceilIdx][i][0] != platform_pos[0] || squishCeilingTriangles[ceilIdx][i][1] != platform_pos[1] || startCeilingTriangles[ceilIdx][i][2] != platform_pos[2]) {
            p[pIdx][0] = squishCeilingTriangles[ceilIdx][i][0];
            p[pIdx][1] = squishCeilingTriangles[ceilIdx][i][1];
            p[pIdx][2] = squishCeilingTriangles[ceilIdx][i][2];

            q[pIdx][0] = startCeilingTriangles[ceilIdx][i][0];
            q[pIdx][1] = startCeilingTriangles[ceilIdx][i][1];
            q[pIdx][2] = startCeilingTriangles[ceilIdx][i][2];

            pIdx++;
        }
    }

    float z0 = nextafterf(targetPosition[2], -INFINITY) - yNormal * zVel;
    float z1 = nextafterf(targetPosition[2], INFINITY) - yNormal * zVel;

    float px0 = p[0][0] + (p[1][0] - p[0][0]) * (z0 - p[0][2]) / (p[1][2] - p[0][2]);
    float px1 = p[0][0] + (p[1][0] - p[0][0]) * (z1 - p[0][2]) / (p[1][2] - p[0][2]);
    float qx0 = q[0][0] + (q[1][0] - q[0][0]) * (z0 - q[0][2]) / (q[1][2] - q[0][2]);
    float qx1 = q[0][0] + (q[1][0] - q[0][0]) * (z1 - q[0][2]) / (q[1][2] - q[0][2]);

    float minX = fminf(fminf(px0, px1), fminf(qx0, qx1));
    float maxX = fmaxf(fmaxf(px0, px1), fmaxf(qx0, qx1));
    minX = (minX > 0) ? ceilf(minX) : nextafterf(ceilf(minX) - 1.0f, INFINITY);
    maxX = (maxX > 0) ? nextafterf(floorf(maxX) + 1.0f, -INFINITY) : floorf(maxX);

    float lowerXVel = find_speed_boundary_a(maxX, targetPosition[0], yNormal, -1);
    float upperXVel = find_speed_boundary_a(minX, targetPosition[0], yNormal, 1);

    float vel1 = find_speed_boundary_b(targetSpeed, zVel, -1);
    float vel2 = find_speed_boundary_b(targetSpeed, zVel, 1);

    for (int xDir = -1; xDir <= 1; xDir += 2) {
        float minXVel = fmaxf(lowerXVel, xDir > 0 ? vel1 : -vel2);
        float maxXVel = fminf(upperXVel, xDir > 0 ? vel2 : -vel1);

        minXVel = (minSpeedDelta == 0) ? minXVel : ceilf(minXVel / minSpeedDelta) * minSpeedDelta;
        maxXVel = (minSpeedDelta == 0) ? maxXVel : floorf(maxXVel / minSpeedDelta) * minSpeedDelta;

        for (float xVel1 = minXVel; xVel1 <= maxXVel; xVel1 = fmaxf(xVel1 + minSpeedDelta, nextafterf(xVel1, INFINITY))) {
            float minX = nextafterf(targetPosition[0], -INFINITY) - yNormal * xVel1;
            float maxX = nextafterf(targetPosition[0], INFINITY) - yNormal * xVel1;
            float minZ = nextafterf(targetPosition[2], -INFINITY) - yNormal * zVel;
            float maxZ = nextafterf(targetPosition[2], INFINITY) - yNormal * zVel;

            minX = find_position_boundary(minX, maxX, targetPosition[0], yNormal, xVel1, -1);
            maxX = find_position_boundary(minX, maxX, targetPosition[0], yNormal, xVel1, 1);
            minZ = find_position_boundary(minZ, maxZ, targetPosition[2], yNormal, zVel, -1);
            maxZ = find_position_boundary(minZ, maxZ, targetPosition[2], yNormal, zVel, 1);

            int minXI = (int)minX;
            int maxXI = (int)maxX;
            int minZI = (int)minZ;
            int maxZI = (int)maxZ;

            float minXF = INFINITY;
            float maxXF = -INFINITY;
            float minZF = INFINITY;
            float maxZF = -INFINITY;

            for (int x = minXI; x <= maxXI; x++) {
                for (int z = minZI; z <= maxZI; z++) {
                    float squarePos[3] = { (float)x, 0.0f, (float)z };
                    float fHeight;
                    int fIdx1 = find_floor(squarePos, squishTriangles, squishNormals, &fHeight);
                    int fIdx2 = find_floor(squarePos, startTriangles, startNormals, &fHeight);

                    if (fIdx1 == -1 && fIdx2 != -1) {
                        minXF = fminf(minXF, (x < 0) ? nextafterf((float)(x - 1), INFINITY) : (float)x);
                        maxXF = fmaxf(maxXF, (x > 0) ? nextafterf((float)(x + 1), -INFINITY) : (float)x);
                        minZF = fminf(minZF, (z < 0) ? nextafterf((float)(z - 1), INFINITY) : (float)z);
                        maxZF = fmaxf(maxZF, (z > 0) ? nextafterf((float)(z + 1), -INFINITY) : (float)z);
                    }
                }
            }

            minX = fmaxf(minX, minXF);
            maxX = fminf(maxX, maxXF);
            minZ = fmaxf(minZ, minZF);
            maxZ = fminf(maxZ, maxZF);

            if (minX <= maxX && minZ <= maxZ) {
                int solIdx = atomicAdd(&(counts.nDouble10KSolutions), 1);

                if (solIdx < limits.MAX_DOUBLE_10K_SOLUTIONS) {
                    struct DoubleTenKSolution* solution = &(solutions.doubleTenKSolutions[solIdx]);
                    solution->tenKSolutionIdx = idx;
                    solution->post10KXVel = xVel1;
                    solution->post10KZVel = zVel;
                    solution->minStartX = minX;
                    solution->maxStartX = maxX;
                    solution->minStartZ = minZ;
                    solution->maxStartZ = maxZ;
                }
            }
        }
    }
}

__global__ void find_double_10k_solutions() {
    const float minSpeedDelta = powf(2.0f, -4);

    float minPlatformZ = fminf(fminf(fminf(squishTriangles[0][0][2], squishTriangles[0][2][2]), fminf(squishTriangles[1][0][2], squishTriangles[1][1][2])), fminf(fminf(startTriangles[0][0][2], startTriangles[0][2][2]), fminf(startTriangles[1][0][2], startTriangles[1][1][2])));
    float maxPlatformZ = fmaxf(fmaxf(fmaxf(squishTriangles[0][0][2], squishTriangles[0][2][2]), fmaxf(squishTriangles[1][0][2], squishTriangles[1][1][2])), fmaxf(fmaxf(startTriangles[0][0][2], startTriangles[0][2][2]), fmaxf(startTriangles[1][0][2], startTriangles[1][1][2])));
    minPlatformZ = (minPlatformZ > 0) ? minPlatformZ : nextafterf(minPlatformZ - 1.0f, INFINITY);
    maxPlatformZ = (maxPlatformZ > 0) ? nextafterf(maxPlatformZ + 1.0f, -INFINITY) : maxPlatformZ;

    int idx = blockIdx.x * blockDim.x + threadIdx.x;

    if (idx < min(counts.n10KSolutions, limits.MAX_10K_SOLUTIONS)) {
        struct TenKSolution* tenKSol = &(solutions.tenKSolutions[idx]);

        if (tenKSol->bdSetups > 0) {
            struct SpeedSolution* speedSol = &(solutions.speedSolutions[tenKSol->speedSolutionIdx]);

            int floorIdx = (tenKSol->squishCeiling == 0 || tenKSol->squishCeiling == 2) ? 0 : 1;

            double xPos = (tenKSol->startPosition[0][0] + tenKSol->startPosition[1][0]) / 2.0;
            double zPos = (tenKSol->startPosition[0][2] + tenKSol->startPosition[1][2]) / 2.0;

            double xDiff = tenKSol->frame1Position[0] - xPos;
            double zDiff = tenKSol->frame1Position[2] - zPos;

            float minZVel = fmaxf(-tenKSol->departureSpeed, find_speed_boundary_a(maxPlatformZ, tenKSol->frame1Position[2], startNormals[floorIdx][1], -1));
            float maxZVel = fminf(tenKSol->departureSpeed, find_speed_boundary_a(minPlatformZ, tenKSol->frame1Position[2], startNormals[floorIdx][1], 1));

            minZVel = (minSpeedDelta == 0) ? minZVel : ceilf(minZVel / minSpeedDelta) * minSpeedDelta;
            maxZVel = (minSpeedDelta == 0) ? maxZVel : floorf(maxZVel / minSpeedDelta) * minSpeedDelta;

            for (float zVel1 = minZVel; zVel1 <= maxZVel; zVel1 = fmaxf(zVel1 + minSpeedDelta, nextafterf(zVel1, INFINITY))) {
                search_xVel(zVel1, tenKSol->departureSpeed, tenKSol->frame1Position, startNormals[floorIdx][1], idx, minSpeedDelta);
            }
        }
    }
}

__global__ void set_squish_spots(short* tris, float* norms) {
    for (int x = 0; x < 4; x++) {
        for (int y = 0; y < 3; y++) {
            preSquishCeilingTriangles[x][y][0] = tris[9 * x + 3 * y];
            preSquishCeilingTriangles[x][y][1] = tris[9 * x + 3 * y + 1];
            preSquishCeilingTriangles[x][y][2] = tris[9 * x + 3 * y + 2];
            preSquishCeilingNormals[x][y] = norms[3 * x + y];

            squishCeilingTriangles[x][y][0] = tris[36 + 9 * x + 3 * y];
            squishCeilingTriangles[x][y][1] = tris[36 + 9 * x + 3 * y + 1];
            squishCeilingTriangles[x][y][2] = tris[36 + 9 * x + 3 * y + 2];
            squishCeilingNormals[x][y] = norms[12 + 3 * x + y];

            startCeilingTriangles[x][y][0] = tris[72 + 9 * x + 3 * y];
            startCeilingTriangles[x][y][1] = tris[72 + 9 * x + 3 * y + 1];
            startCeilingTriangles[x][y][2] = tris[72 + 9 * x + 3 * y + 2];
            startCeilingNormals[x][y] = norms[24 + 3 * x + y];
        }

        squishCeilings[x] = squishCeilingNormals[x][1] > -0.5f;
    }

    for (int ceilIdx = 0; ceilIdx < 4; ceilIdx++) {
        nSquishSpots[ceilIdx] = 0;

        if (squishCeilings[ceilIdx]) {
            int minX = INT_MAX;
            int maxX = INT_MIN;
            int minZ = INT_MAX;
            int maxZ = INT_MIN;

            for (int i = 0; i < 4; i++) {
                for (int j = 0; j < 3; j++) {
                    minX = min(minX, (int)squishCeilingTriangles[i][j][0]);
                    maxX = max(maxX, (int)squishCeilingTriangles[i][j][0]);
                    minZ = min(minZ, (int)squishCeilingTriangles[i][j][2]);
                    maxZ = max(maxZ, (int)squishCeilingTriangles[i][j][2]);
                }
            }

            int x0 = (ceilIdx == 0 || ceilIdx == 2) ? squishCeilingTriangles[ceilIdx][0][0] : squishCeilingTriangles[ceilIdx][1][0];
            int z0 = (ceilIdx == 0 || ceilIdx == 2) ? squishCeilingTriangles[ceilIdx][0][2] : squishCeilingTriangles[ceilIdx][1][2];
            int x1 = ceilIdx == 0 ? squishCeilingTriangles[ceilIdx][1][0] : squishCeilingTriangles[ceilIdx][2][0];
            int z1 = ceilIdx == 0 ? squishCeilingTriangles[ceilIdx][1][2] : squishCeilingTriangles[ceilIdx][2][2];

            float xDiff = x1 - x0;
            float zDiff = z1 - z0;

            float diffDist = sqrtf(xDiff * xDiff + zDiff * zDiff);

            xDiff = xDiff / diffDist;
            zDiff = zDiff / diffDist;

            for (int x = minX; x <= maxX; x++) {
                for (int z = minZ; z <= maxZ; z++) {
                    float pos[3] = { (float)x, -3071.0f , (float)z };

                    float ceilHeight;
                    int idx = find_ceil(pos, squishCeilingTriangles, squishCeilingNormals, &ceilHeight);

                    if (idx == ceilIdx && ceilHeight - -3071.0f < 150.0f) {
                        float floorHeight;
                        int floorIdx = find_floor(pos, squishTriangles, squishNormals, &floorHeight);

                        if (floorIdx == -1) {
                            float preCeilHeight;
                            int preIdx = find_ceil(pos, preSquishCeilingTriangles, preSquishCeilingNormals, &preCeilHeight);

                            if (preIdx == -1) {
                                if (nSquishSpots[ceilIdx] < limits.MAX_SQUISH_SPOTS) {
                                    squishSpots[(2 * ceilIdx * limits.MAX_SQUISH_SPOTS) + (2 * nSquishSpots[ceilIdx])] = x;
                                    squishSpots[(2 * ceilIdx * limits.MAX_SQUISH_SPOTS) + (2 * nSquishSpots[ceilIdx]) + 1] = z;
                                }

                                nSquishSpots[ceilIdx]++;
                            }
                        }
                    }
                }
            }
        }
    }
}

__global__ void generate_strain_setups() {
    nStrainSetups = 0;

    for (int i = 0; i <= maxFSpeedLevels; i++) {
        float fSpeed = (float)i / (float)maxFSpeedLevels;

        float maxSSpeedLevelsSq = maxSSpeedLevels * sqrtf(1.0 - fSpeed * fSpeed);

        fSpeed = 1.5f * fSpeed;

        for (int j = 0; j <= maxSSpeedLevelsSq; j++) {
            float sSpeed = 10.0f * (float)j / (float)maxSSpeedLevels;

            for (float signF = (i == 0) ? 1.0f : -1.0f; signF <= 1.0f; signF += 2.0f) {
                for (float signS = (j == 0) ? 1.0f : -1.0f; signS <= 1.0f; signS += 2.0f) {
                    if (nStrainSetups < limits.MAX_STRAIN_SETUPS) {
                        struct StrainSetup* setup = &(strainSetups[nStrainSetups]);
                        setup->forwardStrain = signF*fSpeed;
                        setup->sidewardStrain = signS*sSpeed;
                    }

                    nStrainSetups++;
                }
            }
        }
    }
}

__global__ void reset_ranges() {
    maxFSpeedLevels = 0;
    maxSSpeedLevels = 0;
}

int init_solution_structs(SolStruct* s, GPULimits* l) {
    int errorCode = 0;

    errorCode |= hipMalloc((void**)&s->sk1Solutions, l->MAX_SK_PHASE_ONE * sizeof(SKPhase1));
    errorCode |= hipMalloc((void**)&s->sk2ASolutions, l->MAX_SK_PHASE_TWO_A * sizeof(SKPhase2));
    errorCode |= hipMalloc((void**)&s->sk2BSolutions, l->MAX_SK_PHASE_TWO_B * sizeof(SKPhase2));
    errorCode |= hipMalloc((void**)&s->sk2CSolutions, l->MAX_SK_PHASE_TWO_C * sizeof(SKPhase2));
    errorCode |= hipMalloc((void**)&s->sk2DSolutions, l->MAX_SK_PHASE_TWO_D * sizeof(SKPhase2));
    errorCode |= hipMalloc((void**)&s->sk3Solutions, l->MAX_SK_PHASE_THREE * sizeof(SKPhase3));
    errorCode |= hipMalloc((void**)&s->sk4Solutions, l->MAX_SK_PHASE_FOUR * sizeof(SKPhase4));
    errorCode |= hipMalloc((void**)&s->sk5Solutions, l->MAX_SK_PHASE_FIVE * sizeof(SKPhase5));
    errorCode |= hipMalloc((void**)&s->sk6Solutions, l->MAX_SK_PHASE_SIX * sizeof(SKPhase6));
    errorCode |= hipMalloc((void**)&s->platSolutions, l->MAX_PLAT_SOLUTIONS * sizeof(PlatformSolution));
    errorCode |= hipMalloc((void**)&s->upwarpSolutions, l->MAX_UPWARP_SOLUTIONS * sizeof(UpwarpSolution));
    errorCode |= hipMalloc((void**)&s->skuwSolutions, l->MAX_SK_UPWARP_SOLUTIONS * sizeof(SKUpwarpSolution));
    errorCode |= hipMalloc((void**)&s->speedSolutions, l->MAX_SPEED_SOLUTIONS * sizeof(SpeedSolution));
    errorCode |= hipMalloc((void**)&s->tenKSolutions, l->MAX_10K_SOLUTIONS * sizeof(TenKSolution));
    errorCode |= hipMalloc((void**)&s->doubleTenKSolutions, l->MAX_DOUBLE_10K_SOLUTIONS * sizeof(DoubleTenKSolution));
    errorCode |= hipMalloc((void**)&s->bullyPushSolutions, l->MAX_BULLY_PUSH_SOLUTIONS * sizeof(BullyPushSolution));
    errorCode |= hipMalloc((void**)&s->slideSolutions, l->MAX_SLIDE_SOLUTIONS * sizeof(SlideSolution));
    errorCode |= hipMalloc((void**)&s->bdSolutions, l->MAX_BD_SOLUTIONS * sizeof(BDSolution));

    hipMemcpyToSymbol(HIP_SYMBOL(solutions), s, sizeof(struct SolStruct), 0, hipMemcpyHostToDevice);

    return errorCode;
}

void free_solution_pointers_gpu(SolStruct* s) {
    hipFree(s->sk1Solutions);
    hipFree(s->sk2ASolutions);
    hipFree(s->sk2BSolutions);
    hipFree(s->sk2CSolutions);
    hipFree(s->sk2DSolutions);
    hipFree(s->sk3Solutions);
    hipFree(s->sk4Solutions);
    hipFree(s->sk5Solutions);
    hipFree(s->sk6Solutions);
    hipFree(s->platSolutions);
    hipFree(s->upwarpSolutions);
    hipFree(s->skuwSolutions);
    hipFree(s->speedSolutions);
    hipFree(s->tenKSolutions);
    hipFree(s->doubleTenKSolutions);
    hipFree(s->bullyPushSolutions);
    hipFree(s->slideSolutions);
    hipFree(s->bdSolutions);
}

void free_solution_pointers_cpu(SolStruct* s) {
    std::free(s->sk1Solutions);
    std::free(s->sk2ASolutions);
    std::free(s->sk2BSolutions);
    std::free(s->sk2CSolutions);
    std::free(s->sk2DSolutions);
    std::free(s->sk3Solutions);
    std::free(s->sk4Solutions);
    std::free(s->sk5Solutions);
    std::free(s->sk6Solutions);
    std::free(s->platSolutions);
    std::free(s->upwarpSolutions);
    std::free(s->skuwSolutions);
    std::free(s->speedSolutions);
    std::free(s->tenKSolutions);
    std::free(s->doubleTenKSolutions);
    std::free(s->bullyPushSolutions);
    std::free(s->slideSolutions);
    std::free(s->bdSolutions);
}

void copy_solution_counts_to_cpu(struct SolCounts* countsCPU) {
    hipMemcpyFromSymbol(&countsCPU, HIP_SYMBOL(counts), sizeof(struct SolCounts), 0, hipMemcpyDeviceToHost);
}

void copy_solutions_to_cpu(struct FSTData* p, struct SolStruct* solutionsCPU, struct SolCounts* countsCPU) {
    solutionsCPU->doubleTenKSolutions = (struct DoubleTenKSolution*)std::malloc(countsCPU->nDouble10KSolutions * sizeof(struct DoubleTenKSolution));
    solutionsCPU->bullyPushSolutions = (struct BullyPushSolution*)std::malloc(countsCPU->nBullyPushSolutions * sizeof(struct BullyPushSolution));

    solutionsCPU->bdSolutions = (struct BDSolution*)std::malloc(countsCPU->nBDSolutions * sizeof(struct BDSolution));
    solutionsCPU->slideSolutions = (struct SlideSolution*)std::malloc(countsCPU->nSlideSolutions * sizeof(struct SlideSolution));
    solutionsCPU->tenKSolutions = (struct TenKSolution*)std::malloc(countsCPU->n10KSolutions * sizeof(struct TenKSolution));
    solutionsCPU->speedSolutions = (struct SpeedSolution*)std::malloc(countsCPU->nSpeedSolutions * sizeof(struct SpeedSolution));
    solutionsCPU->skuwSolutions = (struct SKUpwarpSolution*)std::malloc(countsCPU->nSKUWSolutions * sizeof(struct SKUpwarpSolution));

    solutionsCPU->platSolutions = (struct PlatformSolution*)std::malloc(countsCPU->nPlatSolutions * sizeof(struct PlatformSolution));
    solutionsCPU->upwarpSolutions = (struct UpwarpSolution*)std::malloc(countsCPU->nUpwarpSolutions * sizeof(struct UpwarpSolution));

    solutionsCPU->sk1Solutions = (struct SKPhase1*)std::malloc(countsCPU->nSK1Solutions * sizeof(struct SKPhase1));
    solutionsCPU->sk2ASolutions = (struct SKPhase2*)std::malloc(countsCPU->nSK2ASolutions * sizeof(struct SKPhase2));
    solutionsCPU->sk2BSolutions = (struct SKPhase2*)std::malloc(countsCPU->nSK2BSolutions * sizeof(struct SKPhase2));
    solutionsCPU->sk2CSolutions = (struct SKPhase2*)std::malloc(countsCPU->nSK2CSolutions * sizeof(struct SKPhase2));
    solutionsCPU->sk2DSolutions = (struct SKPhase2*)std::malloc(countsCPU->nSK2DSolutions * sizeof(struct SKPhase2));
    solutionsCPU->sk3Solutions = (struct SKPhase3*)std::malloc(countsCPU->nSK3Solutions * sizeof(struct SKPhase3));
    solutionsCPU->sk4Solutions = (struct SKPhase4*)std::malloc(countsCPU->nSK4Solutions * sizeof(struct SKPhase4));
    solutionsCPU->sk5Solutions = (struct SKPhase5*)std::malloc(countsCPU->nSK5Solutions * sizeof(struct SKPhase5));
    solutionsCPU->sk6Solutions = (struct SKPhase6*)std::malloc(countsCPU->nSK6Solutions * sizeof(struct SKPhase6));

    hipMemcpy(solutionsCPU->doubleTenKSolutions, p->s.doubleTenKSolutions, countsCPU->nDouble10KSolutions * sizeof(struct DoubleTenKSolution), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->bullyPushSolutions, p->s.bullyPushSolutions, countsCPU->nBullyPushSolutions * sizeof(struct BullyPushSolution), hipMemcpyDeviceToHost);

    hipMemcpy(solutionsCPU->bdSolutions, p->s.bdSolutions, countsCPU->nBDSolutions * sizeof(struct BDSolution), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->slideSolutions, p->s.slideSolutions, countsCPU->nSlideSolutions * sizeof(struct SlideSolution), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->tenKSolutions, p->s.tenKSolutions, countsCPU->n10KSolutions * sizeof(struct TenKSolution), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->speedSolutions, p->s.speedSolutions, countsCPU->nSpeedSolutions * sizeof(struct SpeedSolution), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->skuwSolutions, p->s.skuwSolutions, countsCPU->nSKUWSolutions * sizeof(struct SKUpwarpSolution), hipMemcpyDeviceToHost);

    hipMemcpy(solutionsCPU->upwarpSolutions, p->s.upwarpSolutions, countsCPU->nUpwarpSolutions * sizeof(struct UpwarpSolution), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->platSolutions, p->s.platSolutions, countsCPU->nPlatSolutions * sizeof(struct PlatformSolution), hipMemcpyDeviceToHost);

    hipMemcpy(solutionsCPU->sk1Solutions, p->s.sk1Solutions, countsCPU->nSK1Solutions * sizeof(struct SKPhase1), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->sk2ASolutions, p->s.sk2ASolutions, countsCPU->nSK2ASolutions * sizeof(struct SKPhase2), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->sk2BSolutions, p->s.sk2BSolutions, countsCPU->nSK2BSolutions * sizeof(struct SKPhase2), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->sk2CSolutions, p->s.sk2CSolutions, countsCPU->nSK2CSolutions * sizeof(struct SKPhase2), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->sk2DSolutions, p->s.sk2DSolutions, countsCPU->nSK2DSolutions * sizeof(struct SKPhase2), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->sk3Solutions, p->s.sk3Solutions, countsCPU->nSK3Solutions * sizeof(struct SKPhase3), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->sk4Solutions, p->s.sk4Solutions, countsCPU->nSK4Solutions * sizeof(struct SKPhase4), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->sk5Solutions, p->s.sk5Solutions, countsCPU->nSK5Solutions * sizeof(struct SKPhase5), hipMemcpyDeviceToHost);
    hipMemcpy(solutionsCPU->sk6Solutions, p->s.sk6Solutions, countsCPU->nSK6Solutions * sizeof(struct SKPhase6), hipMemcpyDeviceToHost);
}

SolutionStage get_best_stage(struct SolCounts* countsCPU) {
    if (countsCPU->nPlatSolutions == 0) {
        return STAGE_NOTHING;
    } 
    else if (countsCPU->nUpwarpSolutions == 0) {
        return STAGE_PLATFORM;
    } 
    else if (countsCPU->nSK6Solutions == 0) {
        return STAGE_UPWARP;
    }
    else if (countsCPU->nSKUWSolutions == 0) {
        return STAGE_SLIDE_KICK;
    }
    else if (countsCPU->nSpeedSolutions == 0) {
        return STAGE_SKUW;
    }
    else if (countsCPU->n10KSolutions == 0) {
        return STAGE_SPEED;
    }
    else if (countsCPU->nSlideSolutions == 0) {
        return STAGE_TEN_K;
    }
    else if (countsCPU->nBDSolutions == 0) {
        return STAGE_SLIDE;
    }
    else if (countsCPU->nDouble10KSolutions == 0) {
        return STAGE_BREAKDANCE;
    }
    else if (countsCPU->nBullyPushSolutions == 0) {
        return STAGE_DOUBLE_TEN_K;
    }
    else if (countsCPU->nFullSolutions == 0) {
        return STAGE_BULLY_PUSH;
    }
    else {
        return STAGE_COMPLETE;
    }
}

void write_solutions_to_file(float* startNormal, struct FSTOptions* o, struct FSTData* p, struct SolStruct* solutionsCPU, struct SolCounts* countsCPU, int floorIdx, std::ofstream& wf) {
    int bestStage = get_best_stage(countsCPU);

    if (o->outputLevel == 0) {
        if (bestStage == STAGE_COMPLETE) {
            wf << float2string_max(startNormal[0], 1) << "," << float2string_max(startNormal[1], 1) << "," << float2string_max(startNormal[2], 1) << "," << countsCPU->nFullSolutions << endl;
        }
    }
    else if (o->outputLevel == 1) {
        if (bestStage >= STAGE_TEN_K) {
            wf << float2string_max(startNormal[0], 1) << "," << float2string_max(startNormal[1], 1) << "," << float2string_max(startNormal[2], 1) << "," << bestStage << endl;
        }
    }
    else {
        for (int l = 0; l < countsCPU->nBDSolutions; l++) {
            if (solutionsCPU->bdSolutions[l].slideSolutionIdx >= 0) {
                int tenKIdx = solutionsCPU->slideSolutions[solutionsCPU->bdSolutions[l].slideSolutionIdx].tenKSolutionIdx;

                int newIdx = solutionsCPU->tenKSolutions[tenKIdx].bdSetups;
                solutionsCPU->tenKSolutions[tenKIdx].bdSetups++;

                if (l != newIdx) {
                    struct BDSolution temp = solutionsCPU->bdSolutions[l];
                    temp.slideSolutionIdx = -temp.slideSolutionIdx - 1;
                    solutionsCPU->bdSolutions[l] = solutionsCPU->bdSolutions[newIdx];
                    solutionsCPU->bdSolutions[newIdx] = temp;
                    l--;
                }
            }
            else {
                solutionsCPU->bdSolutions[l].slideSolutionIdx = -solutionsCPU->bdSolutions[l].slideSolutionIdx - 1;
            }
        }

        for (int l = 0; l < countsCPU->nBullyPushSolutions; l++) {
            if (solutionsCPU->bullyPushSolutions[l].doubleTenKSolutionIdx >= 0) {
                int tenKIdx = solutionsCPU->doubleTenKSolutions[solutionsCPU->bullyPushSolutions[l].doubleTenKSolutionIdx].tenKSolutionIdx;

                int newIdx = solutionsCPU->tenKSolutions[tenKIdx].bpSetups;
                solutionsCPU->tenKSolutions[tenKIdx].bpSetups++;

                if (l != newIdx) {
                    struct BullyPushSolution temp = solutionsCPU->bullyPushSolutions[l];
                    temp.doubleTenKSolutionIdx = -temp.doubleTenKSolutionIdx - 1;
                    solutionsCPU->bullyPushSolutions[l] = solutionsCPU->bullyPushSolutions[newIdx];
                    solutionsCPU->bullyPushSolutions[newIdx] = temp;
                    l--;
                }
            }
            else {
                solutionsCPU->bullyPushSolutions[l].doubleTenKSolutionIdx = -solutionsCPU->bullyPushSolutions[l].doubleTenKSolutionIdx - 1;
            }
        }

        int m = 0;

        for (int l = 0; l < countsCPU->nBDSolutions; l++) {
            struct BDSolution* bdSol = &(solutionsCPU->bdSolutions[l]);
            struct SlideSolution* slideSol = &(solutionsCPU->slideSolutions[bdSol->slideSolutionIdx]);
            struct TenKSolution* tenKSol = &(solutionsCPU->tenKSolutions[slideSol->tenKSolutionIdx]);
            struct SpeedSolution* speedSol = &(solutionsCPU->speedSolutions[tenKSol->speedSolutionIdx]);
            struct SKUpwarpSolution* skuwSol = &(solutionsCPU->skuwSolutions[speedSol->skuwSolutionIdx]);
            struct UpwarpSolution* uwSol = &(solutionsCPU->upwarpSolutions[skuwSol->uwIdx]);
            struct PlatformSolution* platSol = &(solutionsCPU->platSolutions[uwSol->platformSolutionIdx]);
            struct SKPhase6* p6Sol = &(solutionsCPU->sk6Solutions[skuwSol->skIdx]);
            struct SKPhase5* p5Sol = &(solutionsCPU->sk5Solutions[p6Sol->p5Idx]);
            struct SKPhase4* p4Sol = &(solutionsCPU->sk4Solutions[p5Sol->p4Idx]);
            struct SKPhase3* p3Sol = &(solutionsCPU->sk3Solutions[p4Sol->p3Idx]);
            struct SKPhase2* p2Sol = (p3Sol->p2Type / 2 == 0) ? ((p3Sol->p2Type % 2 == 0) ? &(solutionsCPU->sk2ASolutions[p3Sol->p2Idx]) : &(solutionsCPU->sk2BSolutions[p3Sol->p2Idx])) : ((p3Sol->p2Type % 2 == 0) ? &(solutionsCPU->sk2CSolutions[p3Sol->p2Idx]) : &(solutionsCPU->sk2DSolutions[p3Sol->p2Idx]));
            struct SKPhase1* p1Sol = &(solutionsCPU->sk1Solutions[p2Sol->p1Idx]);

            while (m < countsCPU->nBullyPushSolutions && solutionsCPU->doubleTenKSolutions[solutionsCPU->bullyPushSolutions[m].doubleTenKSolutionIdx].tenKSolutionIdx < slideSol->tenKSolutionIdx) {
                m++;
            }

            int n = m;

            while (n < countsCPU->nBullyPushSolutions && solutionsCPU->doubleTenKSolutions[solutionsCPU->bullyPushSolutions[n].doubleTenKSolutionIdx].tenKSolutionIdx == slideSol->tenKSolutionIdx) {
                struct BullyPushSolution* bpSol = &(solutionsCPU->bullyPushSolutions[n]);
                struct DoubleTenKSolution* doubleTenKSol = &(solutionsCPU->doubleTenKSolutions[bpSol->doubleTenKSolutionIdx]);

                //if (!o->silent) printf("---------------------------------------\nFound Solution:\n---------------------------------------\n    Start Position Range: [%.10g, %.10g], [%.10g, %.10g]\n    Frame 1 Position: %.10g, %.10g, %.10g\n    Frame 2 Position: %.10g, %.10g, %.10g\n    Return Position: %.10g, %.10g, %.10g\n    PU Departure Speed: %.10g (x=%.10g, z=%.10g)\n    PU Strain Speed: (x=%.10g, z=%.10g, fwd=%.10g)\n    Pre-10K Speed: (x=%.10g, z=%.10g)\n    PU Return Speed: %.10g (x=%.10g, z=%.10g)\n    Frame 1 Q-steps: %d\n    Frame 2 Q-steps: %d\n    Frame 3 Q-steps: %d\n", doubleTenKSol->minStartX, doubleTenKSol->maxStartX, doubleTenKSol->minStartZ, doubleTenKSol->maxStartZ, tenKSol->frame1Position[0], tenKSol->frame1Position[1], tenKSol->frame1Position[2], tenKSol->frame2Position[0], tenKSol->frame2Position[1], tenKSol->frame2Position[2], platSol->returnPosition[0], platSol->returnPosition[1], platSol->returnPosition[2], tenKSol->departureSpeed, doubleTenKSol->post10KXVel, doubleTenKSol->post10KZVel, speedSol->xStrain, speedSol->zStrain, speedSol->forwardStrain, tenKSol->pre10KVel[0], tenKSol->pre10KVel[1], speedSol->returnSpeed, tenKSol->returnVel[0], tenKSol->returnVel[1], 4, p1Sol->q2, 1);
                //if (!o->silent) printf("    10k Stick X: %d\n    10k Stick Y: %d\n    Frame 2 HAU: %d\n    10k Camera Yaw: %d\n    Start Floor Normal: %.10g, %.10g, %.10g\n", ((p5Sol->stickX == 0) ? 0 : ((p5Sol->stickX < 0) ? p5Sol->stickX - 6 : p5Sol->stickX + 6)), ((p5Sol->stickY == 0) ? 0 : ((p5Sol->stickY < 0) ? p5Sol->stickY - 6 : p5Sol->stickY + 6)), p2Sol->f2Angle, p4Sol->cameraYaw, host_norms[3 * x], host_norms[3 * x + 1], host_norms[3 * x + 2]);
                //if (!o->silent) printf("---------------------------------------\n    Tilt Frames: %d\n    Post-Tilt Platform Normal: %.10g, %.10g, %.10g\n    Post-Tilt Position: %.10g, %.10g, %.10g\n    Pre-Upwarp Position: %.10g, %.10g, %.10g\n    Post-Upwarp Position: %.10g, %.10g, %.10g\n    Upwarp PU X: %d\n    Upwarp PU Z: %d\n    Upwarp Slide Facing Angle: %d\n    Upwarp Slide Intended Mag: %.10g\n    Upwarp Slide Intended DYaw: %d\n", platSol->nFrames, platSol->endNormal[0], platSol->endNormal[1], platSol->endNormal[2], platSol->endPosition[0], platSol->endPosition[1], platSol->endPosition[2], slideSol->preUpwarpPosition[0], slideSol->preUpwarpPosition[1], slideSol->preUpwarpPosition[2], slideSol->upwarpPosition[0], slideSol->upwarpPosition[1], slideSol->upwarpPosition[2], uwSol->pux, uwSol->puz, slideSol->angle, slideSol->stickMag, slideSol->intendedDYaw);
                //if (!o->silent) printf("---------------------------------------\n    Post-Breakdance Camera Yaw: %d\n    Post-Breakdance Stick X: %d\n    Post-Breakdance Stick Y: %d\n    Landing Position: %.10g, %.10g, %.10g\n    Landing Speed: %.10g\n---------------------------------------\n\n\n", bdSol->cameraYaw, bdSol->stickX, bdSol->stickY, bdSol->landingPosition[0], bdSol->landingPosition[1], bdSol->landingPosition[2], bdSol->postSlideSpeed);
                //if (!o->silent) printf("---------------------------------------\n    Squish Push Position Range: [%.10g, %.10g], [%.10g, %.10g]\n    Squish Push Q-steps: %d\n    Bully Position Range: [%.10g, %.10g], [%.10g, %.10g]\n    Bully Push Angle: %d\n    Max Bully Speed: %.10g\n    Min Sliding Spped: (x=%.10g, z=%.10g)\n---------------------------------------\n\n\n", bpSol->squishPushMinX, bpSol->squishPushMaxX, bpSol->squishPushMinZ, bpSol->squishPushMaxZ, bpSol->squishPushQF, bpSol->bullyMinX, bpSol->bullyMaxX, bpSol->bullyMinZ, bpSol->bullyMaxZ, bpSol->pushAngle, bpSol->maxSpeed, bpSol->minSlidingSpeedX, bpSol->minSlidingSpeedZ);
                
                wf << float2string_max(startNormal[0], 1) << "," << float2string_max(startNormal[1], 1) << "," << float2string_max(startNormal[2], 1) << ",";
                wf << doubleTenKSol->minStartX << "," << doubleTenKSol->maxStartX << ",";
                wf << doubleTenKSol->minStartZ << "," << doubleTenKSol->maxStartZ << ",";
                wf << tenKSol->frame1Position[0] << "," << tenKSol->frame1Position[1] << "," << tenKSol->frame1Position[2] << ",";
                wf << tenKSol->frame2Position[0] << "," << tenKSol->frame2Position[1] << "," << tenKSol->frame2Position[2] << ",";
                wf << platSol->returnPosition[0] << "," << platSol->returnPosition[1] << "," << platSol->returnPosition[2] << ",";
                wf << tenKSol->departureSpeed << "," << doubleTenKSol->post10KXVel << "," << doubleTenKSol->post10KZVel << ",";
                wf << speedSol->xStrain << "," << speedSol->zStrain << "," << speedSol->forwardStrain << ",";
                wf << tenKSol->pre10KVel[0] << "," << tenKSol->pre10KVel[1] << ",";
                wf << speedSol->returnSpeed << "," << tenKSol->returnVel[0] << "," << tenKSol->returnVel[1] << ",";
                wf << 4 << "," << p1Sol->q2 << "," << 1 << ",";
                wf << ((p5Sol->stickX == 0) ? 0 : ((p5Sol->stickX < 0) ? p5Sol->stickX - 6 : p5Sol->stickX + 6)) << "," << ((p5Sol->stickY == 0) ? 0 : ((p5Sol->stickY < 0) ? p5Sol->stickY - 6 : p5Sol->stickY + 6)) << ",";
                wf << p2Sol->f2Angle << "," << p4Sol->cameraYaw << ",";
                wf << p->host_norms[3 * floorIdx] << "," << p->host_norms[3 * floorIdx + 1] << "," << p->host_norms[3 * floorIdx + 2] << ",";
                wf << platSol->nFrames << ",";
                wf << platSol->endNormal[0] << "," << platSol->endNormal[1] << "," << platSol->endNormal[2] << ",";
                wf << platSol->endPosition[0] << "," << platSol->endPosition[1] << "," << platSol->endPosition[2] << ",";
                wf << slideSol->preUpwarpPosition[0] << "," << slideSol->preUpwarpPosition[1] << "," << slideSol->preUpwarpPosition[2] << ",";
                wf << slideSol->upwarpPosition[0] << "," << slideSol->upwarpPosition[1] << "," << slideSol->upwarpPosition[2] << ",";
                wf << uwSol->pux << "," << uwSol->puz << ",";
                wf << slideSol->angle << "," << slideSol->stickMag << "," << slideSol->intendedDYaw << ",";
                wf << bdSol->cameraYaw << ",";
                wf << bdSol->stickX << "," << bdSol->stickY << ",";
                wf << bdSol->landingPosition[0] << "," << bdSol->landingPosition[1] << "," << bdSol->landingPosition[2] << ",";
                wf << bdSol->postSlideSpeed << ",";
                wf << bpSol->squishPushMinX << "," << bpSol->squishPushMaxX << "," << bpSol->squishPushMinZ << "," << bpSol->squishPushMaxZ << "," << bpSol->squishPushQF << ",";
                wf << bpSol->bullyMinX << "," << bpSol->bullyMaxX << "," << bpSol->bullyMinZ << "," << bpSol->bullyMaxZ << "," << bpSol->pushAngle << ",";
                wf << bpSol->maxSpeed << "," << bpSol->minSlidingSpeedX << "," << bpSol->minSlidingSpeedZ << ",";
                wf << bpSol->marioMinX << "," << bpSol->marioMaxX << "," << bpSol->marioMinZ << "," << bpSol->marioMaxZ << "," << bpSol->marioMaxY << endl;

                n++;
            }
        }
    }
}

void write_line_to_log_file(LogType type, std::string content, std::ofstream& logf) {
    std::time_t current_time = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    logf << (char)type << " [" << std::put_time(std::localtime(&current_time), "%c") << "] - " << content << std::endl;
}

void initialise_solution_file_stream(std::ofstream& wf, std::string outFile, struct FSTOptions* o) {
    initialise_solution_file_stream(wf, outFile, o, false);
}

void initialise_solution_file_stream(std::ofstream& wf, std::string outFile, struct FSTOptions* o, bool resume) {
    if (resume) {
        wf.open(outFile, std::ofstream::app);
    } 
    else {
        wf.open(outFile, std::ofstream::trunc);
    }

    if (wf.is_open()) {
        wf << std::fixed;

        if (!resume) {
            write_solution_file_header(o->outputLevel, wf);
        }
    }
    else {
        if (!o->silent) fprintf(stderr, "Warning: ofstream is not open. No solutions will be written to the output file.\n");
        if (!o->silent) fprintf(stderr, "         This may be due to an invalid output file path.\n");
    }
}

void write_solution_file_header(int outputLevel, std::ofstream& wf) {
    wf << "Start Normal X,Start Normal Y,Start Normal Z";

    if (outputLevel == 0) {
        wf << ",Number of Solutions";
    }
    else if (outputLevel == 1) {
        wf << ",Latest Stage Reached";
    }
    else if (outputLevel == 2) {
        wf << ",";
        wf << "Start Position Min X,Start Position Max X,";
        wf << "Start Position Min Z,Start Position Max Z,";
        wf << "Frame 1 Position X,Frame 1 Position Y,Frame 1 Position Z,";
        wf << "Frame 2 Position X,Frame 2 Position Y,Frame 2 Position Z,";
        wf << "Return Position X,Return Position Y,Return Position Z,";
        wf << "Departure Speed,Departure X Velocity,Departure Z Velocity,";
        wf << "Frame 2 Strain X Velocity,Frame 2 Strain Z Velocity,Frame 2 Strain Forward Speed,";
        wf << "Pre-10K X Velocity, Pre-10K Z Velocity,";
        wf << "Return Speed,Return X Velocity,Return Z Velocity,";
        wf << "Frame 1 Q-steps,Frame 2 Q-steps,Frame 3 Q-steps,";
        wf << "10K Stick X,10K Stick Y,";
        wf << "Frame 2 HAU,10K Camera Yaw,";
        wf << "Start Floor Normal X,Start Floor Normal Y,Start Floor Normal Z,";
        wf << "Number of Tilt Frames,";
        wf << "Post-Tilt Platform Normal X,Post-Tilt Platform Normal Y,Post-Tilt Platform Normal Z,";
        wf << "Post-Tilt Position X,Post-Tilt Position Y,Post-Tilt Position Z,";
        wf << "Pre-Upwarp Position X,Pre-Upwarp Position Y,Pre-Upwarp Position Z,";
        wf << "Post-Upwarp Position X,Post-Upwarp Position Y,Post-Upwarp Position Z,";
        wf << "Upwarp PU X,Upwarp PU Z,";
        wf << "Upwarp Slide Facing Angle,Upwarp Slide IntendedMag,Upwarp Slide IntendedDYaw,";
        wf << "Post-Breakdance Camera Yaw,";
        wf << "Post-Breakdance Stick X,Post-Breakdance Stick Y,";
        wf << "Landing Position X,Landing Position Y,Landing Position Z,";
        wf << "Landing Speed,";
        wf << "Squish Push Min X,Squish Push Max X,Squish Push Min Z,Squish Push Max Z,Squish Push Q-steps,";
        wf << "Bully Min X,Bully Max X,Bully Min Z,Bully Max Z,Bully Push HAU,";
        wf << "Max Bully Push Speed,Min X Sliding Speed,Min Z Sliding Speed,";
        wf << "Mario Min X,Mario Max X,Mario Min Z,Mario Max Z, Mario Max Y";
    }

    wf << endl;
}

FSTOutput check_normal(float* startNormal, struct FSTOptions* o, struct FSTData* p, std::ofstream& wf) {
    std::ofstream logf;

    return check_normal(startNormal, o, p, wf, logf);
}

FSTOutput check_normal(float* startNormal, struct FSTOptions* o, struct FSTData* p, std::ofstream& wf, std::ofstream& logf) {
    FSTOutput output;

    const float normal_offsets_cpu[4][3] = { {0.01f, -0.01f, 0.01f}, {-0.01f, -0.01f, 0.01f}, {-0.01f, -0.01f, -0.01f}, {0.01f, -0.01f, -0.01f} };

    Vec3f preStartNormal = { (startNormal[0] + (startNormal[0] > 0 ? 0.01f : -0.01f)) + (startNormal[0] > 0 ? 0.01f : -0.01f) , (startNormal[1] - 0.01f) - 0.01f, (startNormal[2] + (startNormal[2] > 0 ? 0.01f : -0.01f)) + (startNormal[2] > 0 ? 0.01f : -0.01f) };
    Vec3f offPlatformPosition = { o->platformPos[0], 2000.0f, o->platformPos[2] };

    Platform platform0 = Platform(o->platformPos[0], o->platformPos[1], o->platformPos[2], preStartNormal);
    platform0.platform_logic(offPlatformPosition);

    Platform platform1 = Platform(o->platformPos[0], o->platformPos[1], o->platformPos[2], platform0.normal);
    platform1.platform_logic(offPlatformPosition);

    startNormal[0] = platform1.normal[0];
    startNormal[1] = platform1.normal[1];
    startNormal[2] = platform1.normal[2];

    set_platform_normal<<<1, 1>>>(startNormal[0], startNormal[1], startNormal[2]);
    set_platform_pos<<<1, 1>>>(o->platformPos[0], o->platformPos[1], o->platformPos[2]);

    float ceilingNormals[4] = { platform1.ceilings[0].normal[1], platform1.ceilings[1].normal[1], platform1.ceilings[2].normal[1], platform1.ceilings[3].normal[1] };
    bool squishTest = (ceilingNormals[0] > -0.5f) || (ceilingNormals[1] > -0.5f) || (ceilingNormals[2] > -0.5f) || (ceilingNormals[3] > -0.5f);

    if (!squishTest) {
        return output;
    }

    int uphillAngle = (unsigned short)atan2s(-platform1.normal[2], -platform1.normal[0]);

    Platform platform = Platform(o->platformPos[0], o->platformPos[1], o->platformPos[2], platform1.normal);
    platform.platform_logic(offPlatformPosition);

    for (int x = 0; x < 2; x++) {
        for (int y = 0; y < 3; y++) {
            p->host_tris[9 * x + 3 * y] = platform.triangles[x].vectors[y][0];
            p->host_tris[9 * x + 3 * y + 1] = platform.triangles[x].vectors[y][1];
            p->host_tris[9 * x + 3 * y + 2] = platform.triangles[x].vectors[y][2];
            p->host_norms[3 * x + y] = platform.triangles[x].normal[y];
            p->host_tris[18 + 9 * x + 3 * y] = platform1.triangles[x].vectors[y][0];
            p->host_tris[18 + 9 * x + 3 * y + 1] = platform1.triangles[x].vectors[y][1];
            p->host_tris[18 + 9 * x + 3 * y + 2] = platform1.triangles[x].vectors[y][2];
            p->host_norms[6 + 3 * x + y] = platform1.triangles[x].normal[y];
        }
    }
                    
    hipMemcpy(p->dev_tris, p->host_tris, 36 * sizeof(short), hipMemcpyHostToDevice);
    hipMemcpy(p->dev_norms, p->host_norms, 12 * sizeof(float), hipMemcpyHostToDevice);

    set_start_triangle<<<1, 1>>>(p->dev_tris, p->dev_norms);

    for (int x = 0; x < 4; x++) {
        for (int y = 0; y < 3; y++) {
            p->host_ceiling_tris[9 * x + 3 * y] = platform0.ceilings[x].vectors[y][0];
            p->host_ceiling_tris[9 * x + 3 * y + 1] = platform0.ceilings[x].vectors[y][1];
            p->host_ceiling_tris[9 * x + 3 * y + 2] = platform0.ceilings[x].vectors[y][2];
            p->host_ceiling_norms[3 * x + y] = platform0.ceilings[x].normal[y];

            p->host_ceiling_tris[36 + 9 * x + 3 * y] = platform1.ceilings[x].vectors[y][0];
            p->host_ceiling_tris[36 + 9 * x + 3 * y + 1] = platform1.ceilings[x].vectors[y][1];
            p->host_ceiling_tris[36 + 9 * x + 3 * y + 2] = platform1.ceilings[x].vectors[y][2];
            p->host_ceiling_norms[12 + 3 * x + y] = platform1.ceilings[x].normal[y];

            p->host_ceiling_tris[72 + 9 * x + 3 * y] = platform.ceilings[x].vectors[y][0];
            p->host_ceiling_tris[72 + 9 * x + 3 * y + 1] = platform.ceilings[x].vectors[y][1];
            p->host_ceiling_tris[72 + 9 * x + 3 * y + 2] = platform.ceilings[x].vectors[y][2];
            p->host_ceiling_norms[24 + 3 * x + y] = platform.ceilings[x].normal[y];
        }
    }

    hipMemcpy(p->dev_ceiling_tris, p->host_ceiling_tris, 108 * sizeof(short), hipMemcpyHostToDevice);
    hipMemcpy(p->dev_ceiling_norms, p->host_ceiling_norms, 36 * sizeof(float), hipMemcpyHostToDevice);

    set_squish_spots<<<1, 1>>>(p->dev_ceiling_tris, p->dev_ceiling_norms);

    if (!o->silent) {
        bool squishCheck = false;

        hipMemcpy(p->hostNSquishSpots, p->devNSquishSpots, 4 * sizeof(int), hipMemcpyDeviceToHost);

        for (int ceilIdx = 0; ceilIdx < 4; ceilIdx++) {
            squishCheck |= (p->hostNSquishSpots[ceilIdx] > o->limits.MAX_SQUISH_SPOTS);
        }

        if (squishCheck) {
            output.flags |= SW_FLAG_SQUISH_SPOT;
            fprintf(stderr, "Warning: Number of squish spots for this normal has been exceeded. No more squish spots for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
            char logContent[200];
            sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Squish Spot Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
            write_line_to_log_file(LOG_WARNING, logContent, logf);
        }
    }

    struct SolStruct solutionsCPU;
    struct SolCounts countsCPU;

    Vec3f postTiltNormal = { platform.normal[0], platform.normal[1], platform.normal[2] };
                    
    for (int t = 0; t < 4; t++) {
        platform.normal[0] = postTiltNormal[0] + normal_offsets_cpu[t][0];
        platform.normal[1] = postTiltNormal[1] + normal_offsets_cpu[t][1];
        platform.normal[2] = postTiltNormal[2] + normal_offsets_cpu[t][2];

        for (int k = 2; k < o->nPUFrames; k++) {
            platform.platform_logic(offPlatformPosition);
        }

        float minX = INT16_MAX;
        float maxX = INT16_MIN;
        float minZ = INT16_MAX;
        float maxZ = INT16_MIN;

        for (int k = 0; k < platform.triangles.size(); k++) {
            minX = fminf(fminf(fminf(minX, platform.triangles[k].vectors[0][0]), platform.triangles[k].vectors[1][0]), platform.triangles[k].vectors[2][0]);
            maxX = fmaxf(fmaxf(fmaxf(maxX, platform.triangles[k].vectors[0][0]), platform.triangles[k].vectors[1][0]), platform.triangles[k].vectors[2][0]);
            minZ = fminf(fminf(fminf(minZ, platform.triangles[k].vectors[0][2]), platform.triangles[k].vectors[1][2]), platform.triangles[k].vectors[2][2]);
            maxZ = fmaxf(fmaxf(fmaxf(maxZ, platform.triangles[k].vectors[0][2]), platform.triangles[k].vectors[1][2]), platform.triangles[k].vectors[2][2]);
        }
                        
        int nX = round((maxX - minX) / o->deltaX) + 1;
        int nZ = round((maxZ - minZ) / o->deltaZ) + 1;

        countsCPU.nPlatSolutions = 0;
        countsCPU.nUpwarpSolutions = 0;

        hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU.nPlatSolutions), sizeof(int), offsetof(struct SolCounts, nPlatSolutions), hipMemcpyHostToDevice);

        long long int nBlocks = (nX * nZ + o->nThreads - 1) / o->nThreads;

        simulate_tilts<<<nBlocks, o->nThreads>>>(minX, o->deltaX, minZ, o->deltaZ, nX, nZ, platform.normal[0], platform.normal[1], platform.normal[2], o->maxFrames);
        output.hipError_t = hipGetLastError();
        if (output.hipError_t != 0x0) return output;

        hipMemcpyFromSymbol(&(countsCPU.nPlatSolutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nPlatSolutions), hipMemcpyDeviceToHost);
                  
        if (countsCPU.nPlatSolutions > 0) {
            output.bestStage = max(output.bestStage, STAGE_PLATFORM);

            if (countsCPU.nPlatSolutions > o->limits.MAX_PLAT_SOLUTIONS) {
                output.flags |= SW_FLAG_PLATFORM;
                if (!o->silent) fprintf(stderr, "Warning: Number of platform tilt solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
                countsCPU.nPlatSolutions = o->limits.MAX_PLAT_SOLUTIONS;
                char logContent[200];
                sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Platform Tilt Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
                write_line_to_log_file(LOG_WARNING, logContent, logf);
            }

            //if (!o->silent) printf("---------------------------------------\nTesting Normal: %.10g, %.10g, %.10g\n", startNormal[0], startNormal[1], startNormal[2]);
            //if (!o->silent) printf("        # Platform Solutions: %d\n", countsCPU.nPlatSolutions);

            nBlocks = (countsCPU.nPlatSolutions + o->nThreads - 1) / o->nThreads;

            hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU.nUpwarpSolutions), sizeof(int), offsetof(struct SolCounts, nUpwarpSolutions), hipMemcpyHostToDevice);

            find_upwarp_solutions<<<nBlocks, o->nThreads>>>(1000000000.0f);
            output.hipError_t = hipGetLastError();
            if (output.hipError_t != 0x0) return output;

            hipMemcpyFromSymbol(&(countsCPU.nUpwarpSolutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nUpwarpSolutions), hipMemcpyDeviceToHost);
        }

        if (countsCPU.nUpwarpSolutions > 0) {
            output.bestStage = max(output.bestStage, STAGE_UPWARP);

            if (countsCPU.nUpwarpSolutions > o->limits.MAX_UPWARP_SOLUTIONS) {
                output.flags |= SW_FLAG_UPWARP;
                if (!o->silent) fprintf(stderr, "Warning: Number of upwarp solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
                countsCPU.nUpwarpSolutions = o->limits.MAX_UPWARP_SOLUTIONS;
                char logContent[200];
                sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Upwarp Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
                write_line_to_log_file(LOG_WARNING, logContent, logf);
            }

            //if (!o->silent) printf("        # Upwarp Solutions: %d\n", countsCPU.nUpwarpSolutions);

            bool sameNormal = p->host_norms[1] == p->host_norms[4];

            for (int x = 0; x < (sameNormal ? 1 : 2); x++) {
                for (int y = 0; y < 3; y++) {
                    p->floorPoints[3 * y] = p->host_tris[9 * x + 3 * y];
                    p->floorPoints[3 * y + 1] = p->host_tris[9 * x + 3 * y + 1];
                    p->floorPoints[3 * y + 2] = p->host_tris[9 * x + 3 * y + 2];
                }

                if (sameNormal) {
                    p->floorPoints[9] = p->host_tris[15];
                    p->floorPoints[10] = p->host_tris[16];
                    p->floorPoints[11] = p->host_tris[17];
                }

                p->squishEdges[0] = (x == 0) ? 2 : -1;
                p->squishEdges[1] = (x == 0) ? 0 : 1;
                p->squishEdges[2] = (sameNormal || x == 1) ? (sameNormal ? 1 : 3) : -1;
                p->squishEdges[3] = sameNormal ? 3 : -1;

                for (int y = 0; y < 4; y++) {
                    if (p->squishEdges[y] != -1 && ceilingNormals[p->squishEdges[y]] <= -0.5f) {
                        p->squishEdges[y] = -1;
                    }
                }

                hipMemcpy(p->devSquishEdges, p->squishEdges, 4 * sizeof(int), hipMemcpyHostToDevice);

                countsCPU.nSK6Solutions = 0;
                countsCPU.nSKUWSolutions = 0;
                countsCPU.nSpeedSolutions = 0;
                countsCPU.n10KSolutions = 0;
                countsCPU.nDouble10KSolutions = 0;
                countsCPU.nBullyPushSolutions = 0;
                countsCPU.nSlideSolutions = 0;
                countsCPU.nBDSolutions = 0;
                countsCPU.nFullSolutions = 0;

                int nStrainSetupsCPU = 0;

                find_slide_kick_setup_triangle(startNormal, p->floorPoints, p->devFloorPoints, sameNormal ? 4 : 3, p->host_norms[3 * x + 1], t, o, &countsCPU, logf, output);

                hipMemcpyFromSymbol(&(countsCPU.nSK6Solutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nSK6Solutions), hipMemcpyDeviceToHost);

                if (countsCPU.nSK6Solutions > 0) {
                    output.bestStage = max(output.bestStage, STAGE_SLIDE_KICK);

                    if (countsCPU.nSK6Solutions > o->limits.MAX_SK_PHASE_SIX) {
                        output.flags |= SW_FLAG_SLIDE_KICK_6;
                        if (!o->silent) fprintf(stderr, "Warning: Number of slide kick phase 6 solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
                        countsCPU.nSK6Solutions = o->limits.MAX_SK_PHASE_SIX;
                        char logContent[200];
                        sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Slide Kick Phase 6 Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
                        write_line_to_log_file(LOG_WARNING, logContent, logf);
                    }

                    //if (!o->silent) printf("        # Slide Kick Routes: %d\n", countsCPU.nSK6Solutions);

                    nBlocks = (countsCPU.nUpwarpSolutions + o->nThreads - 1) / o->nThreads;

                    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU.nSKUWSolutions), sizeof(int), offsetof(struct SolCounts, nSKUWSolutions), hipMemcpyHostToDevice);

                    reset_ranges<<<1, 1>>>();
                    find_sk_upwarp_solutions<<<nBlocks, o->nThreads>>>();
                    output.hipError_t = hipGetLastError();
                    if (output.hipError_t != 0x0) return output;

                    hipMemcpyFromSymbol(&(countsCPU.nSKUWSolutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nSKUWSolutions), hipMemcpyDeviceToHost);
                }

                if (countsCPU.nSKUWSolutions > 0) {
                    output.bestStage = max(output.bestStage, STAGE_SKUW);

                    if (countsCPU.nSKUWSolutions > o->limits.MAX_SK_UPWARP_SOLUTIONS) {
                        output.flags |= SW_FLAG_SKUW;
                        if (!o->silent) fprintf(stderr, "Warning: Number of slide kick upwarp solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
                        countsCPU.nSKUWSolutions = o->limits.MAX_SK_UPWARP_SOLUTIONS;
                        char logContent[200];
                        sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Slide Kick Upwarp Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
                        write_line_to_log_file(LOG_WARNING, logContent, logf);
                    }

                    //if (!o->silent) printf("        # Slide Kick Upwarp Solutions: %d\n", countsCPU.nSKUWSolutions);

                    generate_strain_setups<<<1, 1>>>();
                    output.hipError_t = hipGetLastError();
                    if (output.hipError_t != 0x0) return output;

                    hipMemcpyFromSymbol(&nStrainSetupsCPU, HIP_SYMBOL(nStrainSetups), sizeof(int), 0, hipMemcpyDeviceToHost);

                    if (nStrainSetupsCPU > o->limits.MAX_STRAIN_SETUPS) {
                        output.flags |= SW_FLAG_STRAIN_SETUP;
                        if (!o->silent) fprintf(stderr, "Warning: Number of strain setups for this normal has been exceeded. No more setups for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
                        nStrainSetupsCPU = o->limits.MAX_STRAIN_SETUPS;
                        char logContent[200];
                        sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Strain Setup Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
                        write_line_to_log_file(LOG_WARNING, logContent, logf);
                    }

                    nBlocks = (((long long int)countsCPU.nSKUWSolutions*(long long int)nStrainSetupsCPU) + o->nThreads - 1) / o->nThreads;

                    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU.nSpeedSolutions), sizeof(int), offsetof(struct SolCounts, nSpeedSolutions), hipMemcpyHostToDevice);

                    find_speed_solutions<<<nBlocks, o->nThreads>>>();
                    output.hipError_t = hipGetLastError();
                    if (output.hipError_t != 0x0) return output;

                    hipMemcpyFromSymbol(&(countsCPU.nSpeedSolutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nSpeedSolutions), hipMemcpyDeviceToHost);
                }

                if (countsCPU.nSpeedSolutions > 0) {
                    output.bestStage = max(output.bestStage, STAGE_SPEED);

                    if (countsCPU.nSpeedSolutions > o->limits.MAX_SPEED_SOLUTIONS) {
                        output.flags |= SW_FLAG_SPEED;
                        if (!o->silent) fprintf(stderr, "Warning: Number of speed solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
                        countsCPU.nSpeedSolutions = o->limits.MAX_SPEED_SOLUTIONS;
                        char logContent[200];
                        sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Speed Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
                        write_line_to_log_file(LOG_WARNING, logContent, logf);
                    }

                    //if (!o->silent) printf("        # Speed Solutions: %d\n", countsCPU.nSpeedSolutions);

                    nBlocks = (countsCPU.nSpeedSolutions + o->nThreads - 1) / o->nThreads;

                    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU.n10KSolutions), sizeof(int), offsetof(struct SolCounts, n10KSolutions), hipMemcpyHostToDevice);

                    test_speed_solution<<<nBlocks, o->nThreads>>>(p->devSquishEdges, sameNormal ? 4 : 3, p->host_norms[3 * x + 1], uphillAngle, o->maxSlidingSpeed, o->maxSlidingSpeedToPlatform);
                    output.hipError_t = hipGetLastError();
                    if (output.hipError_t != 0x0) return output;

                    hipMemcpyFromSymbol(&(countsCPU.n10KSolutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, n10KSolutions), hipMemcpyDeviceToHost);
                }

                if (countsCPU.n10KSolutions > 0) {
                    output.bestStage = max(output.bestStage, STAGE_TEN_K);

                    if (countsCPU.n10KSolutions > o->limits.MAX_10K_SOLUTIONS) {
                        output.flags |= SW_FLAG_TEN_K;
                        if (!o->silent) fprintf(stderr, "Warning: Number of 10K solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
                        countsCPU.n10KSolutions = o->limits.MAX_10K_SOLUTIONS;
                        char logContent[200];
                        sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - 10K Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
                        write_line_to_log_file(LOG_WARNING, logContent, logf);
                    }

                    if (!o->silent) printf("---------------------------------------\nTesting Normal: %g, %g, %g\n", startNormal[0], startNormal[1], startNormal[2]);
                    if (!o->silent) printf("        # Platform Solutions: %d\n", countsCPU.nPlatSolutions);
                    if (!o->silent) printf("        # Upwarp Solutions: %d\n", countsCPU.nUpwarpSolutions);
                    if (!o->silent) printf("        # Slide Kick Routes: %d\n", countsCPU.nSK6Solutions);
                    if (!o->silent) printf("        # Slide Kick Upwarp Solutions: %d\n", countsCPU.nSKUWSolutions);
                    if (!o->silent) printf("        # Speed Solutions: %d\n", countsCPU.nSpeedSolutions);
                    if (!o->silent) printf("        # 10K Solutions: %d\n", countsCPU.n10KSolutions);

                    int maxAngleRangeCPU = 0;

                    hipMemcpyToSymbol(HIP_SYMBOL(maxAngleRange), &maxAngleRangeCPU, sizeof(int), 0, hipMemcpyHostToDevice);

                    find_slide_solutions<<<nBlocks, o->nThreads>>>();
                    output.hipError_t = hipGetLastError();
                    if (output.hipError_t != 0x0) return output;

                    hipMemcpyFromSymbol(&maxAngleRangeCPU, HIP_SYMBOL(maxAngleRange), sizeof(int), 0, hipMemcpyDeviceToHost);

                    if (maxAngleRangeCPU > 0) {
                        nBlocks = ((maxAngleRangeCPU * countsCPU.n10KSolutions) + o->nThreads - 1) / o->nThreads;

                        hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU.nSlideSolutions), sizeof(int), offsetof(struct SolCounts, nSlideSolutions), hipMemcpyHostToDevice);
                        test_slide_angle<<<nBlocks, o->nThreads>>>();
                        output.hipError_t = hipGetLastError();
                        if (output.hipError_t != 0x0) return output;
                        hipMemcpyFromSymbol(&(countsCPU.nSlideSolutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nSlideSolutions), hipMemcpyDeviceToHost);
                    }
                }

                if (countsCPU.nSlideSolutions > 0) {
                    output.bestStage = max(output.bestStage, STAGE_SLIDE);

                    if (countsCPU.nSlideSolutions > o->limits.MAX_SLIDE_SOLUTIONS) {
                        output.flags |= SW_FLAG_SLIDE;
                        if (!o->silent) fprintf(stderr, "Warning: Number of slide solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
                        countsCPU.nSlideSolutions = o->limits.MAX_SLIDE_SOLUTIONS;
                        char logContent[200];
                        sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Slide Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
                        write_line_to_log_file(LOG_WARNING, logContent, logf);
                    }

                    if (!o->silent) printf("        # Slide Solutions: %d\n", countsCPU.nSlideSolutions);

                    int nUniqueSticksCPU;
                    hipMemcpyFromSymbol(&nUniqueSticksCPU, HIP_SYMBOL(nUniqueSticks), sizeof(int), 0, hipMemcpyDeviceToHost);

                    nBlocks = ((long long int)nUniqueSticksCPU * (long long int)countsCPU.nSlideSolutions + o->nThreads - 1) / o->nThreads;

                    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU.nBDSolutions), sizeof(int), offsetof(struct SolCounts, nBDSolutions), hipMemcpyHostToDevice);

                    find_breakdance_solutions<<<nBlocks, o->nThreads>>>();
                    output.hipError_t = hipGetLastError();
                    if (output.hipError_t != 0x0) return output;

                    hipMemcpyFromSymbol(&(countsCPU.nBDSolutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nBDSolutions), hipMemcpyDeviceToHost);
                }

                if (countsCPU.nBDSolutions > 0) {
                    output.bestStage = max(output.bestStage, STAGE_BREAKDANCE);

                    if (countsCPU.nBDSolutions > o->limits.MAX_BD_SOLUTIONS) {
                        output.flags |= SW_FLAG_BREAKDANCE;
                        if (!o->silent) fprintf(stderr, "Warning: Number of breakdance solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
                        countsCPU.nBDSolutions = o->limits.MAX_BD_SOLUTIONS;
                        char logContent[200];
                        sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Breakdance Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
                        write_line_to_log_file(LOG_WARNING, logContent, logf);
                    }

                    if (!o->silent) printf("        # Breakdance Solutions: %d\n", countsCPU.nBDSolutions);

                    nBlocks = (countsCPU.n10KSolutions + o->nThreads - 1) / o->nThreads;

                    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU.nDouble10KSolutions), sizeof(int), offsetof(struct SolCounts, nDouble10KSolutions), hipMemcpyHostToDevice);

                    find_double_10k_solutions<<<nBlocks, o->nThreads>>>();
                    output.hipError_t = hipGetLastError();
                    if (output.hipError_t != 0x0) return output;

                    hipMemcpyFromSymbol(&(countsCPU.nDouble10KSolutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nDouble10KSolutions), hipMemcpyDeviceToHost);
                }

                if (countsCPU.nDouble10KSolutions > 0) {
                    output.bestStage = max(output.bestStage, STAGE_DOUBLE_TEN_K);

                    if (countsCPU.nDouble10KSolutions > o->limits.MAX_DOUBLE_10K_SOLUTIONS) {
                        output.flags |= SW_FLAG_DOUBLE_TEN_K;
                        if (!o->silent) fprintf(stderr, "Warning: Number of double 10K solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
                        countsCPU.nDouble10KSolutions = o->limits.MAX_DOUBLE_10K_SOLUTIONS;
                        char logContent[200];
                        sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Double 10K Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
                        write_line_to_log_file(LOG_WARNING, logContent, logf);
                    }

                    if (!o->silent) printf("        # Double 10K Solutions: %d\n", countsCPU.nDouble10KSolutions);

                    nBlocks = (3 * countsCPU.nDouble10KSolutions + o->nThreads - 1) / o->nThreads;

                    hipMemcpyToSymbol(HIP_SYMBOL(counts), &(countsCPU.nBullyPushSolutions), sizeof(int), offsetof(struct SolCounts, nBullyPushSolutions), hipMemcpyHostToDevice);

                    find_bully_positions<<<nBlocks, o->nThreads>>>(uphillAngle, o->maxSlidingSpeed, o->maxSlidingSpeedToPlatform);
                    output.hipError_t = hipGetLastError();
                    if (output.hipError_t != 0x0) return output;

                    hipMemcpyFromSymbol(&(countsCPU.nBullyPushSolutions), HIP_SYMBOL(counts), sizeof(int), offsetof(struct SolCounts, nBullyPushSolutions), hipMemcpyDeviceToHost); 
                }

                if (countsCPU.nBullyPushSolutions > 0) {
                    output.bestStage = max(output.bestStage, STAGE_BULLY_PUSH);

                    if (countsCPU.nBullyPushSolutions > o->limits.MAX_BULLY_PUSH_SOLUTIONS) {
                        output.flags |= SW_FLAG_BULLY_PUSH;
                        if (!o->silent) fprintf(stderr, "Warning: Number of bully push solutions for this normal has been exceeded. No more solutions for this normal will be recorded. Increase the internal maximum to prevent this from happening. (Normal: %.10g, %.10g, %.10g)\n", startNormal[0], startNormal[1], startNormal[2]);
                        countsCPU.nBullyPushSolutions = o->limits.MAX_BULLY_PUSH_SOLUTIONS;
                        char logContent[200];
                        sprintf(logContent, "(%s, %s, %s) (%.10g, %.10g, %.10g) - Bully Push Solution Maximum Exceeded", float2string_max(startNormal[0], 1).c_str(), float2string_max(startNormal[1], 1).c_str(), float2string_max(startNormal[2], 1).c_str(), o->platformPos[0], o->platformPos[1], o->platformPos[2]);
                        write_line_to_log_file(LOG_WARNING, logContent, logf);
                    }

                    if (!o->silent) printf("        # Bully Push Solutions: %d\n", countsCPU.nBullyPushSolutions);

                    int bdRunningSum = 0;
                    int bpRunningSum = 0;

                    copy_solutions_to_cpu(p, &solutionsCPU, &countsCPU);

                    for (int l = 0; l < countsCPU.n10KSolutions; l++) {
                        countsCPU.nFullSolutions += solutionsCPU.tenKSolutions[l].bdSetups * solutionsCPU.tenKSolutions[l].bpSetups;
                        bdRunningSum += solutionsCPU.tenKSolutions[l].bdSetups;
                        solutionsCPU.tenKSolutions[l].bdSetups = bdRunningSum - solutionsCPU.tenKSolutions[l].bdSetups;
                        bpRunningSum += solutionsCPU.tenKSolutions[l].bpSetups;
                        solutionsCPU.tenKSolutions[l].bpSetups = bpRunningSum - solutionsCPU.tenKSolutions[l].bpSetups;
                    }
                }

                if (countsCPU.nFullSolutions > 0) {
                    output.bestStage = max(output.bestStage, STAGE_COMPLETE);

                    if (!o->silent) printf("        # Full Solutions: %d\n", countsCPU.nFullSolutions);
                }

                if (wf.is_open()) {
                    write_solutions_to_file(startNormal, o, p, &solutionsCPU, &countsCPU, x, wf);
                }
                else {
                    if (!o->silent) fprintf(stderr, "Warning: ofstream is not open. No solutions will be written to the output file.\n");
                }

                if (countsCPU.nBullyPushSolutions > 0) {
                    free_solution_pointers_cpu(&solutionsCPU);
                }
            }
        }
    }

    return output;
}

int initialise_fst_vars(struct FSTData* p, struct FSTOptions* o, std::ofstream& logf) {
    int hipError_t = 0;

    hipError_t |= hipSetDevice(o->hipDevice);

    if (hipError_t != 0) {
        if (hipError_t & hipErrorInvalidDevice) {
            if (!o->silent) fprintf(stderr, "Error: Device %d is not a valid hip device.\n", o->hipDevice);
            char logContent[200];
            sprintf(logContent, "Device %d is not a valid hip device", o->hipDevice);
            write_line_to_log_file(LOG_ERROR, logContent, logf);
        }
        else {
            if (!o->silent) fprintf(stderr, "Error: Setting hip device failed with error code: %d.\n", hipError_t);
            char logContent[200];
            sprintf(logContent, "Setting hip device failed with error code: %d", hipError_t);
            write_line_to_log_file(LOG_ERROR, logContent, logf);
        }

        return hipError_t;
    }

    init_reverse_atanG<<<1, 1>>>();
    init_camera_angles<<<1, 1>>>();
    init_mag_set<<<1, 1>>>();
    init_unique_stick_positions<<<1, 1>>>();
    initialise_floors<<<1, 1>>>();
    
    hipMemcpyToSymbol(HIP_SYMBOL(limits), &(o->limits), sizeof(GPULimits), 0, hipMemcpyHostToDevice);
    hipError_t |= init_solution_structs(&(p->s), &(o->limits));

    hipError_t |= hipMalloc((void**)&(p->devSquishSpots), 8 * o->limits.MAX_SQUISH_SPOTS * sizeof(float));
    hipError_t |= hipMalloc((void**)&(p->devNSquishSpots), 4 * sizeof(int));

    p->hostNSquishSpots = (int*)std::malloc(4 * sizeof(int));

    hipMemcpyToSymbol(HIP_SYMBOL(squishSpots), &(p->devSquishSpots), sizeof(float*), 0, hipMemcpyHostToDevice);
    hipMemcpyToSymbol(HIP_SYMBOL(nSquishSpots), &(p->devNSquishSpots), sizeof(int*), 0, hipMemcpyHostToDevice);

    hipError_t |= hipMalloc((void**)&(p->devStrainSetups), o->limits.MAX_STRAIN_SETUPS * sizeof(struct StrainSetup));

    hipMemcpyToSymbol(HIP_SYMBOL(strainSetups), &(p->devStrainSetups), sizeof(struct StrainSetup*), 0, hipMemcpyHostToDevice);

    p->host_tris = (short*)std::malloc(36 * sizeof(short));
    p->host_norms = (float*)std::malloc(12 * sizeof(float));

    hipError_t |= hipMalloc((void**)&(p->dev_tris), 36 * sizeof(short));
    hipError_t |= hipMalloc((void**)&(p->dev_norms), 12 * sizeof(float));

    p->host_ceiling_tris = (short*)std::malloc(108 * sizeof(short));
    p->host_ceiling_norms = (float*)std::malloc(36 * sizeof(float));

    hipError_t |= hipMalloc((void**)&(p->dev_ceiling_tris), 108 * sizeof(short));
    hipError_t |= hipMalloc((void**)&(p->dev_ceiling_norms), 36 * sizeof(float));

    p->floorPoints = (short*)std::malloc(4 * 3 * sizeof(short));
    hipError_t |= hipMalloc((void**)&(p->devFloorPoints), 4 * 3 * sizeof(short));

    p->squishEdges = (int*)std::malloc(4 * sizeof(int));
    hipError_t |= hipMalloc((void**)&(p->devSquishEdges), 4 * sizeof(int));

    if (hipError_t != 0) {
        if (hipError_t & hipErrorOutOfMemory) {
            if (!o->silent) fprintf(stderr, "Error: GPU memory allocation failed due to insufficient memory.\n");
            if (!o->silent) fprintf(stderr, "       It is recommended that you decrease the size of the\n");
            if (!o->silent) fprintf(stderr, "       reserved memory used for storing sub-solutions.\n");
            write_line_to_log_file(LOG_ERROR, "Device Memory Allocation Failed due to Insufficient Memory", logf);
        }
        else {
            if (!o->silent) fprintf(stderr, "Error: GPU memory allocation failed with error code: %d.\n", hipError_t);
            char logContent[200];
            sprintf(logContent, "Device Memory Allocation Failed with code %d", hipError_t);
            write_line_to_log_file(LOG_ERROR, logContent, logf);
        }
    }

    return hipError_t;
}

void free_fst_vars(struct FSTData* p) {
    std::free(p->host_tris);
    std::free(p->host_norms);
    std::free(p->host_ceiling_tris);
    std::free(p->host_ceiling_norms);
    std::free(p->floorPoints);
    std::free(p->squishEdges);
    std::free(p->hostNSquishSpots);
    hipFree(p->dev_tris);
    hipFree(p->dev_norms);
    hipFree(p->dev_ceiling_tris);
    hipFree(p->dev_ceiling_norms);
    hipFree(p->devFloorPoints);
    hipFree(p->devSquishEdges);
    hipFree(p->devSquishSpots);
    hipFree(p->devNSquishSpots);
    free_solution_pointers_gpu(&(p->s));
}

__global__ void hip_print_success() {
    printf("hip code completed successfully.\n");
}

void print_success() {
    hip_print_success<<<1, 1>>>();
}

__global__ void hip_test_device_true() {
    deviceTest = true;
}

__global__ void hip_test_device_false() {
    deviceTest = false;
}

bool test_device() {
    bool deviceTestCPU = false;
    hipMemcpyToSymbol(HIP_SYMBOL(deviceTest), &deviceTestCPU, sizeof(bool), 0, hipMemcpyHostToDevice);
    hip_test_device_true<<<1, 1>>>();
    hipMemcpyFromSymbol(&deviceTestCPU, HIP_SYMBOL(deviceTest), sizeof(bool), 0, hipMemcpyDeviceToHost);
    hip_test_device_false<<<1, 1>>>();

    return deviceTestCPU;
}
